<!-- filename: index.html -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Iterative Image Degrader</title>
<style>
  :root{
    --coffee-dark: #2B1810;
    --coffee-medium: #4A2C1A;
    --coffee-light: #8B6F47;
    --cream: #E8DCC4;
    --tan: #C9A87C;
    --gap:16px;
    font-family: 'Courier New', Courier, monospace;
  }
  * { box-sizing: border-box; }
  body{
    margin:0;
    padding:32px;
    background: var(--cream);
    color: var(--coffee-dark);
    min-height:100vh;
  }
  h1{
    font-size:42px;
    font-weight:900;
    margin:0 0 8px 0;
    text-transform:uppercase;
    letter-spacing:-1px;
    line-height:1;
  }
  .subtitle{
    font-size:14px;
    margin:0 0 32px 0;
    opacity:0.7;
    text-transform:uppercase;
    letter-spacing:2px;
  }
  .controls{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
    gap:var(--gap);
    margin-bottom:24px;
    background: var(--coffee-dark);
    padding:24px;
    border:4px solid var(--coffee-dark);
  }
  label{
    display:flex;
    flex-direction:column;
    font-size:11px;
    font-weight:700;
    text-transform:uppercase;
    letter-spacing:1px;
    color: var(--cream);
  }
  input[type="file"],
  input[type="number"]{
    margin-top:8px;
    padding:10px;
    border:3px solid var(--coffee-medium);
    background: var(--cream);
    color: var(--coffee-dark);
    font-family: inherit;
    font-size:14px;
    font-weight:700;
  }
  input[type="file"]{
    padding:8px;
    cursor:pointer;
  }
  input[type="number"]:focus{
    outline:none;
    border-color: var(--tan);
  }
  canvas{
    background: var(--coffee-medium);
    max-width:100%;
    max-height:calc(100vh - 400px);
    height:auto;
    border:6px solid var(--coffee-dark);
    display:block;
    margin:24px 0;
    object-fit:contain;
  }
  .action-bar{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
    margin-bottom:24px;
  }
  button{
    padding:14px 28px;
    border:4px solid var(--coffee-dark);
    background: var(--tan);
    color: var(--coffee-dark);
    font-family: inherit;
    font-size:13px;
    font-weight:900;
    text-transform:uppercase;
    letter-spacing:1px;
    cursor:pointer;
    transition: all 0.15s ease;
  }
  button:hover:not(:disabled){
    background: var(--coffee-dark);
    color: var(--cream);
    transform:translate(-2px, -2px);
    box-shadow: 4px 4px 0 var(--coffee-medium);
  }
  button:active:not(:disabled){
    transform:translate(0, 0);
    box-shadow: none;
  }
  button:disabled{
    opacity:0.4;
    cursor:not-allowed;
  }
  #download{
    padding:14px 28px;
    border:4px solid var(--coffee-dark);
    background: var(--coffee-light);
    color: var(--cream);
    text-decoration:none;
    font-family: inherit;
    font-size:13px;
    font-weight:900;
    text-transform:uppercase;
    letter-spacing:1px;
    transition: all 0.15s ease;
    display:inline-block;
  }
  #download:hover{
    background: var(--coffee-dark);
    transform:translate(-2px, -2px);
    box-shadow: 4px 4px 0 var(--coffee-medium);
  }
  #status{
    font-size:13px;
    font-weight:700;
    text-transform:uppercase;
    letter-spacing:1px;
    padding:14px 20px;
    background: var(--coffee-medium);
    color: var(--cream);
    border:3px solid var(--coffee-dark);
  }
</style>
</head>
<body>
<h1>Image Degrader</h1>
<p class="subtitle">Iterative Compression Tool</p>

<div class="controls">
  <label>Image Upload<input id="file" type="file" accept="image/*"></label>
  <label>Iterations
    <input id="iterations" type="number" min="1" max="200" value="5">
  </label>
  <label>JPEG Quality (0–1)
    <input id="quality" type="number" step="0.01" min="0" max="1" value="0.6">
  </label>
  <label>Downscale Factor
    <input id="downscale" type="number" step="0.1" min="1" max="4" value="1.5">
  </label>
  <label>Noise (0–1)
    <input id="noise" type="number" step="0.01" min="0" max="1" value="0.02">
  </label>
  <label>Posterize Levels
    <input id="posterize" type="number" step="1" min="1" max="32" value="32">
  </label>
</div>

<div class="action-bar">
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
  <a id="download" download="degraded.jpg">Download</a>
  <div id="status"></div>
</div>

<canvas id="canvas"></canvas>

<script>
const fileInput = document.getElementById('file');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const downloadLink = document.getElementById('download');
const status = document.getElementById('status');

let stopRequested = false;

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const imgBitmap = await createImageBitmap(f);
  // limit working size to reduce CPU
  const maxSide = 2048;
  const scale = Math.min(1, maxSide / Math.max(imgBitmap.width, imgBitmap.height));
  canvas.width = Math.round(imgBitmap.width * scale);
  canvas.height = Math.round(imgBitmap.height * scale);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
  // prepare download link for original
  canvas.toBlob(b => {
    downloadLink.href = URL.createObjectURL(b);
    downloadLink.download = 'degraded-start.jpg';
  }, 'image/jpeg', 0.95);
  status.textContent = 'Image loaded';
});

function applyNoise(imageData, strength) {
  if (strength <= 0) return;
  const d = imageData.data;
  const n = d.length;
  for (let i = 0; i < n; i += 4) {
    // gaussian-ish small noise
    const r = (Math.random() * 2 - 1) * 255 * strength;
    const g = (Math.random() * 2 - 1) * 255 * strength;
    const b = (Math.random() * 2 - 1) * 255 * strength;
    d[i] = Math.max(0, Math.min(255, d[i] + r));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + g));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + b));
  }
}

function applyPosterize(imageData, levels) {
  if (levels <= 1 || levels >= 256) return;
  const step = 255 / (levels - 1);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    d[i] = Math.round(d[i] / step) * step;
    d[i+1] = Math.round(d[i+1] / step) * step;
    d[i+2] = Math.round(d[i+2] / step) * step;
  }
}

async function canvasToBlobAsync(mime, quality) {
  return await new Promise(resolve => canvas.toBlob(resolve, mime, quality));
}

async function degradeLoop({iterations, quality, downscale, noise, posterize}) {
  stopRequested = false;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  const mime = 'image/jpeg'; // could be configurable
  for (let i = 0; i < iterations; ++i) {
    if (stopRequested) break;
    status.textContent = `Iteration ${i+1}/${iterations}`;
    // optional downscale/upscale to create blockiness
    if (downscale > 1) {
      // draw smaller then back up
      const w = Math.max(1, Math.round(canvas.width / downscale));
      const h = Math.max(1, Math.round(canvas.height / downscale));
      // create temporary canvas
      const tmp = document.createElement('canvas');
      tmp.width = w; tmp.height = h;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(canvas, 0, 0, w, h);
      // scale back
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.imageSmoothingEnabled = false; // produce blocky artifacts
      ctx.drawImage(tmp, 0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = true;
    }

    // pixel ops (noise, posterize)
    if (noise > 0 || posterize < 256) {
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (noise > 0) applyNoise(imageData, noise);
      if (posterize < 256) applyPosterize(imageData, posterize);
      ctx.putImageData(imageData, 0, 0);
    }

    // re-encode to create true compression artifacts
    const blob = await canvasToBlobAsync(mime, quality);
    if (!blob) break;
    // load compressed bytes back into canvas for next iteration
    const bmp = await createImageBitmap(blob);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(bmp, 0, 0, canvas.width, canvas.height);

    // yield to UI
    await new Promise(r => setTimeout(r, 8));
  }

  // make final blob and link
  const finalBlob = await canvasToBlobAsync('image/jpeg', quality);
  if (finalBlob) {
    downloadLink.href = URL.createObjectURL(finalBlob);
    downloadLink.download = `degraded-${Date.now()}.jpg`;
    status.textContent = stopRequested ? 'Stopped' : 'Done';
  } else {
    status.textContent = 'Failed to generate final file';
  }
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

startBtn.addEventListener('click', () => {
  const iterations = parseInt(document.getElementById('iterations').value, 10) || 1;
  const quality = parseFloat(document.getElementById('quality').value) || 0.6;
  const downscale = parseFloat(document.getElementById('downscale').value) || 1;
  const noise = parseFloat(document.getElementById('noise').value) || 0;
  const posterize = parseInt(document.getElementById('posterize').value, 10) || 256;
  degradeLoop({iterations, quality, downscale, noise, posterize});
});

stopBtn.addEventListener('click', () => {
  stopRequested = true;
});
</script>
</body>
</html>