<!-- filename: index.html -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Iterative Image Degrader</title>
<style>
  :root{font-family:system-ui,Segoe UI,Roboto,Arial;--gap:10px}
  body{margin:20px;background:#fff;color:#111}
  .controls{display:flex;flex-wrap:wrap;gap:var(--gap);margin-bottom:12px}
  label{display:flex;flex-direction:column;font-size:13px}
  canvas{background:#222;max-width:100%;height:auto;border:1px solid #ccc}
  .row{display:flex;gap:12px;align-items:center}
  button{padding:8px 12px}
</style>
</head>
<body>
<div class="controls">
  <label>Image upload<input id="file" type="file" accept="image/*"></label>
  <label>Iterations
    <input id="iterations" type="number" min="1" max="200" value="5">
  </label>
  <label>JPEG quality (0–1)
    <input id="quality" type="number" step="0.01" min="0" max="1" value="0.6">
  </label>
  <label>Downscale factor (1 = none)
    <input id="downscale" type="number" step="0.1" min="1" max="4" value="1.5">
  </label>
  <label>Noise (0–1)
    <input id="noise" type="number" step="0.01" min="0" max="1" value="0.02">
  </label>
  <label>Posterize levels (1 = none)
    <input id="posterize" type="number" step="1" min="1" max="32" value="32">
  </label>
</div>

<div class="row">
  <button id="start">Start Degrade</button>
  <button id="stop" disabled>Stop</button>
  <a id="download" style="margin-left:12px" download="degraded.jpg">Download final image</a>
  <div id="status" style="margin-left:12px;font-size:13px"></div>
</div>

<canvas id="canvas"></canvas>

<script>
const fileInput = document.getElementById('file');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const downloadLink = document.getElementById('download');
const status = document.getElementById('status');

let stopRequested = false;

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const imgBitmap = await createImageBitmap(f);
  // limit working size to reduce CPU
  const maxSide = 2048;
  const scale = Math.min(1, maxSide / Math.max(imgBitmap.width, imgBitmap.height));
  canvas.width = Math.round(imgBitmap.width * scale);
  canvas.height = Math.round(imgBitmap.height * scale);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
  // prepare download link for original
  canvas.toBlob(b => {
    downloadLink.href = URL.createObjectURL(b);
    downloadLink.download = 'degraded-start.jpg';
  }, 'image/jpeg', 0.95);
  status.textContent = 'Image loaded';
});

function applyNoise(imageData, strength) {
  if (strength <= 0) return;
  const d = imageData.data;
  const n = d.length;
  for (let i = 0; i < n; i += 4) {
    // gaussian-ish small noise
    const r = (Math.random() * 2 - 1) * 255 * strength;
    const g = (Math.random() * 2 - 1) * 255 * strength;
    const b = (Math.random() * 2 - 1) * 255 * strength;
    d[i] = Math.max(0, Math.min(255, d[i] + r));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + g));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + b));
  }
}

function applyPosterize(imageData, levels) {
  if (levels <= 1 || levels >= 256) return;
  const step = 255 / (levels - 1);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    d[i] = Math.round(d[i] / step) * step;
    d[i+1] = Math.round(d[i+1] / step) * step;
    d[i+2] = Math.round(d[i+2] / step) * step;
  }
}

async function canvasToBlobAsync(mime, quality) {
  return await new Promise(resolve => canvas.toBlob(resolve, mime, quality));
}

async function degradeLoop({iterations, quality, downscale, noise, posterize}) {
  stopRequested = false;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  const mime = 'image/jpeg'; // could be configurable
  for (let i = 0; i < iterations; ++i) {
    if (stopRequested) break;
    status.textContent = `Iteration ${i+1}/${iterations}`;
    // optional downscale/upscale to create blockiness
    if (downscale > 1) {
      // draw smaller then back up
      const w = Math.max(1, Math.round(canvas.width / downscale));
      const h = Math.max(1, Math.round(canvas.height / downscale));
      // create temporary canvas
      const tmp = document.createElement('canvas');
      tmp.width = w; tmp.height = h;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(canvas, 0, 0, w, h);
      // scale back
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.imageSmoothingEnabled = false; // produce blocky artifacts
      ctx.drawImage(tmp, 0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = true;
    }

    // pixel ops (noise, posterize)
    if (noise > 0 || posterize < 256) {
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (noise > 0) applyNoise(imageData, noise);
      if (posterize < 256) applyPosterize(imageData, posterize);
      ctx.putImageData(imageData, 0, 0);
    }

    // re-encode to create true compression artifacts
    const blob = await canvasToBlobAsync(mime, quality);
    if (!blob) break;
    // load compressed bytes back into canvas for next iteration
    const bmp = await createImageBitmap(blob);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(bmp, 0, 0, canvas.width, canvas.height);

    // yield to UI
    await new Promise(r => setTimeout(r, 8));
  }

  // make final blob and link
  const finalBlob = await canvasToBlobAsync('image/jpeg', quality);
  if (finalBlob) {
    downloadLink.href = URL.createObjectURL(finalBlob);
    downloadLink.download = `degraded-${Date.now()}.jpg`;
    status.textContent = stopRequested ? 'Stopped' : 'Done';
  } else {
    status.textContent = 'Failed to generate final file';
  }
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

startBtn.addEventListener('click', () => {
  const iterations = parseInt(document.getElementById('iterations').value, 10) || 1;
  const quality = parseFloat(document.getElementById('quality').value) || 0.6;
  const downscale = parseFloat(document.getElementById('downscale').value) || 1;
  const noise = parseFloat(document.getElementById('noise').value) || 0;
  const posterize = parseInt(document.getElementById('posterize').value, 10) || 256;
  degradeLoop({iterations, quality, downscale, noise, posterize});
});

stopBtn.addEventListener('click', () => {
  stopRequested = true;
});
</script>
</body>
</html>
