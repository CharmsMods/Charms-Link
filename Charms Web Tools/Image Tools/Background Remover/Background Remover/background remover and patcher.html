<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Color Keying Tool</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #3b82f6;
            --text-color: #e0e0e0;
            --secondary-text: #a0a0a0;
            --border-radius: 8px;
            --spacing: 16px;
            --slider-track: #333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Prevent body scroll, handle internally */
        }

        /* Header */
        header {
            background-color: var(--surface-color);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #333;
            height: 60px;
        }

        h1 {
            font-size: 1.2rem;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        /* Main Layout */
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: calc(100vh - 60px);
        }

        /* Sidebar Controls */
        aside {
            width: 320px;
            background-color: var(--surface-color);
            padding: 2rem;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--secondary-text);
            margin-bottom: 0.25rem;
        }

        .value-display {
            font-family: monospace;
            color: var(--primary-color);
        }

        /* Upload Button */
        .file-input-wrapper {
            position: relative;
            width: 100%;
            height: 50px;
            border: 2px dashed #444;
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s;
            text-align: center;
            color: var(--secondary-text);
            font-size: 0.9rem;
        }

        .file-input-wrapper:hover {
            border-color: var(--primary-color);
            color: var(--text-color);
            background-color: rgba(59, 130, 246, 0.1);
        }

        input[type="file"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Sliders */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            cursor: pointer;
        }

        input[type="range"]:focus {
            outline: none;
        }

        /* Slider Track */
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: var(--slider-track);
            border-radius: 3px;
        }

        /* Slider Thumb */
        input[type="range"]::-webkit-slider-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            -webkit-appearance: none;
            margin-top: -6px;
            /* center thumb */
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Color Preview Box */
        .color-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: var(--border-radius);
            border: 1px solid #444;
            background-color: transparent;
            /* Default */
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
            position: relative;
            overflow: hidden;
        }

        .color-swatch-inner {
            width: 100%;
            height: 100%;
            background-color: black;
        }

        .instruction-text {
            font-size: 0.85rem;
            color: var(--secondary-text);
            line-height: 1.4;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 4px;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            background-color: #000;
            background-image:
                linear-gradient(45deg, #333 25%, transparent 25%),
                linear-gradient(-45deg, #333 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #333 75%),
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            padding: 20px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
            /* Support checkerboard through transparency */
            background-image:
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%),
                linear-gradient(-45deg, #1a1a1a 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #1a1a1a 75%),
                linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            image-rendering: pixelated;
            /* Keeps zoomed picking sharp */
        }

        /* Initial State Message */
        .empty-state {
            text-align: center;
            color: var(--secondary-text);
            pointer-events: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            main {
                flex-direction: column;
                height: auto;
                overflow-y: auto;
            }

            aside {
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 1px solid #333;
            }

            .canvas-container {
                min-height: 400px;
            }
        }
    </style>
</head>

<body>

    <header>
        <h1>Color Remover</h1>
    </header>

    <main>
        <!-- Sidebar -->
        <aside>
            <div class="control-group">
                <div class="file-input-wrapper">
                    <span>Click to Upload Image</span>
                    <input type="file" id="imageInput" accept="image/*">
                </div>
            </div>

            <div class="control-group">
                <div class="control-header">
                    <span>Picked Color</span>
                </div>
                <div class="color-preview">
                    <div class="color-swatch">
                        <div class="color-swatch-inner" id="colorSwatch"></div>
                    </div>
                    <span id="colorHex">#000000</span>
                </div>
                <div class="instruction-text">
                    Click on the image to select the color you want to modify.
                </div>
            </div>

            <div class="control-group">
                <div class="control-header">
                    <span>Transparency</span>
                    <span class="value-display" id="alphaVal">0%</span>
                </div>
                <input type="range" id="alphaSlider" min="0" max="100" value="0" step="1">
            </div>

            <div class="control-group">
                <div class="control-header">
                    <span>Color Tolerance</span>
                    <span class="value-display" id="toleranceVal">10%</span>
                </div>
                <input type="range" id="toleranceSlider" min="0" max="100" value="10" step="1">
            </div>

            <div class="control-group" style="border-top: 1px solid #333; padding-top: 1rem;">
                <div class="control-header">
                    <span style="color: #fff; font-weight: bold;">Patching Tool</span>
                </div>
                <label id="patchToggleLabel"
                    style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 0.9rem;">
                    <input type="checkbox" id="patchModeToggle"> Enable Patching Mode
                </label>
                <div id="patchSettings" style="display: none; flex-direction: column; gap: 1rem; margin-top: 0.5rem;">
                    <button id="addPatchBtn" style="
                        padding: 8px;
                        background: #333;
                        border: 1px solid #555;
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 0.85rem;
                    ">+ Add New Patch</button>

                    <div id="patchList" style="
                        max-height: 150px;
                        overflow-y: auto;
                        display: flex;
                        flex-direction: column;
                        gap: 5px;
                        padding: 5px;
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 4px;
                    ">
                        <!-- Patch items will be added here -->
                    </div>

                    <div id="activePatchControls"
                        style="display: none; flex-direction: column; gap: 0.8rem; border-top: 1px solid #333; padding-top: 0.8rem;">
                        <div class="instruction-text">
                            Drag to move, Shift+Drag to resize.
                        </div>
                        <div class="control-header">
                            <span>Patch Color</span>
                        </div>
                        <div class="color-preview">
                            <div class="color-swatch">
                                <div class="color-swatch-inner" id="patchSwatch" style="background-color: #ff0000;">
                                </div>
                            </div>
                            <span id="patchHex">#FF0000</span>
                        </div>
                        <div class="control-header">
                            <span>Patch Size</span>
                            <span class="value-display" id="patchSizeVal">100px</span>
                        </div>
                        <input type="range" id="patchSizeSlider" min="10" max="2000" value="100">

                        <button id="deletePatchBtn" style="
                            padding: 6px;
                            background: #442222;
                            border: 1px solid #663333;
                            color: #ffaaaa;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.8rem;
                            margin-top: 5px;
                        ">Delete Active Patch</button>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <button id="resetBtn" style="
                    padding: 10px;
                    background: #2a2a2a;
                    border: 1px solid #444;
                    color: white;
                    border-radius: 4px;
                    cursor: pointer;
                    transition: background 0.2s;
                    width: 100%;
                  ">Reset Settings</button>
                <button id="downloadBtn" style="
                    margin-top: 10px;
                    padding: 12px;
                    background: var(--primary-color);
                    border: none;
                    color: white;
                    font-weight: bold;
                    border-radius: 4px;
                    cursor: pointer;
                    transition: opacity 0.2s, transform 0.1s;
                    width: 100%;
                  ">Download Result</button>
            </div>
        </aside>

        <!-- Canvas Area -->
        <div class="canvas-container" id="canvasContainer">
            <div class="empty-state" id="emptyState">
                <p>No image loaded</p>
                <p style="font-size: 0.8em; margin-top: 5px;">Upload an image to start</p>
            </div>
            <canvas id="glCanvas"></canvas>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
            </div>
        </div>
    </main>

    <script>
        /**
         * GPU CHROMA KEY TOOL
         * Uses WebGL (GLSL) to perform color replacement and fading on the GPU.
         */

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
        const imageInput = document.getElementById('imageInput');
        const emptyState = document.getElementById('emptyState');
        const loadingOverlay = document.getElementById('loadingOverlay');

        // UI Elements
        const alphaSlider = document.getElementById('alphaSlider');
        const alphaVal = document.getElementById('alphaVal');
        const toleranceSlider = document.getElementById('toleranceSlider');
        const toleranceVal = document.getElementById('toleranceVal');
        const colorSwatch = document.getElementById('colorSwatch');
        const colorHex = document.getElementById('colorHex');
        const resetBtn = document.getElementById('resetBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        // Patching Elements
        const patchModeToggle = document.getElementById('patchModeToggle');
        const patchSettings = document.getElementById('patchSettings');
        const addPatchBtn = document.getElementById('addPatchBtn');
        const patchList = document.getElementById('patchList');
        const activePatchControls = document.getElementById('activePatchControls');
        const patchSwatch = document.getElementById('patchSwatch');
        const patchHex = document.getElementById('patchHex');
        const patchSizeSlider = document.getElementById('patchSizeSlider');
        const patchSizeVal = document.getElementById('patchSizeVal');
        const deletePatchBtn = document.getElementById('deletePatchBtn');

        // State
        let originalImage = null;
        let texture = null;
        let program = null;
        let positionBuffer = null;
        let texCoordBuffer = null;

        // Patching State
        let patchEnabled = false;
        const MAX_PATCHES = 32;
        let patches = []; // Array of {x, y, w, h, color: [r,g,b]}
        let selectedPatchIndex = -1;

        let isDraggingPatch = false;
        let isResizingPatch = false;
        let dragOffset = { x: 0, y: 0 };

        // Off-screen canvas for precise color picking
        const offScreenCanvas = document.createElement('canvas');
        const offScreenCtx = offScreenCanvas.getContext('2d', { willReadFrequently: true });

        // Parameters
        let targetColor = [0.0, 0.0, 0.0]; // RGB 0-1
        let targetAlpha = 1.0; // 0-1 (Opaque by default)
        let tolerance = 0.1; // 0-1

        // Initial Setup
        canvas.style.display = 'none';

        if (!gl) {
            alert('Unable to initialize WebGL. Your browser may not support it.');
        }

        // --- WebGL Shaders ---

        const vsSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        const fsSource = `
            precision mediump float;
            uniform sampler2D u_image;
            uniform vec3 u_targetColor;
            uniform float u_targetAlpha;
            uniform float u_tolerance;
            
            // Multi-Patch Uniforms
            uniform bool u_patchEnabled;
            uniform int u_numPatches;
            uniform vec4 u_patchRects[32]; // x, y, width, height
            uniform vec3 u_patchColors[32];
            uniform vec2 u_resolution;

            varying vec2 v_texCoord;

            void main() {
                vec2 pixelCoord = v_texCoord * u_resolution;
                // Since UV 0 is at the top in our mapping, pixelCoord.y is already 0 at top.
                
                vec4 color = texture2D(u_image, v_texCoord);
                
                if (u_patchEnabled) {
                    for (int i = 0; i < 32; i++) {
                        if (i >= u_numPatches) break;
                        vec4 rect = u_patchRects[i];
                        if (pixelCoord.x >= rect.x && pixelCoord.x <= rect.x + rect.z &&
                            pixelCoord.y >= rect.y && pixelCoord.y <= rect.y + rect.w) {
                            gl_FragColor = vec4(u_patchColors[i], 1.0);
                            return;
                        }
                    }
                }

                float dist = distance(color.rgb, u_targetColor);
                float mask = 1.0 - smoothstep(0.0, u_tolerance, dist);
                float newAlpha = mix(color.a, u_targetAlpha, mask);
                gl_FragColor = vec4(color.rgb * newAlpha, newAlpha);
            }
        `;

        // --- WebGL Boilerplate ---

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function createProgram(gl, vs, fs) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);
            const prog = gl.createProgram();
            gl.attachShader(prog, vertexShader);
            gl.attachShader(prog, fragmentShader);
            gl.linkProgram(prog);
            return prog;
        }

        function initWebGL() {
            program = createProgram(gl, vsSource, fsSource);
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
            texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0]), gl.STATIC_DRAW);
        }

        function createTexture(image) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            return tex;
        }

        function render() {
            if (!originalImage || !program) return;
            if (canvas.width !== originalImage.width || canvas.height !== originalImage.height) {
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;
            }
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(program);

            const posLoc = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const texLoc = gl.getAttribLocation(program, "a_texCoord");
            gl.enableVertexAttribArray(texLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(gl.getUniformLocation(program, "u_image"), 0);

            gl.uniform3fv(gl.getUniformLocation(program, "u_targetColor"), targetColor);
            gl.uniform1f(gl.getUniformLocation(program, "u_targetAlpha"), targetAlpha);
            gl.uniform1f(gl.getUniformLocation(program, "u_tolerance"), (parseFloat(tolerance) / 100.0) * 1.5);

            // Multi-Patch Uniforms
            gl.uniform1i(gl.getUniformLocation(program, "u_patchEnabled"), patchEnabled);
            gl.uniform1i(gl.getUniformLocation(program, "u_numPatches"), patches.length);
            gl.uniform2f(gl.getUniformLocation(program, "u_resolution"), canvas.width, canvas.height);

            if (patches.length > 0) {
                const rectData = new Float32Array(MAX_PATCHES * 4);
                const colorData = new Float32Array(MAX_PATCHES * 3);
                for (let i = 0; i < patches.length; i++) {
                    rectData[i * 4 + 0] = patches[i].x;
                    rectData[i * 4 + 1] = patches[i].y;
                    rectData[i * 4 + 2] = patches[i].w;
                    rectData[i * 4 + 3] = patches[i].h;
                    colorData[i * 3 + 0] = patches[i].color[0];
                    colorData[i * 3 + 1] = patches[i].color[1];
                    colorData[i * 3 + 2] = patches[i].color[2];
                }
                gl.uniform4fv(gl.getUniformLocation(program, "u_patchRects"), rectData);
                gl.uniform3fv(gl.getUniformLocation(program, "u_patchColors"), colorData);
            }

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // --- Patch Management ---

        function addPatch() {
            if (patches.length >= MAX_PATCHES) {
                alert(`Maximum of ${MAX_PATCHES} patches reached.`);
                return;
            }

            const size = parseInt(patchSizeSlider.value) || 100;
            const newPatch = {
                x: originalImage ? (originalImage.width - size) / 2 : 50,
                y: originalImage ? (originalImage.height - size) / 2 : 50,
                w: size,
                h: size,
                color: [1.0, 0.0, 0.0] // Red default
            };

            patches.push(newPatch);
            selectPatch(patches.length - 1);
            render();
        }

        function selectPatch(index) {
            selectedPatchIndex = index;
            updatePatchListUI();

            if (index === -1) {
                activePatchControls.style.display = 'none';
            } else {
                activePatchControls.style.display = 'flex';
                const p = patches[index];
                patchSizeSlider.value = p.w;
                patchSizeVal.textContent = p.w + 'px';

                const r = Math.round(p.color[0] * 255);
                const g = Math.round(p.color[1] * 255);
                const b = Math.round(p.color[2] * 255);
                const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();

                patchSwatch.style.backgroundColor = `rgb(${r},${g},${b})`;
                patchHex.textContent = hex;
            }
        }

        function deletePatch(index) {
            patches.splice(index, 1);
            if (selectedPatchIndex === index) {
                selectedPatchIndex = patches.length > 0 ? 0 : -1;
            } else if (selectedPatchIndex > index) {
                selectedPatchIndex--;
            }
            selectPatch(selectedPatchIndex);
            render();
        }

        function updatePatchListUI() {
            patchList.innerHTML = '';
            patches.forEach((p, i) => {
                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 6px 10px;
                    background: ${i === selectedPatchIndex ? '#333' : '#222'};
                    border: 1px solid ${i === selectedPatchIndex ? 'var(--primary-color)' : '#444'};
                    border-radius: 4px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    cursor: pointer;
                    font-size: 0.85rem;
                    color: white;
                `;
                item.onclick = () => selectPatch(i);

                const label = document.createElement('span');
                label.textContent = `Patch ${i + 1}`;
                item.appendChild(label);

                const colorDot = document.createElement('div');
                colorDot.style.cssText = `
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: rgb(${p.color[0] * 255}, ${p.color[1] * 255}, ${p.color[2] * 255});
                    border: 1px solid #666;
                `;
                item.appendChild(colorDot);

                patchList.appendChild(item);
            });

            if (patches.length === 0) {
                patchList.innerHTML = '<div style="color: #666; font-size: 0.8rem; text-align: center; padding: 10px;">No patches added</div>';
            }
        }

        // --- Interaction ---

        const loupe = document.createElement('div');
        loupe.style.cssText = `position:fixed;width:80px;height:80px;border:2px solid white;border-radius:50%;pointer-events:none;display:none;z-index:1000;box-shadow:0 0 10px rgba(0,0,0,0.5);background-color:black;`;
        document.body.appendChild(loupe);

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.floor((e.clientX - rect.left) / rect.width * canvas.width),
                y: Math.floor((e.clientY - rect.top) / rect.height * canvas.height)
            };
        }

        window.addEventListener('mousemove', (e) => {
            if (!originalImage) return;
            const pos = getMousePos(e);

            if (isDraggingPatch && selectedPatchIndex !== -1) {
                const p = patches[selectedPatchIndex];
                p.x = Math.max(0, Math.min(canvas.width - p.w, pos.x - dragOffset.x));
                p.y = Math.max(0, Math.min(canvas.height - p.h, pos.y - dragOffset.y));
                render();
                return;
            }
            if (isResizingPatch && selectedPatchIndex !== -1) {
                const p = patches[selectedPatchIndex];
                p.w = Math.max(10, Math.min(canvas.width - p.x, pos.x - p.x));
                p.h = Math.max(10, Math.min(canvas.height - p.y, pos.y - p.y));

                // Square resize
                const size = Math.max(p.w, p.h);
                p.w = Math.min(size, canvas.width - p.x);
                p.h = Math.min(size, canvas.height - p.y);

                patchSizeSlider.value = p.w;
                patchSizeVal.textContent = p.w + 'px';
                render();
                return;
            }

            const rect = canvas.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
                loupe.style.display = 'block';
                loupe.style.left = (e.clientX + 20) + 'px';
                loupe.style.top = (e.clientY - 40) + 'px';
                const safeX = Math.max(0, Math.min(canvas.width - 1, pos.x));
                const safeY = Math.max(0, Math.min(canvas.height - 1, pos.y));
                const data = offScreenCtx.getImageData(safeX, safeY, 1, 1).data;
                loupe.style.backgroundColor = `rgb(${data[0]}, ${data[1]}, ${data[2]})`;

                if (patchEnabled) {
                    let overAny = false;
                    for (let i = patches.length - 1; i >= 0; i--) {
                        const p = patches[i];
                        if (pos.x >= p.x && pos.x <= p.x + p.w && pos.y >= p.y && pos.y <= p.y + p.h) {
                            overAny = true;
                            break;
                        }
                    }
                    canvas.style.cursor = overAny ? 'move' : 'crosshair';
                }
            } else {
                loupe.style.display = 'none';
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (!originalImage) return;
            const pos = getMousePos(e);
            if (patchEnabled) {
                // Hit test in reverse order (top-most first)
                for (let i = patches.length - 1; i >= 0; i--) {
                    const p = patches[i];
                    if (pos.x >= p.x && pos.x <= p.x + p.w && pos.y >= p.y && pos.y <= p.y + p.h) {
                        selectPatch(i);
                        if (e.shiftKey) isResizingPatch = true;
                        else {
                            isDraggingPatch = true;
                            dragOffset.x = pos.x - p.x;
                            dragOffset.y = pos.y - p.y;
                        }
                        loupe.style.display = 'none';
                        return;
                    }
                }
            }
            pickColor(e);
        });

        window.addEventListener('mouseup', () => {
            isDraggingPatch = isResizingPatch = false;
        });

        function pickColor(e) {
            const pos = getMousePos(e);
            const safeX = Math.max(0, Math.min(canvas.width - 1, pos.x));
            const safeY = Math.max(0, Math.min(canvas.height - 1, pos.y));
            const [r, g, b] = offScreenCtx.getImageData(safeX, safeY, 1, 1).data;
            const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();

            if (patchEnabled && selectedPatchIndex !== -1) {
                const p = patches[selectedPatchIndex];
                p.color = [r / 255, g / 255, b / 255];
                patchSwatch.style.backgroundColor = `rgb(${r},${g},${b})`;
                patchHex.textContent = hex;
                updatePatchListUI();
            } else {
                targetColor = [r / 255, g / 255, b / 255];
                colorSwatch.style.backgroundColor = `rgb(${r},${g},${b})`;
                colorHex.textContent = hex;
            }
            render();
        }

        // --- Listeners ---

        addPatchBtn.addEventListener('click', addPatch);
        deletePatchBtn.addEventListener('click', () => {
            if (selectedPatchIndex !== -1) {
                deletePatch(selectedPatchIndex);
            }
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            loadingOverlay.style.display = 'flex';
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    emptyState.style.display = 'none';
                    canvas.style.display = 'block';
                    offScreenCanvas.width = img.width;
                    offScreenCanvas.height = img.height;
                    offScreenCtx.drawImage(img, 0, 0);
                    if (texture) gl.deleteTexture(texture);
                    texture = createTexture(img);

                    // Center all existing patches to new image dimensions if they are out of bounds
                    patches.forEach(p => {
                        p.x = Math.min(p.x, img.width - p.w);
                        p.y = Math.min(p.y, img.height - p.h);
                        p.x = Math.max(0, p.x);
                        p.y = Math.max(0, p.y);
                    });

                    render();
                    loadingOverlay.style.display = 'none';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        patchModeToggle.addEventListener('change', (e) => {
            patchEnabled = e.target.checked;
            patchSettings.style.display = patchEnabled ? 'flex' : 'none';
            if (patchEnabled && patches.length === 0) {
                addPatch();
            }
            render();
        });

        patchSizeSlider.addEventListener('input', (e) => {
            if (selectedPatchIndex !== -1) {
                const p = patches[selectedPatchIndex];
                const val = parseInt(e.target.value);
                p.w = p.h = val;

                // Clamp to canvas if possible
                if (originalImage) {
                    p.w = p.h = Math.min(val, originalImage.width - p.x, originalImage.height - p.y);
                }

                patchSizeVal.textContent = p.w + 'px';
                render();
            }
        });

        alphaSlider.addEventListener('input', (e) => {
            alphaVal.textContent = e.target.value + '%';
            targetAlpha = 1.0 - (e.target.value / 100.0);
            render();
        });

        toleranceSlider.addEventListener('input', (e) => {
            toleranceVal.textContent = e.target.value + '%';
            tolerance = e.target.value;
            render();
        });

        resetBtn.addEventListener('click', () => {
            alphaSlider.value = 0; alphaVal.textContent = '0%'; targetAlpha = 1.0;
            toleranceSlider.value = 10; toleranceVal.textContent = '10%'; tolerance = 10;
            targetColor = [0, 0, 0]; colorSwatch.style.backgroundColor = 'black'; colorHex.textContent = '#000000';

            // Clear patches
            patches = [];
            selectPatch(-1);

            render();
        });

        downloadBtn.addEventListener('click', () => {
            if (!originalImage) return;
            render();
            const link = document.createElement('a');
            link.download = `gpu-patch-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        initWebGL();
        window.addEventListener('resize', () => { if (originalImage) render(); });

        // Force defaults
        patchModeToggle.checked = false;
        patchEnabled = false;
        patchSettings.style.display = 'none';
    </script>
</body>

</html>