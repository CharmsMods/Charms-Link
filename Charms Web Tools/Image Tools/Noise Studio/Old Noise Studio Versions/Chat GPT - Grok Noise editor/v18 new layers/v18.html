<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Digital Grain Studio ‚Äî GPU Accelerated</title>
    <style>
        :root {
            --bg: #000;
            --fg: #fff;
            --panel-max: 460px;
            --muted: #8c8c8c;
            --accent: #2a9df4;
            --border: rgba(255, 255, 255, 0.08);
            --layer-h: 40px;
            --tab-bg: #1a1a1a;
            --tab-active: #2a9df4;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', monospace
        }

        body {
            padding: 16px;
            display: flex;
            gap: 16px;
            align-items: flex-start;
            min-height: 100vh
        }

        .container {
            display: flex;
            gap: 16px;
            width: 100%;
            height: 100%;
        }

        /* Left control column */
        .controls-panel {
            flex: 0 0 var(--panel-max);
            max-width: var(--panel-max);
            min-width: 320px;
            padding-right: 10px;
            overflow-y: auto;
            height: 100%;
            scrollbar-width: thin;
            scrollbar-color: var(--muted) var(--bg);
            display: flex;
            flex-direction: column;
        }

        .controls-panel h1 {
            font-size: 18px;
            margin: 0 0 4px 0;
            text-align: center;
            letter-spacing: -0.5px;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
            margin-bottom: 12px;
            display: block;
            text-align: center;
        }

        /* Tabs */
        .tab-toggle-container {
            display: flex;
            gap: 4px;
            margin: 10px 0;
            background: #111;
            padding: 4px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .tab-btn {
            flex: 1;
            background: transparent;
            color: var(--muted);
            border: none;
            padding: 8px;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            font-family: inherit;
            transition: 0.2s;
        }

        .tab-btn.active {
            background: var(--tab-active);
            color: #000;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .tab-content.active {
            display: flex;
        }

        /* Draggable Layer Styles */
        .drag-layer {
            background: #111;
            border: 1px solid var(--border);
            padding: 8px 12px;
            margin-bottom: 6px;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            font-size: 13px;
            border-radius: 4px;
        }

        .drag-layer:active {
            cursor: grabbing;
            background: #222;
            border-color: var(--accent);
        }

        .drag-layer.dragging {
            opacity: 0.5;
        }

        .drag-handle {
            color: var(--muted);
            margin-right: 10px;
        }

        .drag-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .drag-toggle {
            cursor: pointer;
            accent-color: var(--accent);
        }

        /* Existing Control Styles */
        details {
            border: 1px solid var(--border);
            margin-bottom: 8px;
            padding: 6px;
            border-radius: 4px;
            background: #0a0a0a
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            margin: 0 0 6px 0;
            outline: none;
            user-select: none;
            font-size: 13px;
        }

        summary:hover {
            color: var(--accent);
        }

        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
            min-height: 28px
        }

        .control-row label {
            flex: 0 0 120px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 12px;
        }

        input[type=range] {
            flex: 1;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .control-value {
            width: 60px;
            padding: 2px 4px;
            text-align: right;
            background: #000;
            color: var(--fg);
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 11px;
        }

        select.control-value {
            flex: 1;
            min-width: 120px;
            padding: 4px
        }

        .row-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        button {
            background: #111;
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 8px 12px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.small-btn {
            padding: 4px 8px;
            font-size: 10px;
        }

        /* Right preview column */
        .preview-column {
            flex: 1 1 auto;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
            overflow: hidden;
        }

        .preview-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px
        }

        .preview-container {
            position: relative;
            border: 1px solid var(--border);
            background: repeating-linear-gradient(45deg, #111 0px, #111 10px, #0e0e0e 10px, #0e0e0e 20px);
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        /* Canvas Display */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Overlay (Original) */
        .overlay-original {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        .overlay-original canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .overlay-original.show canvas {
            opacity: 1
        }

        /* CA Pin */
        #caPin {
            width: 12px;
            height: 12px;
            background: var(--accent);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: crosshair;
            z-index: 20;
            box-shadow: 0 0 5px #000;
            display: none;
        }

        #caPin.active {
            display: block;
        }

        #caPin::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none;
        }

        /* Layer Grid */
        .layer-preview-window {
            border: 1px solid var(--border);
            background: #050505;
            padding: 8px;
            height: 160px;
            flex: 0 0 160px;
            overflow: hidden;
        }

        .layer-grid {
            display: flex;
            gap: 4px;
            height: 100%;
        }

        .layer-item {
            border: 1px solid var(--border);
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #000;
            cursor: pointer;
            transition: border-color 0.2s;
            position: relative;
            min-width: 60px;
        }

        .layer-item:hover {
            border-color: var(--muted);
        }

        .layer-item.active {
            border-color: var(--accent);
        }

        .layer-title {
            color: var(--muted);
            font-size: 9px;
            text-transform: uppercase;
            text-align: center;
            padding-top: 4px;
            height: 24px;
            line-height: 1.2;
            word-wrap: break-word;
            padding: 2px;
        }

        .layer-canvas {
            width: 100%;
            flex: 1;
            background: #111;
            border-top: 1px solid #222;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 3000
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto
        }

        .modal {
            background: #111;
            border: 1px solid var(--border);
            padding: 20px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        /* Loading Indicator */
        #loading {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--accent);
            color: #000;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: bold;
            display: none;
            z-index: 4000;
        }

        /* Upscale & Lock Input */
        .upscale-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            border: 1px solid var(--border);
            padding: 4px 8px;
            background: #0a0a0a;
            border-radius: 4px;
        }

        .upscale-input {
            width: 40px;
            background: #000;
            border: 1px solid var(--border);
            color: var(--fg);
            padding: 2px;
            text-align: center;
            font-family: monospace;
        }

        .lock-switch {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            margin-right: 12px;
            border-right: 1px solid var(--border);
            padding-right: 12px;
        }

        .lock-checkbox {
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* File Inputs */
        .json-btn {
            background: #222;
            border: 1px solid var(--border);
            color: var(--accent);
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            margin-top: 4px;
            width: 100%;
            text-align: center;
        }

        .json-btn:hover {
            background: var(--accent);
            color: #000;
        }

        @media (max-width:900px) {
            body {
                padding: 10px;
                flex-direction: column;
            }

            .container {
                flex-direction: column;
            }

            .controls-panel {
                width: 100%;
                max-width: none;
                flex: none;
                height: auto;
                max-height: 40vh;
            }

            .preview-column {
                width: 100%;
                height: 50vh;
            }
        }
    </style>
</head>

<body>

    <div id="loading">PROCESSING GPU...</div>

    <div class="container">
        <div class="controls-panel">
            <h1>DIGITAL GRAIN [GPU]</h1>
            <span class="muted">WebGL2 Accelerated Pipeline</span>

            <div style="margin:10px 0; border: 1px dashed var(--border); padding: 10px; text-align: center;">
                <label for="imageUpload" style="cursor: pointer; display: block;">
                    <span style="font-size: 24px; display: block; margin-bottom: 5px;">üìÇ</span>
                    <span style="font-size: 12px; color: var(--accent);">CLICK TO LOAD IMAGE</span>
                </label>
                <input id="imageUpload" type="file" accept="image/*" style="display: none;">

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px;">
                    <button class="json-btn" id="downloadJsonBtn">DOWNLOAD .JSON</button>
                    <button class="json-btn" id="uploadJsonTrigger">UPLOAD .JSON</button>
                    <input id="jsonUpload" type="file" accept=".json" style="display: none;">
                </div>
            </div>

            <!-- TABS -->
            <div class="tab-toggle-container">
                <button class="tab-btn active" data-tab="tab-controls">Controls</button>
                <button class="tab-btn" data-tab="tab-layers">Render Layer Order</button>
            </div>

            <!-- TAB 1: CONTROLS -->
            <div id="tab-controls" class="tab-content active">

                <!-- Layer 1: Noise Basics -->
                <details open>
                    <summary>Noise Basics</summary>
                    <div class="control-row">
                        <label>Noise Strength</label>
                        <input id="strength" type="range" min="0" max="150" step="0.1" value="40">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Noise Type</label>
                        <select id="noiseType" class="control-value">
                            <option value="1" selected>Grayscale</option>
                            <option value="0">Color</option>
                            <option value="2">Blend (Sat)</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Sat Strength</label>
                        <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sat Impact</label>
                        <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer 1: Shape & Blur -->
                <details open>
                    <summary>Shape & Blur</summary>
                    <div class="control-row">
                        <label>Scale (Size)</label>
                        <input id="noiseSize" type="range" min="0" max="10" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Blurriness</label>
                        <input id="blurriness" type="range" min="0" max="100" step="1" value="2">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer 1: Blend & Opacity -->
                <details open>
                    <summary>Blend & Opacity</summary>
                    <div class="control-row">
                        <label>Blend Mode</label>
                        <select id="blendMode" class="control-value">
                            <option value="0">Normal</option>
                            <option value="1" selected>Overlay</option>
                            <option value="2">Screen</option>
                            <option value="3">Multiply</option>
                            <option value="4">Add</option>
                            <option value="5">Difference</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Opacity</label>
                        <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer 1: Masking -->
                <details open>
                    <summary>Luminance Masking</summary>
                    <div class="control-row">
                        <label>Shadows</label>
                        <input id="enableShadows" type="checkbox" checked>
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Highlights</label>
                        <input id="enableHighlights" type="checkbox" checked>
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="noiseInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                </details>

                <!-- Layer 1: Alpha -->
                <details>
                    <summary>Alpha Channel</summary>
                    <div class="control-row">
                        <label>Ignore Alpha</label>
                        <input id="ignoreAlphaToggle" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Strength</label>
                        <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer 2: Adjustments -->
                <details>
                    <summary>Adjustments</summary>
                    <div class="control-row">
                        <label>Brightness</label>
                        <input id="brightness" type="range" min="-100" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Contrast</label>
                        <input id="contrast" type="range" min="-100" max="200" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Saturation</label>
                        <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Warmth</label>
                        <input id="warmth" type="range" min="-500" max="500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sharpening</label>
                        <input id="sharpen" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="adjColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="adjExcludeColor" type="color" value="#000000" style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="adjExcludeColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="adjColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="adjColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="adjLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="adjShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="adjShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="adjHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="adjHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="adjInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                </details>

                <!-- Layer 3: HDR -->
                <details>
                    <summary>HDR Emulation</summary>
                    <div class="control-row">
                        <label>Tolerance</label>
                        <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Amount</label>
                        <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer 4: Chromatic Aberration -->
                <details>
                    <summary>Chromatic Aberration</summary>
                    <div class="control-row">
                        <label>Amount</label>
                        <input id="aberrationAmount" type="range" min="0" max="1500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <!-- Radius & Falloff -->
                    <div class="control-row">
                        <label>Clear Radius</label>
                        <input id="caRadius" type="range" min="0" max="1000" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Radius Falloff</label>
                        <input id="caFalloff" type="range" min="0" max="500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Blur</label>
                        <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="text-align: right; margin-top: 5px;">
                        <button id="resetCenterBtn" class="small-btn">RESET CENTER</button>
                    </div>
                </details>

                <!-- Layer: Blur -->
                <details>
                    <summary>Blur</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="blurEnable" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Amount</label>
                        <input id="blurAmount" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Type</label>
                        <select id="blurType" class="control-value">
                            <option value="0" selected>Gaussian</option>
                            <option value="1">Box</option>
                            <option value="2">Motion</option>
                        </select>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="blurColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="blurTargetColor" type="color" value="#000000" style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="blurTargetColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="blurColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="blurColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="blurLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="blurShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="blurShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="blurHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="blurHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="blurInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                </details>

                <!-- Layer: Dithering -->
                <details>
                    <summary>Dithering</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="ditherEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Bit Depth</label>
                        <input id="ditherBitDepth" type="range" min="1" max="8" step="1" value="4">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Palette Size</label>
                        <input id="ditherPaletteSize" type="range" min="2" max="256" step="1" value="16">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Dither Strength</label>
                        <input id="ditherStrength" type="range" min="0" max="1000" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Scale</label>
                        <input id="ditherScale" type="range" min="1" max="16" step="1" value="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Dither Type</label>
                        <select id="ditherType" class="control-value">
                            <option value="0" selected>Bayer (Ordered)</option>
                            <option value="1">Noise (Random)</option>
                        </select>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="ditherColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="ditherExcludeColor" type="color" value="#000000"
                                style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="ditherExcludeColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="ditherColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="ditherColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="ditherLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="ditherShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="ditherShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="ditherHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="ditherHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="ditherInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                </details>

                <!-- Layer: Corruption -->
                <details>
                    <summary>Corruption</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="corruptionEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Iterations</label>
                        <input id="corruptionIterations" type="range" min="0" max="500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Algorithm</label>
                        <select id="corruptionAlgorithm" class="control-value">
                            <option value="0" selected>JPEG Blocks</option>
                            <option value="1">Pixelation</option>
                            <option value="2">Color Bleed</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Resolution Scale</label>
                        <input id="corruptionResScale" type="range" min="1" max="100" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer: Cell Shading -->
                <details>
                    <summary>Cell Shading</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="cellEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Shading Levels</label>
                        <input id="cellLevels" type="range" min="2" max="12" step="1" value="4">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Contrast Bias</label>
                        <input id="cellBias" type="range" min="-1" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Gamma Curve</label>
                        <input id="cellGamma" type="range" min="0.5" max="2.2" step="0.01" value="1.0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Quantize Mode</label>
                        <select id="cellQuantMode" class="control-value">
                            <option value="0" selected>Luminance</option>
                            <option value="1">RGB</option>
                            <option value="2">HSV Value</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Band Mapping</label>
                        <select id="cellBandMap" class="control-value">
                            <option value="0" selected>Linear</option>
                            <option value="1">Smoothstep</option>
                            <option value="2">Posterize</option>
                        </select>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Edges Enable</label>
                        <input id="cellEdgeEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Edge Strength</label>
                        <input id="cellEdgeStr" type="range" min="0" max="5" step="0.01" value="0.8">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Thickness</label>
                        <input id="cellEdgeThick" type="range" min="0.5" max="10" step="0.1" value="1.0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Method</label>
                        <select id="cellEdgeMethod" class="control-value">
                            <option value="0">None</option>
                            <option value="1" selected>Sobel</option>
                            <option value="2">Laplacian</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Color Preserve</label>
                        <input id="cellColorPreserve" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Quant Luma Only</label>
                    </div>
                </details>

                <!-- Layer: Halftoning -->
                <details>
                    <summary>Halftoning</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="halftoneEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Dot Size</label>
                        <input id="halftoneSize" type="range" min="1" max="12" step="0.1" value="4">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Intensity</label>
                        <input id="halftoneIntensity" type="range" min="0" max="1" step="0.01" value="0.8">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sharpness</label>
                        <input id="halftoneSharpness" type="range" min="0" max="1" step="0.01" value="0.5">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Pattern Type</label>
                        <select id="halftonePattern" class="control-value">
                            <option value="0" selected>Circular</option>
                            <option value="1">Line</option>
                            <option value="2">Cross</option>
                            <option value="3">Diamond</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Color Mode</label>
                        <select id="halftoneColorMode" class="control-value">
                            <option value="0" selected>Luminance</option>
                            <option value="1">RGB</option>
                            <option value="2">CMY</option>
                            <option value="3">CMYK</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Sampling</label>
                        <select id="halftoneSample" class="control-value">
                            <option value="0" selected>Center</option>
                            <option value="1">Average</option>
                            <option value="2">Rotated Grid</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Grayscale</label>
                        <input id="halftoneGray" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Screen Lock</label>
                        <input id="halftoneScreenLock" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Invert</label>
                        <input id="halftoneInvert" type="checkbox">
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="halftoneColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div> <!-- Extra wrapper to match style if needed or just use the flex -->
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input id="halftoneExcludeColor" type="color" value="#000000"
                                    style="width: 40px; height: 24px;">
                                <button class="eyedropper-btn" data-target="halftoneExcludeColor"
                                    title="Pick from canvas">üñåÔ∏è</button>
                            </div>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="halftoneColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="halftoneColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="halftoneLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="halftoneShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="halftoneShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="halftoneHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="halftoneHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer: Bilateral Filter -->
                <details>
                    <summary>Bilateral Filter</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="bilateralEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Radius</label>
                        <input id="bilateralRadius" type="range" min="1" max="30" step="1" value="5">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Sigma</label>
                        <input id="bilateralColorSig" type="range" min="0.01" max="1.0" step="0.01" value="0.1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Spatial Sigma</label>
                        <input id="bilateralSpatialSig" type="range" min="0.5" max="15.0" step="0.1" value="2.0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Iterations</label>
                        <input id="bilateralIter" type="range" min="1" max="20" step="1" value="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>High Precision</label>
                        <input id="bilateralHighPrec" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Kernel Type</label>
                        <select id="bilateralKernel" class="control-value">
                            <option value="0" selected>Gaussian</option>
                            <option value="1">Box</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Edge Preservation</label>
                        <select id="bilateralEdgeMode" class="control-value">
                            <option value="0" selected>Luminance</option>
                            <option value="1">RGB</option>
                        </select>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="bilateralColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <input id="bilateralExcludeColor" type="color" value="#000000"
                            style="width: 60px; height: 24px;">
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="bilateralColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="bilateralColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="bilateralLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="bilateralShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="bilateralShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="bilateralHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="bilateralHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>




                <div class="row-buttons">
                    <button id="downloadBtn" disabled>DOWNLOAD FULL RES</button>
                    <button id="compareBtn" disabled>COMPARE / EXPORT</button>
                </div>
            </div>

            <!-- TAB 2: LAYERS -->
            <div id="tab-layers" class="tab-content">
                <div style="font-size:11px; color:var(--muted); margin-bottom:10px;">Drag to reorder render pipeline:
                </div>
                <div id="layer-drag-list">
                    <!-- Populated by JS -->
                </div>
            </div>

        </div>

        <div class="preview-column">
            <div class="preview-top">
                <h3 style="margin:0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Main Preview</h3>

                <div style="display: flex; align-items: center;">
                    <!-- Hover Zoom Slider -->
                    <div class="upscale-control" style="margin-right: 8px;"
                        title="Zoom level when hovering over preview">
                        <span>HOVER ZOOM</span>
                        <input id="hoverZoomSlider" type="range" min="1" max="8" step="0.1" value="1"
                            style="width: 60px; accent-color: var(--accent);">
                        <span id="hoverZoomValue" style="min-width: 28px; text-align: center;">1x</span>
                    </div>

                    <!-- Lens Mode Toggle -->
                    <button id="lensToggleBtn" class="small-btn"
                        style="margin-right: 12px; padding: 4px 8px; font-size: 9px;"
                        title="Toggle between Full zoom and Lens zoom">FULL</button>

                    <!-- Lock Switch -->
                    <label class="lock-switch" title="Lock Preview to prevent Original Image overlay">
                        <input type="checkbox" id="previewLock" class="lock-checkbox">
                        <span>LOCK PREVIEW</span>
                    </label>

                    <div class="upscale-control">
                        <span>UPSCALE (x)</span>
                        <input id="upscaleInput" class="upscale-input" type="text" value="1" min="1" max="10">
                    </div>
                </div>
            </div>

            <div class="preview-container" id="previewContainer">
                <canvas id="displayCanvas"></canvas>
                <div id="caPin"></div>
                <div class="overlay-original" id="overlayOriginal">
                    <canvas id="overlayCanvas"></canvas>
                </div>
                <div id="zoomResIndicator"
                    style="position:absolute; bottom:8px; left:8px; background:rgba(0,0,0,0.8); color:#0f0; padding:4px 8px; font-size:10px; font-family:monospace; z-index:20; display:none; border:1px solid #0f0;">
                </div>
                <div id="zoomLens"
                    style="position:absolute; width:180px; height:180px; border-radius:50%; border:2px solid var(--accent); overflow:hidden; pointer-events:none; display:none; z-index:25; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
                    <canvas id="lensCanvas" style="position:absolute; top:0; left:0;"></canvas>
                </div>
            </div>

            <div class="preview-top">
                <h3 style="margin:0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Layer Breakdown
                </h3>
                <div style="font-size: 10px; color: var(--muted);">Click to view</div>
            </div>
            <div class="layer-preview-window">
                <div class="layer-grid" id="layerGrid">
                    <!-- populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Compare Modal -->
    <div id="compareModal" class="modal-overlay">
        <div class="modal">
            <h2 style="margin-top:0">Comparison & Export</h2>
            <div style="display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap;">
                <div>
                    <div class="muted">Original</div>
                    <canvas id="compareOriginal"
                        style="max-height: 40vh; max-width: 40vw; border: 1px solid #333;"></canvas>
                </div>
                <div>
                    <div class="muted">Processed</div>
                    <canvas id="compareProcessed"
                        style="max-height: 40vh; max-width: 40vw; border: 1px solid #333;"></canvas>
                </div>
            </div>
            <div style="text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button id="exportSideBySide">Export Side-by-Side</button>
                <button id="exportStacked">Export Stacked</button>
                <button id="closeCompare">Close</button>
            </div>
        </div>
    </div>

    <!-- WEBGL SHADERS -->
    <script type="x-shader/x-vertex" id="vs-quad">
#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}
</script>

    <script type="x-shader/x-fragment" id="fs-adjust">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Sharpening
    if (u_sharp > 0.0) {
        vec4 sum = vec4(0.0);
        sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x,  u_step.y));
        vec4 edge = c - (sum * 0.25);
        rgb += edge.rgb * (u_sharp / 10.0); 
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-mask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; 
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.299,0.587,0.114));
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}
</script>

    <script type="x-shader/x-fragment" id="fs-noise">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; 
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; 

float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec2 pos = v_uv * u_origRes; 
    vec2 cell = floor(pos / max(1.0, u_scale));
    
    vec3 n;
    if (u_type == 1) { 
        float r = hash12(cell + u_seed);
        n = vec3(r);
    } else { 
        float r = hash12(cell + u_seed);
        float g = hash12(cell + u_seed + 1.23);
        float b = hash12(cell + u_seed + 2.45);
        n = vec3(r, g, b);
    }
    
    outColor = vec4(n, 1.0);
}
</script>

    <script type="x-shader/x-fragment" id="fs-blur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; 
uniform float u_rad;

void main() {
    vec4 color = vec4(0.0);
    float total = 0.0;
    for(float i = -4.0; i <= 4.0; i++) {
        float weight = exp(-(i*i) / (2.0 * 2.0)); 
        vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad);
        color += s * weight;
        total += weight;
    }
    outColor = color / total;
}
</script>

    <script type="x-shader/x-fragment" id="fs-composite">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; 
uniform int u_nType; 
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; 
uniform float u_ignAstr;

float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); 
    vec3 n = nc.rgb;
    vec3 res;
    vec3 base = bc.rgb;
    
    if (u_nType == 2) {
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        float lum = dot(base, vec3(0.299,0.587,0.114));
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * (u_str/50.0)); 
        res = satColor;
    } else {
        vec3 noiseLayer = nc.rgb;
        if (u_mode == 0) { 
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { 
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { 
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { 
            res = base * noiseLayer;
        } else if (u_mode == 4) { 
            res = base + noiseLayer;
        } else if (u_mode == 5) { 
            res = abs(base - noiseLayer);
        }
        
        float maskVal = mc.r; 
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); 
        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-chroma">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

void main() {
    if (u_amt <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    
    // Calculate clear zone mask
    float clearMask = 0.0;
    if (u_radius > 0.0 || u_falloff > 0.0) {
        clearMask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    }
    
    // Calculate aberration strength based on distance from center
    float str = dist * dist * (u_amt / 1000.0); 
    str *= (1.0 - clearMask); 
    
    vec4 result = vec4(0.0);
    
    if (u_blur > 0.0) {
        float totalWeight = 0.0;
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * u_blur * 0.002; 
            float w = exp(-(i*i)/2.0); 
            
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t)).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5)).g; 
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t)).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}
</script>

    <script type="x-shader/x-fragment" id="fs-copy">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_channel; 

void main() {
    vec4 c = texture(u_tex, v_uv);
    if (u_channel == 1) outColor = vec4(c.rrr, 1.0);
    else if (u_channel == 2) outColor = vec4(c.ggg, 1.0);
    else if (u_channel == 3) outColor = vec4(c.bbb, 1.0);
    else outColor = c;
}
</script>

    <script type="x-shader/x-fragment" id="fs-invert">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;

void main() {
    float mask = texture(u_tex, v_uv).r;
    float inv = 1.0 - mask;
    // We output inversed mask to R channel (and everything else for safety)
    outColor = vec4(inv, inv, inv, 1.0);
}
</script>

    <script type="x-shader/x-fragment" id="fs-dither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

// 8x8 Bayer matrix (normalized to 0-1)
float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    // Bayer 8x8 pattern values
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

// Hash for noise dithering
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    
    // Calculate scaled position for dither pattern
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    // Get threshold value based on dither type
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    // Calculate quantization levels
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    // Apply dithering with strength
    vec3 dithered = col.rgb + threshold * (u_strength) * (1.0 / levels);
    
    // Quantize to bit depth
    dithered = floor(dithered * levels + 0.5) / levels;
    
    // Apply palette quantization
    dithered = floor(dithered * u_paletteSize + 0.5) / u_paletteSize;
    
    outColor = vec4(clamp(dithered, 0.0, 1.0), col.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-corruption">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_algorithm; // 0=jpeg blocks, 1=pixelation, 2=color bleed
uniform float u_resScale; // 1-100 (lower = more corruption)
uniform vec2 u_res;
uniform float u_iteration; // current iteration for variation

void main() {
    // Calculate block size based on resolution scale (inverted: lower scale = bigger blocks)
    float blockSize = max(2.0, (100.0 - u_resScale) / 5.0 + 1.0);
    
    vec4 col;
    
    if (u_algorithm == 0) {
        // JPEG-like block artifacts
        vec2 blockPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        vec2 blockCenter = blockPos + (blockSize * 0.5) / u_res;
        
        // Sample from block center with some offset for artifact feel
        vec2 offset = (v_uv - blockPos) * u_res / blockSize;
        offset = floor(offset * 2.0) / 2.0 * blockSize / u_res;
        
        col = texture(u_tex, blockPos + offset);
        
        // Add slight color shifting at block edges
        vec2 edgeDist = abs(fract(v_uv * u_res / blockSize) - 0.5);
        float edge = smoothstep(0.3, 0.5, max(edgeDist.x, edgeDist.y));
        col.rgb = mix(col.rgb, col.rgb * 0.95, edge * 0.3);
        
    } else if (u_algorithm == 1) {
        // Pixelation - simple downscale/upscale
        vec2 pixelPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        col = texture(u_tex, pixelPos + (blockSize * 0.5) / u_res);
        
    } else {
        // Color bleed - horizontal color smearing
        float bleedAmount = blockSize / u_res.x;
        vec4 left = texture(u_tex, v_uv - vec2(bleedAmount, 0.0));
        vec4 center = texture(u_tex, v_uv);
        vec4 right = texture(u_tex, v_uv + vec2(bleedAmount, 0.0));
        
        // Shift color channels
        col.r = mix(center.r, right.r, 0.3);
        col.g = center.g;
        col.b = mix(center.b, left.b, 0.3);
        col.a = center.a;
    }
    
    outColor = col;
}
</script>

    <script type="x-shader/x-fragment" id="fs-cell">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_levels;         // 2-12
uniform float u_bias;         // -1.0 to 1.0 (contrast bias)
uniform float u_gamma;        // 0.5 to 2.2
uniform int u_quantMode;      // 0=Luma, 1=RGB, 2=HSV
uniform int u_bandMap;        // 0=Linear, 1=Smooth, 2=Poster
uniform int u_edgeMethod;     // 0=None, 1=Sobel, 2=Laplc
uniform float u_edgeStr;      // 0-1
uniform float u_edgeThick;    // 0.5-3.0
uniform int u_colorPreserve;  // 0/1 bool
uniform int u_edgeEnable;     // 0/1 bool

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float getLuma(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

float quantize(float val, int levels, float bias, float gamma) {
    // Apply bias
    val = clamp(val + bias, 0.0, 1.0);
    
    // Apply gamma
    val = pow(val, gamma);
    
    // Quantize
    float fLevels = float(levels);
    float q = floor(val * fLevels) / (fLevels - 1.0);
    
    // Map output based on band mode
    if (u_bandMap == 1) { // Smooth
        q = smoothstep(0.0, 1.0, q);
    } else if (u_bandMap == 2) { // Posterize hard
        q = floor(val * fLevels) / fLevels; 
    }
    
    return q;
}

float sobel(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l00 = getLuma(texture(u_tex, uv + vec2(-px.x, -px.y)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l20 = getLuma(texture(u_tex, uv + vec2(px.x, -px.y)).rgb);
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l02 = getLuma(texture(u_tex, uv + vec2(-px.x, px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l22 = getLuma(texture(u_tex, uv + vec2(px.x, px.y)).rgb);
    
    float gx = l00 + 2.0*l01 + l02 - (l20 + 2.0*l21 + l22);
    float gy = l00 + 2.0*l10 + l20 - (l02 + 2.0*l12 + l22);
    
    return sqrt(gx*gx + gy*gy);
}

float laplacian(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l11 = getLuma(texture(u_tex, uv).rgb); // Center
    
    return abs(l01 + l21 + l10 + l12 - 4.0 * l11) * 2.0;
}

void main() {
    vec4 base = texture(u_tex, v_uv);
    vec3 col = base.rgb;
    
    // Apply Quantization
    vec3 res = col;
    if (u_quantMode == 0) { // Luma
        float l = getLuma(col);
        float q = quantize(l, u_levels, u_bias, u_gamma);
        if (u_colorPreserve == 1) {
            // Preserve color, only quantize lightness
            vec3 hsv = rgb2hsv(col);
            hsv.z = q;
            res = hsv2rgb(hsv);
        } else {
            res = vec3(q);
        }
    } else if (u_quantMode == 1) { // RGB
        res.r = quantize(col.r, u_levels, u_bias, u_gamma);
        res.g = quantize(col.g, u_levels, u_bias, u_gamma);
        res.b = quantize(col.b, u_levels, u_bias, u_gamma);
    } else { // HSV Value
        vec3 hsv = rgb2hsv(col);
        hsv.z = quantize(hsv.z, u_levels, u_bias, u_gamma);
        res = hsv2rgb(hsv);
    }
    
    // Apply Edges
    if (u_edgeEnable == 1 && u_edgeMethod > 0) {
        float edge = 0.0;
        if (u_edgeMethod == 1) edge = sobel(v_uv);
        else if (u_edgeMethod == 2) edge = laplacian(v_uv);
        
        edge = smoothstep(0.1, 1.0, edge * 2.0); // Boost edge visibility
        res = mix(res, vec3(0.0), edge * u_edgeStr);
    }
    
    outColor = vec4(res, base.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-halftone">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform float u_size;           // 1-12
uniform float u_intensity;      // 0-1
uniform float u_sharpness;      // 0-1
uniform int u_pattern;          // 0=Circ, 1=Line, 2=Cross, 3=Diamond
uniform int u_colorMode;        // 0=Luma, 1=RGB, 2=CMY, 3=CMYK
uniform int u_sample;           // 0=Center, 1=Avg
uniform int u_gray;             // Bool
uniform int u_lock;             // Bool
uniform int u_invert;           // Bool

float getPattern(vec2 uv, float angle) {
    float s = sin(angle), c = cos(angle);
    vec2 p = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y) * u_res / u_size; // Map to pattern space
    vec2 grid = fract(p) - 0.5;
    
    float d = 0.0;
    if (u_pattern == 0) { // Circle
        d = length(grid) * 2.0; // 0-1 range center to corner
    } else if (u_pattern == 1) { // Line
        d = abs(grid.y) * 2.0;
    } else if (u_pattern == 2) { // Cross
        d = min(abs(grid.x), abs(grid.y)) * 2.0;
    } else { // Diamond
        d = (abs(grid.x) + abs(grid.y));
    }
    
    return d; // 0 at center/peak, 1 at edge
}

void main() {
    float angle = 0.0; // Default angle
    if (u_sample == 2) angle = 0.785; // 45 deg for rotated
    
    vec2 sampleUV = v_uv;
    if (u_lock == 0) {
        // Pattern follows image (UV space), scale by res ratio to keep square dots
        // Actually simpler: just rely on u_size scaling against u_res
    }
    
    vec4 col = texture(u_tex, v_uv);
    
    // Halftone Logic
    vec3 outRGB = vec3(0.0);
    
    if (u_colorMode == 0) { // Luminance
        float l = dot(col.rgb, vec3(0.299, 0.587, 0.114));
        float pat = getPattern(v_uv, 0.785); // 45 degree default for mono
        
        // Threshold
        // Pattern goes 0(black) to 1(white). Luma 0(black) to 1(white).
        // Standard HT: if luma > pattern -> white. 
        // With intensity: mix pattern with luma.
        
        // Soft edge based on sharpness
        float thresh = 1.0 - l * u_intensity; // Invert luma for pattern comparison
        float softness = 1.0 - u_sharpness;
        float val = smoothstep(thresh - softness, thresh + softness, pat);
        
        if (u_invert == 1) val = 1.0 - val;
        outRGB = vec3(val);
        
    } else if (u_colorMode == 1) { // RGB
        // Separate angles for R, G, B
        float pR = getPattern(v_uv, 0.26); // ~15 deg
        float pG = getPattern(v_uv, 1.30); // ~75 deg
        float pB = getPattern(v_uv, 0.0);  // 0 deg
        
        float soft = 1.0 - u_sharpness;
        
        float r = smoothstep((1.0 - col.r) - soft, (1.0 - col.r) + soft, pR);
        float g = smoothstep((1.0 - col.g) - soft, (1.0 - col.g) + soft, pG);
        float b = smoothstep((1.0 - col.b) - soft, (1.0 - col.b) + soft, pB);
        
        outRGB = vec3(r, g, b);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
        
    } else { // CMY / CMYK
        // Simple RGB -> CMY
        vec3 cmy = 1.0 - col.rgb;
        float k = 0.0;
        if (u_colorMode == 3) { // CMYK
            k = min(min(cmy.x, cmy.y), cmy.z);
            cmy = (cmy - k) / (1.0 - k);
        }
        
        // Angles: C=15, M=75, Y=0, K=45
        float pC = getPattern(v_uv, 0.26);
        float pM = getPattern(v_uv, 1.30);
        float pY = getPattern(v_uv, 0.0);
        float pK = getPattern(v_uv, 0.785);
        
        float soft = 1.0 - u_sharpness;
        
        // Halftone each channel (0=white, 1=ink). 
        // If pattern < ink_amount -> ink. 
        // Pattern 0(center) to 1(edge). Ink 0(none) to 1(full).
        // If pattern < cmy.r => ink.
        // Invert comparison for white checks?
        // Let's use: if pattern > (1.0 - ink) -> ink ?? No.
        
        // Standard: dot grows from center (0). so if pattern < ink -> ink.
        float hC = 1.0 - smoothstep(cmy.x - soft, cmy.x + soft, pC);
        float hM = 1.0 - smoothstep(cmy.y - soft, cmy.y + soft, pM);
        float hY = 1.0 - smoothstep(cmy.z - soft, cmy.z + soft, pY);
        float hK = 1.0 - smoothstep(k - soft, k + soft, pK);
        
        // Combine CMYK -> RGB
        // white - ink
        vec3 resCMY = vec3(hC, hM, hY);
        if (u_colorMode == 3) resCMY += vec3(hK);
        
        outRGB = 1.0 - clamp(resCMY, 0.0, 1.0);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
    }
    
    if (u_gray == 1) {
        float l = dot(outRGB, vec3(0.299, 0.587, 0.114));
        outRGB = vec3(l);
    }
    
    outColor = vec4(outRGB, col.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-bilateral">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_radius;        // 1-30
uniform float u_sigmaCol;    // 0.01 - 1.0
uniform float u_sigmaSpace;  // 0.5 - 15.0
uniform int u_kernel;        // 0=Gauss, 1=Box
uniform int u_edgeMode;      // 0=Luma, 1=RGB

float getDist(vec3 c1, vec3 c2) {
    if (u_edgeMode == 0) {
        float l1 = dot(c1, vec3(0.299, 0.587, 0.114));
        float l2 = dot(c2, vec3(0.299, 0.587, 0.114));
        return abs(l1 - l2);
    } else {
        return length(c1 - c2);
    }
}

void main() {
    vec4 centerCol = texture(u_tex, v_uv);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;
    
    // Separable optimization not easy for true bilateral without ping-pong
    // We will do a full kernel loop but skip somewhat to save perf if radius is high?
    // No, standard loop.
    
    int r = u_radius;
    float fs = u_sigmaSpace;
    float fc = u_sigmaCol;
    
    for (int x = -r; x <= r; x++) {
        for (int y = -r; y <= r; y++) {
            vec2 offset = vec2(float(x), float(y));
            vec2 uv = v_uv + offset / u_res;
            
            vec3 samp = texture(u_tex, uv).rgb;
            
            float spaceDistSq = dot(offset, offset);
            float colorDist = getDist(centerCol.rgb, samp);
            
            float wSpace = 1.0;
            if (u_kernel == 0) wSpace = exp(-spaceDistSq / (2.0 * fs * fs));
            
            float wColor = exp(-(colorDist * colorDist) / (2.0 * fc * fc));
            
            float w = wSpace * wColor;
            
            sum += samp * w;
            weightSum += w;
        }
    }
    
    outColor = vec4(sum / weightSum, centerCol.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-colorMask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;  // RGB 0-1
uniform float u_tolerance;   // 0-1
uniform float u_fade;        // 0-1

void main() {
    vec4 c = texture(u_tex, v_uv);
    float dist = length(c.rgb - u_targetColor);
    float low = u_tolerance - u_fade * 0.5;
    float high = u_tolerance + u_fade * 0.5;
    float mask = smoothstep(low, high, dist);
    // mask = 0 when color matches (to exclude), 1 elsewhere
    outColor = vec4(mask, mask, mask, 1.0);
}
</script>

    <script type="x-shader/x-fragment" id="fs-maskedBlur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    float maskVal = texture(u_mask, v_uv).r;
    vec4 original = texture(u_tex, v_uv);
    
    if (maskVal < 0.01) {
        outColor = original;
        return;
    }
    
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur
        for(float i = -4.0; i <= 4.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (directional only)
        for(float i = -6.0; i <= 6.0; i++) {
            float weight = 1.0 - abs(i) / 6.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.5);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (default)
        for(float i = -4.0; i <= 4.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 2.0)); 
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad);
            color += s * weight;
            total += weight;
        }
    }
    
    vec4 blurred = color / total;
    outColor = mix(original, blurred, maskVal);
}
</script>

    <script type="x-shader/x-fragment" id="fs-maskedDither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    float maskVal = texture(u_mask, v_uv).r;
    
    if (maskVal < 0.01) {
        outColor = col;
        return;
    }
    
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    vec3 dithered = col.rgb + threshold * (u_strength / 100.0) * (1.0 / levels);
    dithered = floor(dithered * levels + 0.5) / levels;
    dithered = floor(dithered * u_paletteSize + 0.5) / u_paletteSize;
    
    vec3 result = mix(col.rgb, dithered, maskVal);
    outColor = vec4(clamp(result, 0.0, 1.0), col.a);
}
</script>

    <script type="x-shader/x-fragment" id="fs-adjustMasked">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_useMask;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Sharpening
    if (u_sharp > 0.0) {
        vec4 sum = vec4(0.0);
        sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x,  u_step.y));
        vec4 edge = c - (sum * 0.25);
        rgb += edge.rgb * (u_sharp / 10.0); 
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    // Apply mask if enabled
    if (u_useMask == 1) {
        float maskVal = texture(u_mask, v_uv).r;
        rgb = mix(original, rgb, maskVal);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script>



    <script>
        // --- GLOBAL STATE ---
        const state = {
            gl: null,
            canvas: null,
            programs: {},
            textures: {},
            fbos: {},
            pingPong: [null, null],
            thumbnailFBO: null,
            baseImage: null,
            width: 1,
            height: 1,
            renderWidth: 1,
            renderHeight: 1,
            fboWidth: 0,
            fboHeight: 0,
            busy: false,
            upscaleFactor: 1,
            renderOrder: ['noise', 'adjust', 'hdr', 'ca', 'blur', 'cell', 'halftone', 'bilateral', 'dither', 'corruption'],
            activeLayerPreview: null,
            activeSection: 'adjust',
            caCenter: { x: 0.5, y: 0.5 },
            isDraggingPin: false,
            layerTextures: {},
            layerVisibility: { noise: true, adjust: true, hdr: true, ca: true, blur: true, cell: true, halftone: true, bilateral: true, dither: true, corruption: true },
            pinIdleTimer: null,
            isPreviewLocked: false // New Lock State
        };

        const UI = {};

        const LAYERS = {
            'noise': { name: 'Noise Group', color: '#fff' },
            'adjust': { name: 'Adjustments', color: '#fff' },
            'hdr': { name: 'HDR Emulation', color: '#fff' },
            'ca': { name: 'Chromatic Aberration', color: '#fff' },
            'blur': { name: 'Blur', color: '#fff' },
            'cell': { name: 'Cell Shading', color: '#fff' },
            'halftone': { name: 'Halftoning', color: '#fff' },
            'bilateral': { name: 'Bilateral Filter', color: '#fff' },
            'dither': { name: 'Dithering', color: '#fff' },
            'corruption': { name: 'Corruption', color: '#fff' },
            'shadows': { name: 'Shadows Mask', color: '#fff' },
            'highlights': { name: 'Highlights Mask', color: '#fff' }
        };

        // --- INIT ---
        window.addEventListener('DOMContentLoaded', async () => {
            // Dynamic UI Collection
            document.querySelectorAll('input, select, button, canvas').forEach(el => {
                if (el.id) UI[el.id] = el;
            });
            // Additional containers
            UI.layerGrid = document.getElementById('layerGrid');
            UI.previewContainer = document.getElementById('previewContainer');
            UI.overlayOriginal = document.getElementById('overlayOriginal');
            UI.loading = document.getElementById('loading');
            UI.hoverZoomValue = document.getElementById('hoverZoomValue');
            UI.hoverZoomSlider = document.getElementById('hoverZoomSlider'); // Fix: Targeted input directly
            UI.zoomResIndicator = document.getElementById('zoomResIndicator');

            // Critical interactive elements (might not be input/button tags)
            UI.caPin = document.getElementById('caPin');
            UI.previewLock = document.getElementById('previewLock');
            UI.resetCenterBtn = document.getElementById('resetCenterBtn');
            UI.upscaleInput = document.getElementById('upscaleInput');

            // Explicitly collect Blur/Dither controls to ensure no initialization race conditions
            const manualIds = [
                'blurEnable', 'blurAmount', 'blurType',
                'blurColorExclude', 'blurTargetColor', 'blurColorTolerance', 'blurColorFade',
                'blurLumaMask', 'blurShadowThreshold', 'blurShadowFade', 'blurHighlightThreshold', 'blurHighlightFade',
                'ditherEnable', 'ditherBitDepth', 'ditherPaletteSize', 'ditherStrength', 'ditherScale', 'ditherType',
                'ditherColorExclude', 'ditherExcludeColor', 'ditherColorTolerance', 'ditherColorFade',
                'ditherLumaMask', 'ditherShadowThreshold', 'ditherShadowFade', 'ditherHighlightThreshold', 'ditherHighlightFade'
            ];
            manualIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) UI[id] = el;
            });

            // Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    e.target.classList.add('active');
                    document.getElementById(e.target.dataset.tab).classList.add('active');
                });
            });

            setupDragLayerList();

            // Track Active Section
            const updateActiveSection = (e) => {
                // Try finding section from ID
                const section = getSectionFromId(e.target.id);
                if (section && section !== state.activeSection) {
                    state.activeSection = section;
                    // Force render to update previews immediately
                    requestRender();
                }
                // Also handle special case: if a <details> is toggled open?
                // The global listener below handles inputs.
            };

            // Listen to all inputs to switch context
            document.addEventListener('input', updateActiveSection);
            document.addEventListener('focus', updateActiveSection, true);
            // Also listen to <details> toggle to switch context to that layer
            document.addEventListener('toggle', (e) => {
                if (e.target.tagName === 'DETAILS' && e.target.open) {
                    // Find the first input's ID to guess the section
                    const input = e.target.querySelector('input, select');
                    if (input) {
                        const section = getSectionFromId(input.id);
                        if (section) {
                            state.activeSection = section;
                            requestRender();
                        }
                    }
                }
            }, true);

            document.querySelectorAll('input[type=range]').forEach(range => {
                const text = range.nextElementSibling;
                if (text && text.classList.contains('control-value')) {
                    const update = () => text.value = range.value;
                    range.addEventListener('input', () => { update(); requestRender(); });
                    update();
                }
            });

            // Specific Listener for Zoom to update State
            if (UI.hoverZoomValue) {
                UI.hoverZoomValue.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!isNaN(val)) state.zoomLevel = val;
                    // requestRender handled by generic listener above? 
                    // No, generic listener only attaches if next element is control-value.
                    // Checking HTML: does hoverZoomValue have sibling? 
                    // Safer to call requestRender here too.
                    requestRender();
                });
            }
            document.querySelectorAll('select, input[type=checkbox], input[type=color]').forEach(el => {
                el.addEventListener('change', requestRender);
                el.addEventListener('input', requestRender);
            });

            // Lock Toggle Logic
            UI.previewLock.addEventListener('change', (e) => {
                state.isPreviewLocked = e.target.checked;
                if (state.isPreviewLocked) {
                    UI.overlayOriginal.classList.remove('show');
                }
            });

            // Upscale
            UI.upscaleInput.addEventListener('change', (e) => {
                let val = parseInt(e.target.value);
                if (isNaN(val) || val < 1) val = 1;
                if (val > 10) val = 10;
                e.target.value = val;
                state.upscaleFactor = val;
                if (state.baseImage) {
                    reallocateBuffers(false);
                    requestRender();
                }
            });

            // Pin Interactions
            UI.resetCenterBtn.addEventListener('click', () => {
                state.caCenter = { x: 0.5, y: 0.5 };
                updatePinPosition();
                requestRender();
            });

            UI.caPin.addEventListener('mousedown', (e) => {
                state.isDraggingPin = true;
                // Lock logic: If globally locked, just keep preview. If not, hide overlay.
                if (!state.isPreviewLocked) UI.overlayOriginal.classList.remove('show');
                clearTimeout(state.pinIdleTimer);
                e.preventDefault();
            });

            window.addEventListener('mouseup', () => {
                if (state.isDraggingPin) {
                    state.isDraggingPin = false;
                    // Idle timer only matters if not locked
                    if (!state.isPreviewLocked) {
                        state.pinIdleTimer = setTimeout(() => {
                            UI.overlayOriginal.classList.add('show');
                        }, 4000);
                    }
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (!state.isDraggingPin) return;
                const rect = UI.previewContainer.getBoundingClientRect();
                let x = (e.clientX - rect.left) / rect.width;
                let y = 1.0 - (e.clientY - rect.top) / rect.height;
                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                state.caCenter = { x, y };
                updatePinPosition();
                requestRender();
            });

            // Preview Hover & Scroll Logic (Refined with Lock)
            let hoverTimeout;
            const pContainer = UI.previewContainer;
            const displayCanvas = UI.displayCanvas;

            // Hover Zoom Slider Logic
            const parseZoom = (val) => {
                let v = parseFloat(val);
                if (isNaN(v)) return 1.0;
                return v;
            };

            UI.hoverZoomSlider.addEventListener('input', () => {
                const val = parseZoom(UI.hoverZoomSlider.value);
                state.zoomLevel = val; // Sync state
                UI.hoverZoomValue.textContent = val.toFixed(1) + 'x';
            });

            // Track if we're currently in zoom mode and lens mode state
            let isZooming = false;
            let isLensMode = false;

            // Lens toggle button
            UI.lensToggleBtn.addEventListener('click', () => {
                isLensMode = !isLensMode;
                UI.lensToggleBtn.textContent = isLensMode ? 'LENS' : 'FULL';
                UI.lensToggleBtn.style.background = isLensMode ? 'var(--accent)' : '';
                UI.lensToggleBtn.style.color = isLensMode ? '#000' : '';
                resetZoom();
            });

            // Setup lens canvas
            const lensSize = 180;
            UI.lensCanvas.width = lensSize;
            UI.lensCanvas.height = lensSize;
            const lensCtx = UI.lensCanvas.getContext('2d');

            // Reset zoom transform when mouse leaves
            const resetZoom = () => {
                displayCanvas.style.transform = '';
                displayCanvas.style.transformOrigin = '';
                displayCanvas.style.zIndex = '';
                UI.zoomResIndicator.style.display = 'none';
                UI.zoomLens.style.display = 'none';
                if (isZooming) {
                    isZooming = false;
                    // Return to preview resolution
                    reallocateBuffers(false);
                    requestRender();
                }
            };

            // Apply zoom transform based on cursor position
            const applyZoom = (e) => {
                const zoomInput = UI.hoverZoomSlider;
                const zoomLevel = parseZoom(zoomInput.value);

                if (zoomLevel <= 1.0) {
                    resetZoom();
                    return;
                }


                // Hide the overlay when zooming
                UI.overlayOriginal.classList.remove('show');

                // Render at full resolution for zoom if not already
                if (!isZooming) {
                    isZooming = true;
                    reallocateBuffers(true);
                    requestRender();
                }

                const rect = pContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const xPct = mouseX / rect.width;
                const yPct = mouseY / rect.height;

                if (isLensMode) {
                    // LENS MODE: Show circular magnifier following cursor
                    displayCanvas.style.transform = '';
                    displayCanvas.style.transformOrigin = '';
                    displayCanvas.style.zIndex = '';

                    // Position lens centered on cursor
                    UI.zoomLens.style.display = 'block';
                    UI.zoomLens.style.left = (mouseX - lensSize / 2) + 'px';
                    UI.zoomLens.style.top = (mouseY - lensSize / 2) + 'px';

                    // Calculate the actual displayed canvas size (object-fit: contain)
                    const canvasAspect = displayCanvas.width / displayCanvas.height;
                    const containerAspect = rect.width / rect.height;
                    let displayedW, displayedH, offsetX, offsetY;

                    if (canvasAspect > containerAspect) {
                        // Canvas is wider than container - width fills, height is centered
                        displayedW = rect.width;
                        displayedH = rect.width / canvasAspect;
                        offsetX = 0;
                        offsetY = (rect.height - displayedH) / 2;
                    } else {
                        // Canvas is taller than container - height fills, width is centered
                        displayedH = rect.height;
                        displayedW = rect.height * canvasAspect;
                        offsetX = (rect.width - displayedW) / 2;
                        offsetY = 0;
                    }

                    // Map mouse position to canvas pixel coordinates
                    const canvasX = ((mouseX - offsetX) / displayedW) * displayCanvas.width;
                    const canvasY = ((mouseY - offsetY) / displayedH) * displayCanvas.height;

                    // Calculate source region size based on zoom
                    const srcSize = lensSize / zoomLevel;
                    const srcX = canvasX - srcSize / 2;
                    const srcY = canvasY - srcSize / 2;

                    // Draw zoomed portion to lens canvas
                    lensCtx.clearRect(0, 0, lensSize, lensSize);
                    lensCtx.drawImage(
                        displayCanvas,
                        Math.max(0, Math.min(srcX, displayCanvas.width - srcSize)),
                        Math.max(0, Math.min(srcY, displayCanvas.height - srcSize)),
                        srcSize, srcSize,
                        0, 0, lensSize, lensSize
                    );
                } else {
                    // FULL MODE: Scale entire canvas from cursor point
                    UI.zoomLens.style.display = 'none';
                    displayCanvas.style.zIndex = '15';
                    displayCanvas.style.transformOrigin = `${xPct * 100}% ${yPct * 100}%`;
                    displayCanvas.style.transform = `scale(${zoomLevel})`;
                }

                // Show resolution indicator
                const srcW = state.width * state.upscaleFactor;
                const srcH = state.height * state.upscaleFactor;
                const bufW = displayCanvas.width;
                const bufH = displayCanvas.height;
                const match = (bufW >= srcW && bufH >= srcH) ? '‚úì FULL RES' : '‚ö† SCALED';
                const modeLabel = isLensMode ? 'LENS' : 'FULL';
                UI.zoomResIndicator.innerHTML = `Mode: ${modeLabel}<br>Source: ${srcW}√ó${srcH}<br>Canvas: ${bufW}√ó${bufH}<br>${match}`;
                UI.zoomResIndicator.style.display = 'block';
                UI.zoomResIndicator.style.color = (bufW >= srcW && bufH >= srcH) ? '#0f0' : '#f80';
                UI.zoomResIndicator.style.borderColor = (bufW >= srcW && bufH >= srcH) ? '#0f0' : '#f80';
            };

            pContainer.addEventListener('mouseenter', (e) => {
                const zoomLevel = parseFloat(UI.hoverZoomSlider.value);
                if (zoomLevel <= 1 && !state.isPreviewLocked && !state.activeLayerPreview) {
                    UI.overlayOriginal.classList.add('show');
                }
                clearTimeout(hoverTimeout);
                applyZoom(e);
            });

            pContainer.addEventListener('mouseleave', () => {
                UI.overlayOriginal.classList.remove('show');
                clearTimeout(hoverTimeout);
                resetZoom();
            });

            pContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                // Show preview immediately
                UI.overlayOriginal.classList.remove('show');

                const sel = UI.blendMode;
                const len = sel.options.length;
                let idx = sel.selectedIndex;
                const dir = Math.sign(e.deltaY);
                idx = (idx + dir + len) % len;
                sel.selectedIndex = idx;

                requestRender();

                // Idle timer only if not locked
                if (!state.isPreviewLocked) {
                    clearTimeout(hoverTimeout);
                    hoverTimeout = setTimeout(() => {
                        // Return to original if not locked
                        if (!state.activeLayerPreview) UI.overlayOriginal.classList.add('show');
                    }, 2000);
                }
            }, { passive: false });

            pContainer.addEventListener('mousemove', (e) => {
                clearTimeout(hoverTimeout);
                const zVal = parseFloat(UI.hoverZoomSlider.value);
                if (!state.isPreviewLocked && !state.activeLayerPreview && zVal <= 1) {
                    UI.overlayOriginal.classList.add('show');
                }
                applyZoom(e);
            });

            // JSON Handlers
            UI.downloadJsonBtn.addEventListener('click', downloadPreset);
            UI.uploadJsonTrigger.addEventListener('click', () => UI.jsonUpload.click());
            UI.jsonUpload.addEventListener('change', uploadPreset);

            initWebGL();

            UI.imageUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = evt => {
                    const img = new Image();
                    img.onload = () => loadNewImage(img);
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            });

            UI.downloadBtn.addEventListener('click', downloadFullRes);
            UI.compareBtn.addEventListener('click', openCompare);
            UI.closeCompare.addEventListener('click', () => document.getElementById('compareModal').classList.remove('show'));
            UI.exportSideBySide.addEventListener('click', () => exportComparison('side'));
            UI.exportStacked.addEventListener('click', () => exportComparison('stack'));

            // --- EYEDROPPER TOOL ---
            const style = document.createElement('style');
            style.textContent = `
                .eyedropper-btn { background: none; border: none; cursor: pointer; font-size: 1.2em; padding: 0 5px; opacity: 0.7; transition: opacity 0.2s; }
                .eyedropper-btn:hover { opacity: 1; }
                .eyedropper-active { cursor: crosshair !important; }
            `;
            document.head.appendChild(style);

            let eyedropperTarget = null;
            document.querySelectorAll('.eyedropper-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    if (eyedropperTarget === targetId) {
                        eyedropperTarget = null;
                        UI.displayCanvas.classList.remove('eyedropper-active');
                    } else {
                        eyedropperTarget = targetId;
                        UI.displayCanvas.classList.add('eyedropper-active');
                    }
                    e.stopPropagation();
                });
            });

            UI.displayCanvas.addEventListener('click', (e) => {
                if (!eyedropperTarget) return;

                const rect = UI.displayCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gl = state.gl;
                const canvas = UI.displayCanvas;
                const cw = canvas.width;
                const ch = canvas.height;

                // Aspect Ratio "Contain" logic
                const imgAspect = cw / ch;
                const rectAspect = rect.width / rect.height;

                let drawW, drawH, ox, oy;
                if (imgAspect > rectAspect) {
                    drawW = rect.width;
                    drawH = rect.width / imgAspect;
                    ox = 0;
                    oy = (rect.height - drawH) / 2;
                } else {
                    drawH = rect.height;
                    drawW = rect.height * imgAspect;
                    ox = (rect.width - drawW) / 2;
                    oy = 0;
                }

                if (x < ox || x > ox + drawW || y < oy || y > oy + drawH) return;

                const relX = (x - ox) / drawW;
                const relY = (y - oy) / drawH;

                // WebGL Y is inverted relative to DOM Y
                const canvasX = relX * cw;
                const canvasY = (1.0 - relY) * ch;

                const pixel = new Uint8Array(4);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.readPixels(canvasX, canvasY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

                const hex = "#" + ((1 << 24) + (pixel[0] << 16) + (pixel[1] << 8) + pixel[2]).toString(16).slice(1);

                const input = document.getElementById(eyedropperTarget);
                if (input) {
                    input.value = hex;
                    input.dispatchEvent(new Event('input'));
                    input.dispatchEvent(new Event('change'));
                }

                eyedropperTarget = null;
                UI.displayCanvas.classList.remove('eyedropper-active');
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && eyedropperTarget) {
                    eyedropperTarget = null;
                    UI.displayCanvas.classList.remove('eyedropper-active');
                }
            });
        });

        // --- JSON PRESETS ---
        function downloadPreset() {
            const preset = {
                values: {},
                checks: {},
                selects: {},
                renderOrder: state.renderOrder,
                layerVisibility: state.layerVisibility,
                upscaleFactor: state.upscaleFactor,
                caCenter: state.caCenter
            };

            // Collect inputs
            document.querySelectorAll('input[type=range]').forEach(el => preset.values[el.id] = el.value);
            document.querySelectorAll('input[type=text].control-value').forEach(el => {
                // Read-only text inputs are for display, skip them
            });
            document.querySelectorAll('input[type=checkbox]').forEach(el => {
                if (!el.id.startsWith('drag-') && el.id !== 'previewLock') { // Skip drag toggles and lock
                    preset.checks[el.id] = el.checked;
                }
            });
            document.querySelectorAll('select').forEach(el => preset.selects[el.id] = el.value);

            const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'grain-settings.json';
            link.click();
        }

        function uploadPreset(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = evt => {
                try {
                    const preset = JSON.parse(evt.target.result);

                    // Apply values
                    if (preset.values) {
                        Object.keys(preset.values).forEach(id => {
                            const el = document.getElementById(id);
                            if (el) { el.value = preset.values[id]; if (el.nextElementSibling) el.nextElementSibling.value = preset.values[id]; }
                        });
                    }
                    if (preset.checks) {
                        Object.keys(preset.checks).forEach(id => {
                            const el = document.getElementById(id);
                            if (el) el.checked = preset.checks[id];
                        });
                    }
                    if (preset.selects) {
                        Object.keys(preset.selects).forEach(id => {
                            const el = document.getElementById(id);
                            if (el) el.value = preset.selects[id];
                        });
                    }

                    // Apply State
                    if (preset.renderOrder) {
                        state.renderOrder = preset.renderOrder;
                        setupDragLayerList();
                    }
                    if (preset.layerVisibility) {
                        state.layerVisibility = preset.layerVisibility;
                        setupDragLayerList();
                    }
                    if (preset.upscaleFactor) {
                        state.upscaleFactor = preset.upscaleFactor;
                        UI.upscaleInput.value = preset.upscaleFactor;
                    }
                    if (preset.caCenter) {
                        state.caCenter = preset.caCenter;
                        updatePinPosition();
                    }

                    requestRender();
                } catch (err) {
                    alert("Error loading JSON: " + err);
                }
            };
            reader.readAsText(file);
        }

        // --- DRAG LAYER LIST ---
        function setupDragLayerList() {
            const list = document.getElementById('layer-drag-list');
            list.innerHTML = '';

            state.renderOrder.forEach((key, index) => {
                const div = document.createElement('div');
                div.className = 'drag-layer';
                div.draggable = true;
                div.dataset.key = key;

                const isChecked = state.layerVisibility[key] ? 'checked' : '';

                div.innerHTML = `
            <div style="display:flex; align-items:center;">
                <span class="drag-handle">‚ò∞</span> 
                <input type="checkbox" class="drag-toggle" data-key="${key}" ${isChecked}>
            </div>
            <span>${LAYERS[key].name}</span>
        `;

                div.querySelector('input').addEventListener('change', (e) => {
                    state.layerVisibility[key] = e.target.checked;
                    requestRender();
                });

                div.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    div.classList.add('dragging');
                });

                div.addEventListener('dragend', () => div.classList.remove('dragging'));

                div.addEventListener('dragover', (e) => e.preventDefault());

                div.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = index;
                    if (fromIndex === toIndex) return;

                    const item = state.renderOrder.splice(fromIndex, 1)[0];
                    state.renderOrder.splice(toIndex, 0, item);

                    setupDragLayerList();
                    setupLayerGridDOM();
                    requestRender();
                });

                list.appendChild(div);
            });
        }

        // --- RENDER LOOP MANAGER ---
        let renderRequested = false;
        function requestRender() {
            if (!renderRequested && state.baseImage) {
                renderRequested = true;
                requestAnimationFrame(() => {
                    renderFrame();
                    renderRequested = false;
                });
            }
        }

        // --- WEBGL CORE ---
        function initWebGL() {
            state.canvas = UI.displayCanvas;
            const gl = state.canvas.getContext('webgl2', { antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: true });
            if (!gl) { alert('WebGL2 not supported.'); return; }

            gl.getExtension('EXT_color_buffer_float');
            gl.getExtension('OES_texture_float_linear');

            state.gl = gl;
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

            state.programs = {
                adjust: createProgram(gl, 'vs-quad', 'fs-adjust'),
                adjustMasked: createProgram(gl, 'vs-quad', 'fs-adjustMasked'),
                mask: createProgram(gl, 'vs-quad', 'fs-mask'),
                colorMask: createProgram(gl, 'vs-quad', 'fs-colorMask'),
                noise: createProgram(gl, 'vs-quad', 'fs-noise'),
                blur: createProgram(gl, 'vs-quad', 'fs-blur'),
                maskedBlur: createProgram(gl, 'vs-quad', 'fs-maskedBlur'),
                composite: createProgram(gl, 'vs-quad', 'fs-composite'),
                chroma: createProgram(gl, 'vs-quad', 'fs-chroma'),
                copy: createProgram(gl, 'vs-quad', 'fs-copy'),
                dither: createProgram(gl, 'vs-quad', 'fs-dither'),
                maskedDither: createProgram(gl, 'vs-quad', 'fs-maskedDither'),
                corruption: createProgram(gl, 'vs-quad', 'fs-corruption'),
                cell: createProgram(gl, 'vs-quad', 'fs-cell'),
                halftone: createProgram(gl, 'vs-quad', 'fs-halftone'),
                bilateral: createProgram(gl, 'vs-quad', 'fs-bilateral'),
                invert: createProgram(gl, 'vs-quad', 'fs-invert')
            };

            const quadVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 0, 0,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                -1, 1, 0, 1,
                1, -1, 1, 0,
                1, 1, 1, 1
            ]), gl.STATIC_DRAW);

            Object.values(state.programs).forEach(p => {
                gl.useProgram(p);
                const posLoc = gl.getAttribLocation(p, 'a_pos');
                const uvLoc = gl.getAttribLocation(p, 'a_uv');
                gl.enableVertexAttribArray(posLoc);
                gl.enableVertexAttribArray(uvLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
                gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);
            });

            const tw = 320, th = 180;
            const tTex = createTexture(gl, null, tw, th);
            const tFbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, tFbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tTex, 0);
            state.thumbnailFBO = { fbo: tFbo, tex: tTex, w: tw, h: th };
        }

        function loadNewImage(img) {
            state.baseImage = img;
            state.width = img.width;
            state.height = img.height;

            const gl = state.gl;
            if (state.textures.base) {
                gl.deleteTexture(state.textures.base);
                state.textures.base = null;
            }
            state.textures.base = createTexture(gl, img);

            // Force FBOs to be reallocated for any size (preview or export) after image change
            state.fboWidth = 0;
            state.fboHeight = 0;

            reallocateBuffers(false);

            UI.downloadBtn.disabled = false;
            UI.compareBtn.disabled = false;

            UI.overlayCanvas.width = img.width;
            UI.overlayCanvas.height = img.height;
            UI.overlayCanvas.getContext('2d').drawImage(img, 0, 0);

            UI.caPin.classList.add('active');

            setupLayerGridDOM();
            requestRender();
        }

        function reallocateBuffers(fullRes = false) {
            const gl = state.gl;
            // Check browser limits
            const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            let targetW, targetH;

            if (fullRes) {
                let requestW = state.width * state.upscaleFactor;
                let requestH = state.height * state.upscaleFactor;
                let scale = 1.0;
                if (requestW > maxTexSize || requestH > maxTexSize) {
                    scale = Math.min(maxTexSize / requestW, maxTexSize / requestH);
                }
                targetW = Math.round(state.width * state.upscaleFactor * scale);
                targetH = Math.round(state.height * state.upscaleFactor * scale);
                state._exportScale = scale; // Store for use in export
            } else {
                const maxDim = 2048;
                let tempW = state.width * state.upscaleFactor;
                let tempH = state.height * state.upscaleFactor;
                let scale = 1.0;
                if (tempW > maxDim || tempH > maxDim) {
                    scale = Math.min(maxDim / tempW, maxDim / tempH);
                }
                targetW = Math.round(tempW * scale);
                targetH = Math.round(tempH * scale);
                // Clamp to max texture size for preview as well
                if (targetW > maxTexSize || targetH > maxTexSize) {
                    const s = Math.min(maxTexSize / targetW, maxTexSize / targetH);
                    targetW = Math.floor(targetW * s);
                    targetH = Math.floor(targetH * s);
                }
                state._exportScale = scale;
            }

            state.renderWidth = targetW;
            state.renderHeight = targetH;

            if (state.fboWidth === targetW && state.fboHeight === targetH) {
                return { w: targetW, h: targetH };
            }

            state.fboWidth = targetW;
            state.fboHeight = targetH;

            const makeFBO = () => {
                const tex = createTexture(gl, null, targetW, targetH);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                return { tex, fbo };
            };

            if (state.pingPong[0]?.tex) { gl.deleteTexture(state.pingPong[0].tex); gl.deleteFramebuffer(state.pingPong[0].fbo); }
            if (state.pingPong[1]?.tex) { gl.deleteTexture(state.pingPong[1].tex); gl.deleteFramebuffer(state.pingPong[1].fbo); }

            state.pingPong[0] = makeFBO();
            state.pingPong[1] = makeFBO();

            ['tempNoise', 'blur1', 'blur2', 'preview'].forEach(k => {
                if (state.textures[k]) gl.deleteTexture(state.textures[k]);
                if (state.fbos[k]) gl.deleteFramebuffer(state.fbos[k]);
            });

            const nse = makeFBO();
            state.textures.tempNoise = nse.tex; state.fbos.tempNoise = nse.fbo;
            const b1 = makeFBO();
            state.textures.blur1 = b1.tex; state.fbos.blur1 = b1.fbo;
            const b2 = makeFBO();
            state.textures.blur2 = b2.tex; state.fbos.blur2 = b2.fbo;

            const prev = makeFBO();
            state.textures.preview = prev.tex; state.fbos.preview = prev.fbo;

            return { w: targetW, h: targetH };
        }

        // --- LAYER LOGIC EXTRACTOR ---
        function renderSingleLayer(gl, key, inputTex, outputFbo, uniforms, force = false) {
            const w = state.renderWidth;
            const h = state.renderHeight;

            if (key === 'adjust') {
                let maskTex = null;
                const hasSH = UI.adjLumaMask?.checked;
                const hasCol = UI.adjColorExclude?.checked;

                if (hasSH || hasCol) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                    if (hasSH) {
                        gl.useProgram(state.programs.mask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.adjShadowThreshold?.value || 0));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.adjShadowFade?.value || 0));
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.adjHighlightThreshold?.value || 1));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.adjHighlightFade?.value || 0));
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    if (hasCol) {
                        const targetColor = UI.adjExcludeColor?.value || '#000000';
                        const r = parseInt(targetColor.slice(1, 3), 16) / 255;
                        const g = parseInt(targetColor.slice(3, 5), 16) / 255;
                        const b = parseInt(targetColor.slice(5, 7), 16) / 255;
                        gl.useProgram(state.programs.colorMask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                        gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), r, g, b);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.adjColorTolerance?.value || 10) / 100.0);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.adjColorFade?.value || 0) / 100.0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    gl.disable(gl.BLEND);
                    maskTex = state.textures.blur1;

                    if (maskTex && UI.adjInvertMask?.checked) {
                        gl.useProgram(state.programs.invert);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        maskTex = state.textures.blur2;
                    }
                }

                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                const prog = state.programs.adjustMasked || state.programs.adjust;
                gl.useProgram(prog);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, inputTex);

                gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bright'), uniforms.u_bright);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_cont'), uniforms.u_cont);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sat'), uniforms.u_sat);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hdrTol'), 0.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hdrAmt'), 0.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_warmth'), uniforms.u_warmth);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sharp'), uniforms.u_sharp);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_step'), uniforms.u_step[0], uniforms.u_step[1]);

                if (maskTex && prog) {
                    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_useMask'), 1);
                } else if (prog) {
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_useMask'), 0);
                }

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                return outputFbo; // Effectively specific texture attached to this FBO
            }
            else if (key === 'hdr') {
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.adjust);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.adjust, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_bright'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_cont'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_sat'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_warmth'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_sharp'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_hdrTol'), uniforms.u_hdrTol);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_hdrAmt'), uniforms.u_hdrAmt);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'noise') {
                gl.useProgram(state.programs.noise);
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.tempNoise);
                gl.uniform1i(gl.getUniformLocation(state.programs.noise, 'u_type'), parseInt(UI.noiseType.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_seed'), Math.random() * 100.0);
                gl.uniform2f(gl.getUniformLocation(state.programs.noise, 'u_res'), w, h);
                gl.uniform2f(gl.getUniformLocation(state.programs.noise, 'u_origRes'), state.width * state.upscaleFactor, state.height * state.upscaleFactor);
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_scale'), parseFloat(UI.noiseSize.value));
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                const blurAmt = parseFloat(UI.blurriness.value) / 100.0;
                let noiseTex = state.textures.tempNoise;
                if (blurAmt > 0) {
                    gl.useProgram(state.programs.blur);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.bindTexture(gl.TEXTURE_2D, state.textures.tempNoise);
                    gl.uniform1i(gl.getUniformLocation(state.programs.blur, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(state.programs.blur, 'u_dir'), 1.0 / w, 0.0);
                    gl.uniform1f(gl.getUniformLocation(state.programs.blur, 'u_rad'), blurAmt * 2.0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                    gl.bindTexture(gl.TEXTURE_2D, state.textures.blur1);
                    gl.uniform2f(gl.getUniformLocation(state.programs.blur, 'u_dir'), 0.0, 1.0 / h);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    noiseTex = state.textures.blur2;
                }

                // Mask
                gl.useProgram(state.programs.mask);
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), UI.enableShadows.checked ? 1 : 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.shadowThreshold.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.shadowFade.value));
                gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), UI.enableHighlights.checked ? 1 : 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.highlightThreshold.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.highlightFade.value));
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Composite
                gl.useProgram(state.programs.composite);
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                // Compute mask texture
                let maskTex = state.textures.blur1;
                if (UI.noiseInvertMask?.checked) {
                    const targetFbo = (noiseTex === state.textures.blur2) ? state.fbos.tempNoise : state.fbos.blur2;
                    const targetTex = (noiseTex === state.textures.blur2) ? state.textures.tempNoise : state.textures.blur2;

                    gl.useProgram(state.programs.invert);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, targetFbo);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.blur1);
                    gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);

                    maskTex = targetTex;
                }

                gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, noiseTex);
                gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, maskTex);

                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_base'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_noise'), 1);
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_mask'), 2);
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_mode'), parseInt(UI.blendMode.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_opacity'), parseFloat(UI.opacity.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_str'), parseFloat(UI.strength.value));
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_nType'), parseInt(UI.noiseType.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_satStr'), parseFloat(UI.satStrength.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_satImp'), parseFloat(UI.satPerNoise.value));
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_ignA'), UI.ignoreAlphaToggle.checked ? 1 : 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_ignAstr'), parseFloat(UI.ignoreAlphaStrength.value));

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'ca') {
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.chroma);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.chroma, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_amt'), uniforms.u_ca_amt);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_blur'), uniforms.u_ca_blur);
                gl.uniform2f(gl.getUniformLocation(state.programs.chroma, 'u_center'), uniforms.u_ca_center[0], uniforms.u_ca_center[1]);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_radius'), uniforms.u_ca_rad);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_falloff'), uniforms.u_ca_fall);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'blur') {
                if (!UI.blurEnable?.checked) {
                    // Pass-through copy if needed, but often we just skip.
                    // If we need to write to outputFbo to maintain chain:
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }

                let maskTex = null;
                const hasSH = UI.blurLumaMask?.checked;
                const hasCol = UI.blurColorExclude?.checked;

                if (hasSH || hasCol) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                    if (hasSH) {
                        gl.useProgram(state.programs.mask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.blurShadowThreshold?.value || 0));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.blurShadowFade?.value || 0));
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.blurHighlightThreshold?.value || 1));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.blurHighlightFade?.value || 0));
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    if (hasCol) {
                        const targetColor = UI.blurTargetColor?.value || '#000000';
                        const r = parseInt(targetColor.slice(1, 3), 16) / 255;
                        const g = parseInt(targetColor.slice(3, 5), 16) / 255;
                        const b = parseInt(targetColor.slice(5, 7), 16) / 255;
                        gl.useProgram(state.programs.colorMask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                        gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), r, g, b);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.blurColorTolerance?.value || 10) / 100.0);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.blurColorFade?.value || 20) / 100.0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    gl.disable(gl.BLEND);
                    gl.disable(gl.BLEND);
                    maskTex = state.textures.blur1;

                    if (maskTex && UI.blurInvertMask?.checked) {
                        // Blur uses blur2 for H Pass, so we must use tempNoise for inverted mask
                        gl.useProgram(state.programs.invert);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.tempNoise);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        maskTex = state.textures.tempNoise;
                    }
                }

                const blurAmt = parseFloat(UI.blurAmount?.value || 0) / 100.0;
                if (blurAmt > 0) {
                    const prog = maskTex ? state.programs.maskedBlur : state.programs.blur;
                    gl.useProgram(prog);
                    // H Pass
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(prog, 'u_dir'), 1.0 / w, 0.0);
                    gl.uniform1f(gl.getUniformLocation(prog, 'u_rad'), blurAmt * 2.0);
                    if (maskTex) {
                        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                        gl.uniform1i(gl.getUniformLocation(prog, 'u_blurType'), parseInt(UI.blurType?.value || 0));
                    }
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    // V Pass
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.blur2);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(prog, 'u_dir'), 0.0, 1.0 / h);
                    if (maskTex) {
                        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                    }
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                } else {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
            }
            else if (key === 'cell') {
                if (!UI.cellEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.cell);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(state.programs.cell, 'u_res'), w, h);
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_levels'), parseInt(UI.cellLevels?.value || 4));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_bias'), parseFloat(UI.cellBias?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_gamma'), parseFloat(UI.cellGamma?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_quantMode'), parseInt(UI.cellQuantMode?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_bandMap'), parseInt(UI.cellBandMap?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_edgeMethod'), parseInt(UI.cellEdgeMethod?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_edgeStr'), parseFloat(UI.cellEdgeStr?.value || 1));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_edgeThick'), parseFloat(UI.cellEdgeThick?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_colorPreserve'), UI.cellColorPreserve?.checked ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_edgeEnable'), UI.cellEdgeEnable?.checked ? 1 : 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'halftone') {
                if (!UI.halftoneEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.halftone);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(state.programs.halftone, 'u_res'), w, h);
                gl.uniform1f(gl.getUniformLocation(state.programs.halftone, 'u_size'), parseFloat(UI.halftoneSize?.value || 4));
                gl.uniform1f(gl.getUniformLocation(state.programs.halftone, 'u_intensity'), parseFloat(UI.halftoneIntensity?.value || 1));
                gl.uniform1f(gl.getUniformLocation(state.programs.halftone, 'u_sharpness'), parseFloat(UI.halftoneSharpness?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_pattern'), parseInt(UI.halftonePattern?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_colorMode'), parseInt(UI.halftoneColorMode?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_sample'), parseInt(UI.halftoneSample?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_gray'), UI.halftoneGray?.checked ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_lock'), UI.halftoneScreenLock?.checked ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_invert'), UI.halftoneInvert?.checked ? 1 : 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'bilateral') {
                if (!UI.bilateralEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                const iters = Math.max(1, parseInt(UI.bilateralIter?.value || 1));
                gl.useProgram(state.programs.bilateral);
                gl.uniform2f(gl.getUniformLocation(state.programs.bilateral, 'u_res'), w, h);
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_radius'), parseInt(UI.bilateralRadius?.value || 2));
                gl.uniform1f(gl.getUniformLocation(state.programs.bilateral, 'u_sigmaCol'), parseFloat(UI.bilateralColorSig?.value || 0.1));
                gl.uniform1f(gl.getUniformLocation(state.programs.bilateral, 'u_sigmaSpace'), parseFloat(UI.bilateralSpatialSig?.value || 2));
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_kernel'), parseInt(UI.bilateralKernel?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_edgeMode'), parseInt(UI.bilateralEdgeMode?.value || 0));

                // Single pass for now as logic for pingpong inside here is complex without new FBOs
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_tex'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'dither') {
                if (!UI.ditherEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }

                let maskTex = null;
                const hasSH = UI.ditherLumaMask?.checked;
                const hasCol = UI.ditherColorExclude?.checked;

                if ((hasSH || hasCol) && state.fbos.blur1) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                    if (hasSH) {
                        gl.useProgram(state.programs.mask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.ditherShadowThreshold?.value || 0));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.ditherShadowFade?.value || 0));
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.ditherHighlightThreshold?.value || 1));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.ditherHighlightFade?.value || 0));
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    if (hasCol) {
                        const targetColor = UI.ditherExcludeColor?.value || '#000000';
                        const r = parseInt(targetColor.slice(1, 3), 16) / 255;
                        const g = parseInt(targetColor.slice(3, 5), 16) / 255;
                        const b = parseInt(targetColor.slice(5, 7), 16) / 255;
                        gl.useProgram(state.programs.colorMask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                        gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), r, g, b);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.ditherColorTolerance?.value || 10) / 100.0);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.ditherColorFade?.value || 0) / 100.0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    gl.disable(gl.BLEND);
                    maskTex = state.textures.blur1;

                    if (maskTex && UI.ditherInvertMask?.checked) {
                        gl.useProgram(state.programs.invert);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        maskTex = state.textures.blur2;
                    }
                }

                const prog = maskTex ? state.programs.maskedDither : state.programs.dither;
                gl.useProgram(prog);

                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_type'), parseInt(UI.ditherType?.value || 0));
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bitDepth'), parseFloat(UI.ditherBitDepth?.value || 4));
                gl.uniform1f(gl.getUniformLocation(prog, 'u_paletteSize'), parseFloat(UI.ditherPaletteSize?.value || 16));
                gl.uniform1f(gl.getUniformLocation(prog, 'u_strength'), parseFloat(UI.ditherStrength?.value || 50) / 100.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_scale'), parseFloat(UI.ditherScale?.value || 1));
                gl.uniform2f(gl.getUniformLocation(prog, 'u_res'), w, h);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_seed'), Math.random() * 100.0);

                if (maskTex) {
                    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                }

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'corruption') {
                if (!UI.corruptionEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.corruption);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.corruption, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.corruption, 'u_algorithm'), parseInt(UI.corruptionAlgorithm?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.corruption, 'u_resScale'), parseFloat(UI.corruptionResScale?.value || 1));
                gl.uniform2f(gl.getUniformLocation(state.programs.corruption, 'u_res'), w, h);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
        }

        // --- PIPELINE EXECUTION ---

        function renderFrame(isExport = false) {
            if (!state.baseImage) return;
            const gl = state.gl;
            const size = reallocateBuffers(isExport);
            const w = size.w;
            const h = size.h;
            gl.viewport(0, 0, w, h);

            let inputIdx = 0;
            let outputIdx = 1;

            // --- Fix: Draw upscaled base image to a temp canvas and upload as texture ---
            let baseTex = state.textures.base;
            if (isExport && (w !== state.width || h !== state.height)) {
                // Create a temp canvas at upscaled size, always using (w, h) as the destination
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(state.baseImage, 0, 0, state.width, state.height, 0, 0, w, h);
                // Create a new texture from the upscaled image
                baseTex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, baseTex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tempCanvas);
            }

            // Start with Base
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.pingPong[0].fbo);
            gl.useProgram(state.programs.copy);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, baseTex);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Clean up temp texture if created
            if (isExport && baseTex !== state.textures.base) {
                gl.deleteTexture(baseTex);
            }

            const uniforms = {
                u_bright: parseFloat(UI.brightness.value),
                u_cont: parseFloat(UI.contrast.value),
                u_sat: parseFloat(UI.saturationAdj.value) / 100.0,
                u_warmth: parseFloat(UI.warmth.value),
                u_sharp: parseFloat(UI.sharpen.value),
                u_step: [1.0 / w, 1.0 / h],
                u_hdrTol: parseFloat(UI.hdrTolerance.value),
                u_hdrAmt: parseFloat(UI.hdrAmount.value),
                u_ca_amt: calcCurve(parseFloat(UI.aberrationAmount.value), 300, 300),
                u_ca_blur: calcCurve(parseFloat(UI.aberrationBlur.value), 100, 100.0),
                u_ca_center: [state.caCenter.x, state.caCenter.y],
                u_ca_rad: parseFloat(UI.caRadius.value) / 1000.0,
                u_ca_fall: parseFloat(UI.caFalloff.value) / 1000.0,
            };

            state.renderOrder.forEach(layerKey => {
                if (!state.layerVisibility[layerKey]) return;

                // Execute layer
                renderSingleLayer(gl, layerKey, state.pingPong[inputIdx].tex, state.pingPong[outputIdx].fbo, uniforms);

                // Save output for chain preview (and old grid logic)
                state.layerTextures[layerKey] = state.pingPong[outputIdx].tex;

                // Swap buffers
                let temp = inputIdx; inputIdx = outputIdx; outputIdx = temp;
            });

            // FINAL OUTPUT
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // Resize canvas DOM element to match render size
            // Setting width/height clears the canvas if preserveDrawingBuffer is false (it's true, but safer to assume it clears).
            // We draw immediately after resize.
            if (gl.canvas.width !== w || gl.canvas.height !== h) {
                gl.canvas.width = w;
                gl.canvas.height = h;
            }
            gl.viewport(0, 0, w, h);

            const sourceTex = state.activeLayerPreview && state.layerTextures[state.activeLayerPreview]
                ? state.layerTextures[state.activeLayerPreview]
                : state.pingPong[inputIdx].tex;

            gl.useProgram(state.programs.copy);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, sourceTex);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);

            let chan = 0;
            if (state.activeLayerPreview === 'shadows') chan = 2;
            if (state.activeLayerPreview === 'highlights') chan = 3;
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), chan);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Ensure rendering is complete before export (toDataURL relies on buffer)
            if (isExport) {
                gl.finish();
            } else {
                updateLayerPreviews();
            }
        }

        function calcCurve(val, max, scale = 1.0) {
            const norm = val / max;
            return (norm * norm) * scale;
        }

        function updatePinPosition() {
            const x = state.caCenter.x * 100;
            const y = (1.0 - state.caCenter.y) * 100;
            UI.caPin.style.left = x + '%';
            UI.caPin.style.top = y + '%';
        }

        function createShader(gl, type, srcId) {
            const src = document.getElementById(srcId).text.trim();
            const shader = gl.createShader(type == 'vs-quad' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
            gl.shaderSource(shader, src);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsId, fsId) {
            const vs = createShader(gl, 'vs-quad', vsId);
            const fs = createShader(gl, 'fs-fragment', fsId);
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.attachShader(p, fs);
            gl.linkProgram(p);
            return p;
        }

        function createTexture(gl, img, w, h) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            if (img) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            }
            return tex;
        }

        // --- UTILS: EXPORT & UI ---

        async function downloadFullRes() {
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            // Ensure buffers are allocated for full resolution export
            reallocateBuffers(true);
            renderFrame(true);

            const link = document.createElement('a');
            link.download = 'grain-export.png';
            link.href = state.canvas.toDataURL('image/png', 1.0);
            link.click();

            // Restore buffers to preview size after export
            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        async function openCompare() {
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            renderFrame(true);

            const original = document.getElementById('compareOriginal');
            const processed = document.getElementById('compareProcessed');

            const aspect = state.width / state.height;
            original.width = 600; original.height = 600 / aspect;
            processed.width = 600; processed.height = 600 / aspect;

            const ctxO = original.getContext('2d');
            const ctxP = processed.getContext('2d');

            ctxO.drawImage(state.baseImage, 0, 0, original.width, original.height);
            ctxP.drawImage(state.canvas, 0, 0, processed.width, processed.height);

            document.getElementById('compareModal').classList.add('show');

            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        async function exportComparison(mode) {
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            renderFrame(true);
            const processedData = state.canvas.toDataURL();
            const processedImg = new Image();
            processedImg.src = processedData;
            await new Promise(r => processedImg.onload = r);

            const exp = document.createElement('canvas');
            const w = state.canvas.width;
            const h = state.canvas.height;

            if (mode === 'side') {
                exp.width = w * 2;
                exp.height = h;
                const ctx = exp.getContext('2d');
                ctx.drawImage(state.baseImage, 0, 0, w, h);
                ctx.drawImage(processedImg, w, 0);
            } else {
                exp.width = w;
                exp.height = h * 2;
                const ctx = exp.getContext('2d');
                ctx.drawImage(state.baseImage, 0, 0, w, h);
                ctx.drawImage(processedImg, 0, h);
            }

            const link = document.createElement('a');
            link.download = `grain-compare-${mode}.png`;
            link.href = exp.toDataURL('image/png', 0.9);
            link.click();

            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        // --- PREVIEW SYSTEM REFACTOR ---

        function getSectionFromId(id) {
            if (!id) return null;
            if (id.startsWith('adj') || id === 'brightness' || id === 'contrast' || id === 'saturationAdj' || id === 'warmth' || id === 'sharpen') return 'adjust';
            if (id.startsWith('hdr')) return 'hdr';
            if (id.startsWith('noise') || id === 'opacity' || id === 'strength' || id === 'blendMode' || id.startsWith('sat') || id.startsWith('ignore')) return 'noise';
            if (id.startsWith('blur')) return 'blur';
            if (id.startsWith('dither')) return 'dither';
            if (id.startsWith('cell')) return 'cell';
            if (id.startsWith('halftone')) return 'halftone';
            if (id.startsWith('bilateral')) return 'bilateral';
            if (id.startsWith('aberration') || id.startsWith('ca')) return 'ca';
            if (id.startsWith('corruption')) return 'corruption';
            return 'adjust'; // Default fallthrough to adjust if unknown (or null)
        }

        function setupLayerGridDOM(section) {
            const grid = UI.layerGrid;
            grid.innerHTML = '';

            const items = [
                { id: 'chain', label: 'Chain Result' },
                { id: 'isolated', label: 'Isolated Layer' }
            ];

            const checks = {
                'blur': ['blurLumaMask', 'blurColorExclude'],
                'dither': ['ditherLumaMask', 'ditherColorExclude'],
                'halftone': ['halftoneLumaMask', 'halftoneColorExclude'],
                'bilateral': ['bilateralLumaMask', 'bilateralColorExclude'],
                'adjust': ['adjLumaMask', 'adjColorExclude'],
                'noise': ['enableShadows', 'enableHighlights']
            };

            if (['blur', 'dither', 'halftone', 'bilateral', 'adjust', 'noise'].includes(section)) {
                items.push({ id: 'mask', label: 'Mask' });
            }

            items.forEach(item => {
                const d = document.createElement('div');
                d.className = 'layer-item';
                const key = section + '_' + item.id;
                if (state.activeLayerPreview === key) d.classList.add('active');

                d.onclick = () => {
                    const targetKey = section + '_' + item.id;
                    if (state.activeLayerPreview === targetKey) {
                        state.activeLayerPreview = null;
                        d.classList.remove('active');
                    } else {
                        state.activeLayerPreview = targetKey;
                        document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('active'));
                        d.classList.add('active');
                        UI.overlayOriginal.classList.remove('show');
                    }
                    requestRender();
                };

                d.innerHTML = `<div class="layer-title">${item.label}</div><canvas class="layer-canvas" id="thumb-${item.id}" width="320" height="180"></canvas>`;
                grid.appendChild(d);
            });
        }

        function updateLayerPreviews() {
            const gl = state.gl;
            if (!state.baseImage) return;

            const section = state.activeSection || 'adjust';

            if (state.lastActiveSectionDOM !== section) {
                setupLayerGridDOM(section);
                state.lastActiveSectionDOM = section;
            }

            if (!state.thumbnailFBO) return;

            // 1. Chain Result
            const chainTex = state.layerTextures[section];
            drawToThumbnail(chainTex, 'thumb-chain');

            // 2. Isolated Result
            const uniforms = {
                u_bright: parseFloat(UI.brightness.value),
                u_cont: parseFloat(UI.contrast.value),
                u_sat: parseFloat(UI.saturationAdj.value) / 100.0,
                u_warmth: parseFloat(UI.warmth.value),
                u_sharp: parseFloat(UI.sharpen.value),
                u_step: [1.0 / state.renderWidth, 1.0 / state.renderHeight],
                u_hdrTol: parseFloat(UI.hdrTolerance.value),
                u_hdrAmt: parseFloat(UI.hdrAmount.value),
                u_ca_amt: calcCurve(parseFloat(UI.aberrationAmount.value), 300, 300),
                u_ca_blur: calcCurve(parseFloat(UI.aberrationBlur.value), 100, 100.0),
                u_ca_center: [state.caCenter.x, state.caCenter.y],
                u_ca_rad: parseFloat(UI.caRadius.value) / 1000.0,
                u_ca_falloff: parseFloat(UI.caFalloff.value) / 1000.0
            };

            // Clear Blur1 FBO to ensure clean mask preview state (prevents stale noise/garbage)
            if (state.fbos.blur1) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }

            renderSingleLayer(gl, section, state.textures.base, state.fbos.preview, uniforms, true);
            drawToThumbnail(state.textures.preview, 'thumb-isolated');

            if (state.activeLayerPreview === section + '_isolated') {
                state.layerTextures[state.activeLayerPreview] = state.textures.preview;
            }

            // 3. Mask Result (Simplified Luma for now as we don't have separate mask gen function yet)
            // But renderSingleLayer might have populated state.textures.blur1 if mask was used?
            // Yes, if mask enabled.
            const maskCanvas = document.getElementById('thumb-mask');
            if (maskCanvas) {
                // If masking is enabled in UI, blur1 should have it.
                // If not enabled, it might be stale or white.
                // Ideally we force render mask.
                // For now, draw whatever is in blur1 if ID exists.
                drawToThumbnail(state.textures.blur1, 'thumb-mask');
                if (state.activeLayerPreview === section + '_mask') {
                    state.layerTextures[state.activeLayerPreview] = state.textures.blur1;
                }
            }
        }

        function drawToThumbnail(tex, canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !tex) return;
            const gl = state.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, state.thumbnailFBO.fbo);
            gl.viewport(0, 0, state.thumbnailFBO.w, state.thumbnailFBO.h);
            gl.useProgram(state.programs.copy);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            const pixels = new Uint8Array(state.thumbnailFBO.w * state.thumbnailFBO.h * 4);
            gl.readPixels(0, 0, state.thumbnailFBO.w, state.thumbnailFBO.h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(state.thumbnailFBO.w, state.thumbnailFBO.h);

            // Flip Y
            const w = state.thumbnailFBO.w;
            const h = state.thumbnailFBO.h;
            for (let y = 0; y < h; y++) {
                const srcY = h - 1 - y;
                const srcOff = srcY * w * 4;
                const dstOff = y * w * 4;
                for (let i = 0; i < w * 4; i++) {
                    imgData.data[dstOff + i] = pixels[srcOff + i];
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }
    </script>
</body>

</html>