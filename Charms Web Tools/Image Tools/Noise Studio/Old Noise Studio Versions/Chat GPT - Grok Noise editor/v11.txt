<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Digital Grain Studio â€” GPU Accelerated</title>
<style>
:root{ --bg:#000; --fg:#fff; --panel-max:460px; --muted:#8c8c8c; --accent:#2a9df4; --border: rgba(255,255,255,0.08); }
*{box-sizing:border-box}
html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:'Courier New', monospace}
body{padding:16px; display:flex; gap:16px; align-items:flex-start; min-height:100vh}
.container{display:flex; gap:16px; width:100%; height: 100%;}

/* Left control column */
.controls-panel{flex:0 0 var(--panel-max); max-width:var(--panel-max); min-width:260px; padding-right:10px; overflow-y:auto; height:100%; scrollbar-width: thin; scrollbar-color: var(--muted) var(--bg);}
.controls-panel h1{font-size:18px; margin:0 0 4px 0; text-align:center; letter-spacing: -0.5px;}
.muted{color:var(--muted); font-size:12px; margin-bottom: 12px; display: block; text-align: center;}
details{border:1px solid var(--border); margin-bottom:8px; padding:6px; border-radius:4px; background:#0a0a0a}
summary{cursor:pointer; font-weight:bold; margin:0 0 6px 0; outline:none; user-select: none; font-size: 13px;}
summary:hover { color: var(--accent); }
.control-row{display:flex; gap:8px; align-items:center; margin-bottom:6px; min-height:28px}
.control-row label{flex:0 0 130px; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size: 12px;}
input[type=range]{flex:1; accent-color: var(--accent); cursor: pointer;}
.control-value{width:70px; padding:2px 4px; text-align:right; background:#000; color:var(--fg); border:1px solid var(--border); font-family:monospace; font-size: 11px;}
select.control-value{flex:1; min-width:120px; padding:4px}
.row-buttons{display:flex; gap:8px; margin-top:12px; flex-wrap: wrap;}
button{background:#111; color:var(--fg); border:1px solid var(--border); padding:8px 12px; cursor:pointer; font-family: monospace; font-size: 12px; transition: all 0.2s;}
button:hover:not(:disabled){background:var(--accent); color:#000; border-color:var(--accent);}
button:disabled { opacity: 0.5; cursor: not-allowed; }

/* Right preview column */
.preview-column{flex:1 1 auto; min-width:320px; display:flex; flex-direction:column; gap:12px; height: 100%; overflow: hidden;}
.preview-top{display:flex; align-items:center; justify-content:space-between; gap:12px}
.preview-container{
    position:relative; 
    border:1px solid var(--border); 
    background: repeating-linear-gradient(45deg, #111 0px, #111 10px, #0e0e0e 10px, #0e0e0e 20px);
    overflow:hidden; 
    flex: 1;
    display:flex; 
    align-items:center; 
    justify-content:center;
    min-height: 300px;
}

/* Canvas Display */
canvas { display: block; }
#displayCanvas { width: 100%; height: 100%; object-fit: contain; box-shadow: 0 0 20px rgba(0,0,0,0.5); }

/* Overlay (Original) */
.overlay-original{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index: 10;}
.overlay-original canvas{ width: 100%; height: 100%; object-fit: contain; opacity:0; transition:opacity 0.2s ease; }
.overlay-original.show canvas{ opacity:1 }

/* Layer Grid */
.layer-preview-window{ border:1px solid var(--border); background:#050505; padding:10px; height: 180px; flex: 0 0 180px; overflow-y:auto;}
.layer-grid{ display:flex; gap:10px; }
.layer-item{ border:1px solid var(--border); padding:6px; min-width: 140px; display:flex; flex-direction:column; gap:6px; background:#000}
.layer-title{ color:var(--muted); font-size:10px; text-transform: uppercase; text-align: center;}
.layer-canvas{ width:100%; aspect-ratio: 16/9; background:#111; border: 1px solid #222; object-fit: contain;}

/* Modals */
.modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; opacity:0; pointer-events:none; transition:opacity 0.2s; z-index:3000}
.modal-overlay.show{ opacity:1; pointer-events:auto}
.modal{ background:#111; border:1px solid var(--border); padding:20px; max-width:90vw; max-height:90vh; overflow:auto; box-shadow: 0 0 50px rgba(0,0,0,0.8);}

/* Loading Indicator */
#loading { position: fixed; top: 10px; right: 10px; background: var(--accent); color: #000; padding: 4px 8px; font-size: 11px; font-weight: bold; display: none; z-index: 4000;}

@media (max-width:900px){ 
    body{padding:10px; flex-direction: column;} 
    .container { flex-direction: column; }
    .controls-panel{ width:100%; max-width: none; flex: none; height: auto; max-height: 40vh;} 
    .preview-column{ width:100%; height: 50vh;} 
}
</style>
</head>
<body>

<div id="loading">PROCESSING GPU...</div>

<div class="container">
    <div class="controls-panel">
      <h1>DIGITAL GRAIN [GPU]</h1>
      <span class="muted">WebGL2 Accelerated Pipeline</span>

      <div style="margin:10px 0; border: 1px dashed var(--border); padding: 10px; text-align: center;">
        <label for="imageUpload" style="cursor: pointer; display: block;">
            <span style="font-size: 24px; display: block; margin-bottom: 5px;">ðŸ“‚</span>
            <span style="font-size: 12px; color: var(--accent);">CLICK TO LOAD IMAGE</span>
        </label>
        <input id="imageUpload" type="file" accept="image/*" style="display: none;">
      </div>

      <!-- Noise Basics -->
      <details open>
        <summary>Noise Basics</summary>
        <div class="control-row">
          <label>Noise Strength</label>
          <input id="strength" type="range" min="0" max="150" step="0.1" value="40">
          <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
          <label>Noise Type</label>
          <select id="noiseType" class="control-value">
            <option value="1" selected>Grayscale</option>
            <option value="0">Color</option>
            <option value="2">Blend (Sat)</option>
          </select>
        </div>
        <div class="control-row">
          <label>Sat Strength</label>
          <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1">
          <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
          <label>Sat Impact</label>
          <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0">
          <input type="text" class="control-value" readonly>
        </div>
      </details>

      <!-- Noise Shape -->
      <details open>
        <summary>Shape & Blur</summary>
        <div class="control-row">
          <label>Scale (Size)</label>
          <input id="noiseSize" type="range" min="0" max="1000" step="1" value="4">
          <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
          <label>Blurriness</label>
          <input id="blurriness" type="range" min="0" max="1000" step="1" value="0">
          <input type="text" class="control-value" readonly>
        </div>
      </details>

      <!-- Blend -->
      <details open>
        <summary>Blend & Opacity</summary>
        <div class="control-row">
          <label>Blend Mode</label>
          <select id="blendMode" class="control-value">
            <option value="0">Normal</option>
            <option value="1" selected>Overlay</option>
            <option value="2">Screen</option>
            <option value="3">Multiply</option>
            <option value="4">Add</option>
            <option value="5">Difference</option>
          </select>
        </div>
        <div class="control-row">
          <label>Opacity</label>
          <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5">
          <input type="text" class="control-value" readonly>
        </div>
      </details>

      <!-- Masking -->
      <details>
        <summary>Luminance Masking</summary>
        <div class="control-row">
            <label>Shadows</label>
            <input id="enableShadows" type="checkbox">
            <label style="color: var(--muted); margin-left: auto;">Enable</label>
        </div>
        <div class="control-row">
            <label>S. Threshold</label>
            <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0.3">
            <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
            <label>S. Fade</label>
            <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0.2">
            <input type="text" class="control-value" readonly>
        </div>
        <div style="height: 10px;"></div>
        <div class="control-row">
            <label>Highlights</label>
            <input id="enableHighlights" type="checkbox">
            <label style="color: var(--muted); margin-left: auto;">Enable</label>
        </div>
        <div class="control-row">
            <label>H. Threshold</label>
            <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0.7">
            <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
            <label>H. Fade</label>
            <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0.2">
            <input type="text" class="control-value" readonly>
        </div>
      </details>

      <!-- Adjustments -->
      <details>
        <summary>Adjustments</summary>
        <div class="control-row">
            <label>Brightness</label>
            <input id="brightness" type="range" min="-100" max="100" step="1" value="0">
            <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
            <label>Contrast</label>
            <input id="contrast" type="range" min="-100" max="200" step="1" value="0">
            <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
            <label>Saturation</label>
            <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0">
            <input type="text" class="control-value" readonly>
        </div>
      </details>

      <!-- HDR -->
      <details>
        <summary>HDR Emulation</summary>
        <div class="control-row">
            <label>Tolerance</label>
            <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35">
            <input type="text" class="control-value" readonly>
        </div>
        <div class="control-row">
            <label>Amount</label>
            <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0">
            <input type="text" class="control-value" readonly>
        </div>
      </details>

      <!-- Chromatic Aberration (New Feature) -->
      <details>
          <summary>Chromatic Aberration</summary>
          <div class="control-row">
              <label>Amount</label>
              <!-- Increased Max to 300 for stronger effect -->
              <input id="aberrationAmount" type="range" min="0" max="300" step="1" value="0">
              <input type="text" class="control-value" readonly>
          </div>
          <div class="control-row">
              <label>Edge Blur</label>
              <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0">
              <input type="text" class="control-value" readonly>
          </div>
          <div class="control-row">
              <label>Center X</label>
              <input id="centerX" type="range" min="0" max="1" step="0.01" value="0.5">
              <input type="text" class="control-value" readonly>
          </div>
          <div class="control-row">
              <label>Center Y</label>
              <input id="centerY" type="range" min="0" max="1" step="0.01" value="0.5">
              <input type="text" class="control-value" readonly>
          </div>
      </details>

      <!-- Alpha -->
      <details>
        <summary>Alpha Channel</summary>
        <div class="control-row">
            <label>Ignore Alpha</label>
            <input id="ignoreAlphaToggle" type="checkbox" checked>
        </div>
        <div class="control-row">
            <label>Strength</label>
            <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100">
            <input type="text" class="control-value" readonly>
        </div>
      </details>

      <div class="row-buttons">
          <button id="downloadBtn" disabled>DOWNLOAD FULL RES</button>
          <button id="compareBtn" disabled>COMPARE / EXPORT</button>
      </div>

    </div>

    <div class="preview-column">
        <div class="preview-top">
            <h3 style="margin:0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Main Preview</h3>
            <div style="font-size: 11px; color: var(--muted)">Hover image to see original</div>
        </div>

        <div class="preview-container" id="previewContainer">
            <canvas id="displayCanvas"></canvas>
            <div class="overlay-original" id="overlayOriginal">
                <!-- Original image drawn here for comparison -->
                <canvas id="overlayCanvas"></canvas> 
            </div>
        </div>

        <div class="preview-top">
            <h3 style="margin:0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Layer Breakdown</h3>
        </div>
        <div class="layer-preview-window">
            <div class="layer-grid" id="layerGrid">
                <!-- populated by JS -->
            </div>
        </div>
    </div>
</div>

<!-- Compare Modal -->
<div id="compareModal" class="modal-overlay">
    <div class="modal">
        <h2 style="margin-top:0">Comparison & Export</h2>
        <div style="display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap;">
            <div>
                <div class="muted">Original</div>
                <canvas id="compareOriginal" style="max-height: 40vh; max-width: 40vw; border: 1px solid #333;"></canvas>
            </div>
            <div>
                <div class="muted">Processed</div>
                <canvas id="compareProcessed" style="max-height: 40vh; max-width: 40vw; border: 1px solid #333;"></canvas>
            </div>
        </div>
        <div style="text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
            <button id="exportSideBySide">Export Side-by-Side</button>
            <button id="exportStacked">Export Stacked</button>
            <button id="closeCompare">Close</button>
        </div>
    </div>
</div>

<!-- WEBGL SHADERS -->
<script type="x-shader/x-vertex" id="vs-quad">
#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="fs-adjust">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;

vec3 rgb2lum(vec3 c) { return vec3(dot(c, vec3(0.299, 0.587, 0.114))); }

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // HDR Emulation (Darken shadows based on tolerance)
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script>

<script type="x-shader/x-fragment" id="fs-mask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; // bools passed as int
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.299,0.587,0.114));
    
    // Default to fully visible (white) if no masks are active
    if (u_useS == 0 && u_useH == 0) {
        outColor = vec4(1.0, 0.0, 0.0, 1.0);
        return;
    }
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="fs-noise">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; // 0=color, 1=gray, 2=blend
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; // Original image resolution

// Dave Hoskins Hash without Sine (to avoid banding/patterns)
// https://www.shadertoy.com/view/4djSRW
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    // We want the noise size to be consistent regardless of the current preview resolution
    // So we use UV coordinates multiplied by the ORIGINAL resolution, then divided by scale
    vec2 pos = v_uv * u_origRes;
    
    // Pixelate based on scale
    vec2 cell = floor(pos / max(1.0, u_scale));
    
    vec3 n;
    if (u_type == 1) { // Gray
        float r = hash12(cell + u_seed);
        n = vec3(r);
    } else { // Color or Blend Base
        float r = hash12(cell + u_seed);
        float g = hash12(cell + u_seed + 1.23);
        float b = hash12(cell + u_seed + 2.45);
        n = vec3(r, g, b);
    }
    
    outColor = vec4(n, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="fs-blur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; // (1.0/width, 0) or (0, 1.0/height)
uniform float u_rad;

void main() {
    vec4 color = vec4(0.0);
    // Simple 9-tap gaussian approx
    float total = 0.0;
    // We sample -4 to 4
    for(float i = -4.0; i <= 4.0; i++) {
        float weight = exp(-(i*i) / (2.0 * 2.0)); // sigma ~ 2.0 static for shape, radius controlled by u_dir stride
        // adjust stride by radius
        vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad);
        color += s * weight;
        total += weight;
    }
    outColor = color / total;
}
</script>

<script type="x-shader/x-fragment" id="fs-composite">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; // noise strength (0-150 mapped to 0-1)
uniform int u_nType; // Noise Type
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; // bool
uniform float u_ignAstr;

// Helper: Overlay
float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

vec3 rgb2hsl(vec3 c){
    float cmin = min(c.r, min(c.g, c.b));
    float cmax = max(c.r, max(c.g, c.b));
    float d = cmax - cmin;
    float l = (cmax + cmin) / 2.0;
    float s = l > 0.5 ? d / (2.0 - cmax - cmin) : d / (cmax + cmin);
    if (cmax == cmin) s = 0.0;
    // Hue not needed for saturation adjust only
    return vec3(0.0, s, l); // We cheat, only returning S and L correctly
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); // R=Combined mask intensity (0..1)
    
    // Calculate noise intensity
    // Normalize noise 0..1 to -1..1 centered, then scale by strength
    vec3 n = nc.rgb;
    
    // Blend Mode Logic
    vec3 res;
    vec3 base = bc.rgb;
    
    // 1. Prepare Noise Layer
    // For Blend Mode (Type 2), we ignore the noise texture color and use it as a sat map
    if (u_nType == 2) {
        // Saturation Blend
        // Use Red channel of noise as driver
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        
        float lum = dot(base, vec3(0.299,0.587,0.114));
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * (u_str/50.0)); // simple saturation mod
        res = satColor;
        // In this mode, we replace base, we don't overlay
    } else {
        // Standard Mixing
        // Remap noise 0..1 to effective range based on Strength
        // Basic idea: blend noise onto 0.5 grey, then blend that onto image
        // Better: Apply blending math directly
        
        vec3 noiseLayer = nc.rgb;
        
        // Mode switch
        if (u_mode == 0) { // Normal
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { // Overlay
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { // Screen
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { // Multiply
            res = base * noiseLayer;
        } else if (u_mode == 4) { // Add
            res = base + noiseLayer;
        } else if (u_mode == 5) { // Diff
            res = abs(base - noiseLayer);
        }
        
        // Interpolate between Base and BlendedResult based on Opacity * Mask * Strength
        float maskVal = mc.r; // Combined mask
        
        // If ignore alpha is on, reduce mask where alpha is low
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); // normalize strength a bit
        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}
</script>

<script type="x-shader/x-fragment" id="fs-chroma">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;

void main() {
    if (u_amt <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    // Cubic falloff for nicer edge effect
    float str = dist * dist * (u_amt / 1000.0); // scale down UI value
    
    vec4 result = vec4(0.0);
    
    if (u_blur > 0.0) {
        // Multi-tap blur for the chromatic aberration
        float totalWeight = 0.0;
        // 5 samples
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * u_blur * 0.002; // scalar for blur spread
            float w = exp(-(i*i)/2.0); // gaussian weight
            
            // Sample with offset + blur offset
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t)).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5)).g; // Green slightly affected or just anchor
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t)).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        // Single tap
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}
</script>


<script>
/**
 * DIGITAL GRAIN STUDIO - WEBGL2 PIPELINE
 * Single-file implementation
 */

// --- GLOBAL STATE ---
const state = {
    gl: null,
    canvas: null,
    programs: {},
    textures: {},
    fbos: {},
    thumbnailFBO: null, // Small FBO for layer previews
    baseImage: null,
    width: 1,
    height: 1,
    fboWidth: 0, 
    fboHeight: 0,
    busy: false
};

const UI = {}; // Handles DOM refs

// --- INIT ---
window.addEventListener('DOMContentLoaded', async () => {
    // 1. DOM refs
    const ids = [
        'imageUpload', 'displayCanvas', 'overlayCanvas', 'overlayOriginal',
        'strength', 'noiseType', 'satStrength', 'satPerNoise',
        'noiseSize', 'blurriness', 'blendMode', 'opacity',
        'enableShadows', 'shadowThreshold', 'shadowFade',
        'enableHighlights', 'highlightThreshold', 'highlightFade',
        'brightness', 'contrast', 'saturationAdj',
        'hdrTolerance', 'hdrAmount',
        'ignoreAlphaToggle', 'ignoreAlphaStrength',
        'aberrationAmount', 'aberrationBlur', 'centerX', 'centerY',
        'downloadBtn', 'compareBtn', 'loading',
        'layerGrid', 'compareOriginal', 'compareProcessed', 'closeCompare',
        'exportSideBySide', 'exportStacked'
    ];
    ids.forEach(id => UI[id] = document.getElementById(id));

    // 2. Setup Controls Sync (Slider + Text input)
    document.querySelectorAll('input[type=range]').forEach(range => {
        const text = range.nextElementSibling;
        if(text && text.classList.contains('control-value')) {
            const update = () => text.value = range.value;
            range.addEventListener('input', () => { update(); requestRender(); });
            update();
        }
    });

    document.querySelectorAll('select, input[type=checkbox]').forEach(el => {
        el.addEventListener('change', requestRender);
    });

    // 3. GL Init
    initWebGL();

    // 4. Image Loader
    UI.imageUpload.addEventListener('change', e => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
            const img = new Image();
            img.onload = () => loadNewImage(img);
            img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
    });

    // 5. Buttons
    UI.downloadBtn.addEventListener('click', downloadFullRes);
    UI.compareBtn.addEventListener('click', openCompare);
    UI.closeCompare.addEventListener('click', () => document.getElementById('compareModal').classList.remove('show'));
    UI.exportSideBySide.addEventListener('click', () => exportComparison('side'));
    UI.exportStacked.addEventListener('click', () => exportComparison('stack'));

    // 6. Overlay interaction
    const pContainer = document.getElementById('previewContainer');
    pContainer.addEventListener('mouseenter', () => UI.overlayOriginal.classList.add('show'));
    pContainer.addEventListener('mouseleave', () => UI.overlayOriginal.classList.remove('show'));
});

// --- RENDER LOOP MANAGER ---
let renderRequested = false;
function requestRender() {
    if(!renderRequested && state.baseImage) {
        renderRequested = true;
        requestAnimationFrame(() => {
            renderFrame();
            renderRequested = false;
        });
    }
}

// --- WEBGL CORE ---
function initWebGL() {
    state.canvas = UI.displayCanvas;
    // Prefer WebGL2
    const gl = state.canvas.getContext('webgl2', { antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: true });
    if (!gl) { alert('WebGL2 not supported. Please use a modern browser.'); return; }
    
    // Extensions
    gl.getExtension('EXT_color_buffer_float');
    gl.getExtension('OES_texture_float_linear');

    state.gl = gl;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    // Compile Shaders
    state.programs = {
        adjust: createProgram(gl, 'vs-quad', 'fs-adjust'),
        mask: createProgram(gl, 'vs-quad', 'fs-mask'),
        noise: createProgram(gl, 'vs-quad', 'fs-noise'),
        blur: createProgram(gl, 'vs-quad', 'fs-blur'),
        composite: createProgram(gl, 'vs-quad', 'fs-composite'),
        chroma: createProgram(gl, 'vs-quad', 'fs-chroma'),
        copy: createProgram(gl, 'vs-quad', 'fs-chroma') // reuse chroma with 0 amt for copy
    };

    // Quad Buffer
    const quadVBO = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // pos(x,y) uv(x,y)
        -1, -1, 0, 0,
         1, -1, 1, 0,
        -1,  1, 0, 1,
        -1,  1, 0, 1,
         1, -1, 1, 0,
         1,  1, 1, 1
    ]), gl.STATIC_DRAW);

    // Set Attributes for all programs (assuming same layout)
    Object.values(state.programs).forEach(p => {
        gl.useProgram(p);
        const posLoc = gl.getAttribLocation(p, 'a_pos');
        const uvLoc = gl.getAttribLocation(p, 'a_uv');
        gl.enableVertexAttribArray(posLoc);
        gl.enableVertexAttribArray(uvLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
        gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);
    });

    // Create thumbnail FBO for layer previews (small size)
    const tw = 320, th = 180;
    const tTex = createTexture(gl, null, tw, th);
    const tFbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, tFbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tTex, 0);
    state.thumbnailFBO = { fbo: tFbo, tex: tTex, w: tw, h: th };
}

function loadNewImage(img) {
    state.baseImage = img;
    state.width = img.width;
    state.height = img.height;
    
    // Create Base Texture
    const gl = state.gl;
    if(state.textures.base) gl.deleteTexture(state.textures.base);
    state.textures.base = createTexture(gl, img); // Load image

    // Reset FBO state check
    state.fboWidth = 0;
    
    // Alloc FBOs (initial)
    reallocateBuffers(false);
    
    // Enable Buttons
    UI.downloadBtn.disabled = false;
    UI.compareBtn.disabled = false;
    
    // Set overlay
    UI.overlayCanvas.width = img.width;
    UI.overlayCanvas.height = img.height;
    UI.overlayCanvas.getContext('2d').drawImage(img, 0, 0);
    
    // Setup Layer Grid DOM
    setupLayerGridDOM();

    requestRender();
}

function reallocateBuffers(fullRes = false) {
    const gl = state.gl;
    
    // Determine preview size
    // For large images, we cap preview size to ensure 60fps
    // Max 2048px width or height
    let w, h;
    
    if (fullRes) {
        w = state.width;
        h = state.height;
    } else {
        const maxDim = 2048;
        let scale = 1.0;
        if (state.width > maxDim || state.height > maxDim) {
            scale = Math.min(maxDim / state.width, maxDim / state.height);
        }
        w = Math.round(state.width * scale);
        h = Math.round(state.height * scale);
    }
    
    // Avoid redundant reallocation
    if (state.fboWidth === w && state.fboHeight === h) {
        return { w, h };
    }
    
    state.fboWidth = w;
    state.fboHeight = h;
    
    // Clean old
    ['adjust', 'mask', 'noise', 'blur1', 'blur2', 'comp'].forEach(k => {
        if(state.textures[k]) gl.deleteTexture(state.textures[k]);
        if(state.fbos[k]) gl.deleteFramebuffer(state.fbos[k]);
    });

    // Helper
    const makeFBO = () => {
        const tex = createTexture(gl, null, w, h);
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        return { tex, fbo };
    };

    const adj = makeFBO();
    state.textures.adjust = adj.tex; state.fbos.adjust = adj.fbo;

    const msk = makeFBO();
    state.textures.mask = msk.tex; state.fbos.mask = msk.fbo;

    const nse = makeFBO();
    state.textures.noise = nse.tex; state.fbos.noise = nse.fbo;

    const b1 = makeFBO();
    state.textures.blur1 = b1.tex; state.fbos.blur1 = b1.fbo;

    const b2 = makeFBO();
    state.textures.blur2 = b2.tex; state.fbos.blur2 = b2.fbo;

    const cmp = makeFBO();
    state.textures.comp = cmp.tex; state.fbos.comp = cmp.fbo;
    
    return { w, h };
}

// --- PIPELINE EXECUTION ---
function renderFrame(isExport = false) {
    if(!state.baseImage) return;
    const gl = state.gl;
    
    // Ensure buffers are correct size
    const size = reallocateBuffers(isExport);
    const w = size.w;
    const h = size.h;
    
    gl.viewport(0, 0, w, h);

    // --- PASS 1: ADJUST ---
    gl.useProgram(state.programs.adjust);
    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.adjust);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, state.textures.base);
    gl.uniform1i(gl.getUniformLocation(state.programs.adjust, 'u_tex'), 0);
    gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_bright'), parseFloat(UI.brightness.value));
    gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_cont'), parseFloat(UI.contrast.value));
    gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_sat'), parseFloat(UI.saturationAdj.value)/100.0);
    gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_hdrTol'), parseFloat(UI.hdrTolerance.value));
    gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_hdrAmt'), parseFloat(UI.hdrAmount.value));
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- PASS 2: MASK ---
    gl.useProgram(state.programs.mask);
    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.mask);
    gl.bindTexture(gl.TEXTURE_2D, state.textures.adjust); // Mask based on adjusted
    gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
    gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), UI.enableShadows.checked ? 1:0);
    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.shadowThreshold.value));
    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.shadowFade.value));
    gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), UI.enableHighlights.checked ? 1:0);
    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.highlightThreshold.value));
    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.highlightFade.value));
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- PASS 3: NOISE ---
    gl.useProgram(state.programs.noise);
    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.noise);
    gl.uniform1i(gl.getUniformLocation(state.programs.noise, 'u_type'), parseInt(UI.noiseType.value));
    gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_seed'), Math.random() * 100.0); 
    gl.uniform2f(gl.getUniformLocation(state.programs.noise, 'u_res'), w, h);
    // Crucial fix: Pass Original Dimensions so scale is consistent
    gl.uniform2f(gl.getUniformLocation(state.programs.noise, 'u_origRes'), state.width, state.height);
    gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_scale'), parseFloat(UI.noiseSize.value));
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- PASS 4: BLUR (Separable) ---
    const blurAmt = parseFloat(UI.blurriness.value) / 100.0;
    if(blurAmt > 0) {
        gl.useProgram(state.programs.blur);
        // Horizontal
        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
        gl.bindTexture(gl.TEXTURE_2D, state.textures.noise);
        gl.uniform1i(gl.getUniformLocation(state.programs.blur, 'u_tex'), 0);
        gl.uniform2f(gl.getUniformLocation(state.programs.blur, 'u_dir'), 1.0/w, 0.0);
        gl.uniform1f(gl.getUniformLocation(state.programs.blur, 'u_rad'), blurAmt * 2.0); // scalar
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        
        // Vertical
        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
        gl.bindTexture(gl.TEXTURE_2D, state.textures.blur1); // input from previous
        gl.uniform2f(gl.getUniformLocation(state.programs.blur, 'u_dir'), 0.0, 1.0/h);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    const noiseTex = blurAmt > 0 ? state.textures.blur2 : state.textures.noise;

    // --- PASS 5: COMPOSITE ---
    gl.useProgram(state.programs.composite);
    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.comp);
    
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.adjust);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, noiseTex);
    gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, state.textures.mask);
    
    const locs = {
        base: gl.getUniformLocation(state.programs.composite, 'u_base'),
        noise: gl.getUniformLocation(state.programs.composite, 'u_noise'),
        mask: gl.getUniformLocation(state.programs.composite, 'u_mask'),
        mode: gl.getUniformLocation(state.programs.composite, 'u_mode'),
        op: gl.getUniformLocation(state.programs.composite, 'u_opacity'),
        str: gl.getUniformLocation(state.programs.composite, 'u_str'),
        nType: gl.getUniformLocation(state.programs.composite, 'u_nType'),
        satStr: gl.getUniformLocation(state.programs.composite, 'u_satStr'),
        satImp: gl.getUniformLocation(state.programs.composite, 'u_satImp'),
        ignA: gl.getUniformLocation(state.programs.composite, 'u_ignA'),
        ignAstr: gl.getUniformLocation(state.programs.composite, 'u_ignAstr')
    };
    gl.uniform1i(locs.base, 0);
    gl.uniform1i(locs.noise, 1);
    gl.uniform1i(locs.mask, 2);
    gl.uniform1i(locs.mode, parseInt(UI.blendMode.value));
    gl.uniform1f(locs.op, parseFloat(UI.opacity.value));
    gl.uniform1f(locs.str, parseFloat(UI.strength.value));
    gl.uniform1i(locs.nType, parseInt(UI.noiseType.value));
    gl.uniform1f(locs.satStr, parseFloat(UI.satStrength.value));
    gl.uniform1f(locs.satImp, parseFloat(UI.satPerNoise.value));
    gl.uniform1i(locs.ignA, UI.ignoreAlphaToggle.checked ? 1:0);
    gl.uniform1f(locs.ignAstr, parseFloat(UI.ignoreAlphaStrength.value));
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- PASS 6: CHROMATIC ABERRATION (TO SCREEN) ---
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    
    // Set canvas drawing buffer size to match FBO size
    if (gl.canvas.width !== w || gl.canvas.height !== h) {
        gl.canvas.width = w;
        gl.canvas.height = h;
    }
    gl.viewport(0, 0, w, h);
    
    gl.useProgram(state.programs.chroma);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, state.textures.comp);
    gl.uniform1i(gl.getUniformLocation(state.programs.chroma, 'u_tex'), 0);
    
    // EXPONENTIAL MAP for Amount: slider (0-300) -> 0..1 then squared
    // This gives finer control at low values
    const abRaw = parseFloat(UI.aberrationAmount.value);
    const abMax = parseFloat(UI.aberrationAmount.max);
    const abNorm = abRaw / abMax;
    const abVal = (abNorm * abNorm) * abMax; // simple square curve
    
    gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_amt'), abVal);
    
    // EXPONENTIAL MAP for Blur
    const blRaw = parseFloat(UI.aberrationBlur.value);
    const blVal = (blRaw / 100.0) * (blRaw / 100.0) * 100.0;
    gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_blur'), blVal);
    
    gl.uniform2f(gl.getUniformLocation(state.programs.chroma, 'u_center'), parseFloat(UI.centerX.value), parseFloat(UI.centerY.value));
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- EXPORT HANDLING ---
    if(isExport) {
        // Just return, caller handles readback
    } else {
        updateLayerPreviews(noiseTex);
    }
}


// --- UTILS: WEBGL HELPERS ---

function createShader(gl, type, srcId) {
    const src = document.getElementById(srcId).text.trim();
    const shader = gl.createShader(type == 'vs-quad' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function createProgram(gl, vsId, fsId) {
    const vs = createShader(gl, 'vs-quad', vsId);
    const fs = createShader(gl, 'fs-fragment', fsId);
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    return p;
}

function createTexture(gl, img, w, h) {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    
    if(img) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    } else {
        // Empty texture for FBO
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    return tex;
}

// --- UTILS: EXPORT & UI ---

async function downloadFullRes() {
    UI.loading.style.display = 'block';
    await new Promise(r => setTimeout(r, 50));
    renderFrame(true);
    const link = document.createElement('a');
    link.download = 'grain-export.png';
    link.href = state.canvas.toDataURL('image/png', 1.0);
    link.click();
    reallocateBuffers(false);
    requestRender();
    UI.loading.style.display = 'none';
}

async function openCompare() {
    UI.loading.style.display = 'block';
    await new Promise(r => setTimeout(r, 50));
    
    renderFrame(true);
    
    const original = document.getElementById('compareOriginal');
    const processed = document.getElementById('compareProcessed');
    
    // Resize compare canvases
    const aspect = state.width / state.height;
    original.width = 600; original.height = 600 / aspect;
    processed.width = 600; processed.height = 600 / aspect;
    
    const ctxO = original.getContext('2d');
    const ctxP = processed.getContext('2d');
    
    ctxO.drawImage(state.baseImage, 0, 0, original.width, original.height);
    ctxP.drawImage(state.canvas, 0, 0, processed.width, processed.height);
    
    document.getElementById('compareModal').classList.add('show');
    
    reallocateBuffers(false);
    requestRender();
    UI.loading.style.display = 'none';
}

// Export logic for side-by-side or stacked
async function exportComparison(mode) {
    UI.loading.style.display = 'block';
    await new Promise(r => setTimeout(r, 50));
    
    // 1. Render Full Res Processed
    renderFrame(true);
    const processedData = state.canvas.toDataURL();
    const processedImg = new Image();
    processedImg.src = processedData;
    await new Promise(r => processedImg.onload = r);

    // 2. Create export canvas
    const exp = document.createElement('canvas');
    const w = state.width;
    const h = state.height;
    
    if (mode === 'side') {
        exp.width = w * 2;
        exp.height = h;
        const ctx = exp.getContext('2d');
        ctx.drawImage(state.baseImage, 0, 0);
        ctx.drawImage(processedImg, w, 0);
    } else {
        exp.width = w;
        exp.height = h * 2;
        const ctx = exp.getContext('2d');
        ctx.drawImage(state.baseImage, 0, 0);
        ctx.drawImage(processedImg, 0, h);
    }
    
    const link = document.createElement('a');
    link.download = `grain-compare-${mode}.png`;
    link.href = exp.toDataURL('image/png', 0.9);
    link.click();

    reallocateBuffers(false);
    requestRender();
    UI.loading.style.display = 'none';
}

function setupLayerGridDOM() {
    const grid = UI.layerGrid;
    grid.innerHTML = '';
    const layers = ['Adjusted', 'Noise', 'Masks', 'Composite'];
    layers.forEach(l => {
        const d = document.createElement('div');
        d.className = 'layer-item';
        d.innerHTML = `<div class="layer-title">${l}</div><canvas class="layer-canvas" id="thumb-${l}" width="320" height="180"></canvas>`;
        grid.appendChild(d);
    });
}

function updateLayerPreviews(noiseTex) {
    const gl = state.gl;
    if(!state.thumbnailFBO) return;
    
    // Map names to textures
    const map = {
        'Adjusted': state.textures.adjust,
        'Noise': noiseTex,
        'Masks': state.textures.mask,
        'Composite': state.textures.comp
    };
    
    // Prepare small FBO
    gl.bindFramebuffer(gl.FRAMEBUFFER, state.thumbnailFBO.fbo);
    gl.viewport(0, 0, state.thumbnailFBO.w, state.thumbnailFBO.h);
    
    // Reuse chroma shader (with 0 amt) as a simple texture copy
    gl.useProgram(state.programs.copy);
    gl.uniform1f(gl.getUniformLocation(state.programs.copy, 'u_amt'), 0.0);
    
    const pixels = new Uint8Array(state.thumbnailFBO.w * state.thumbnailFBO.h * 4);
    
    Object.keys(map).forEach(key => {
        const tex = map[key];
        const canvas = document.getElementById(`thumb-${key}`);
        if(!canvas || !tex) return;
        
        // Draw texture to FBO
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        
        // Read pixels
        gl.readPixels(0, 0, state.thumbnailFBO.w, state.thumbnailFBO.h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        
        // Put on 2D canvas
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(state.thumbnailFBO.w, state.thumbnailFBO.h);
        
        // WebGL reads pixels bottom-up, need to flip Y
        // Manual flip
        const w = state.thumbnailFBO.w;
        const h = state.thumbnailFBO.h;
        for(let y=0; y<h; y++) {
            const srcY = h - 1 - y;
            const srcOff = srcY * w * 4;
            const dstOff = y * w * 4;
            imgData.data.set(pixels.subarray(srcOff, srcOff + w*4), dstOff);
        }
        
        ctx.putImageData(imgData, 0, 0);
    });
}

</script>
</body>
</html>