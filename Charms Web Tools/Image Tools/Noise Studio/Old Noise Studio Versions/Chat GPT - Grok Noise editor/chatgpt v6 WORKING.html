<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Digital Grain Studio — Updated</title>
<style>
:root{
  --bg:#000; --fg:#fff; --panel-max:460px; --muted:#8c8c8c; --accent:#2a9df4;
}
*{box-sizing:border-box}
html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:monospace}
body{padding:16px; display:flex; gap:16px; align-items:flex-start; min-height:100vh}
.container{display:flex; gap:16px; width:100%}
/* Left control column */
.controls-panel{flex:0 0 var(--panel-max); max-width:var(--panel-max); min-width:260px; padding:10px; border-right:1px solid rgba(255,255,255,0.04)}
.controls-panel h1{font-size:18px; margin:0 0 8px 0; text-align:center}
.muted{color:var(--muted); font-size:13px}
details{border:1px solid rgba(255,255,255,0.06); margin-bottom:10px; padding:6px; border-radius:6px; background:transparent}
summary{cursor:pointer; font-weight:bold; margin:0 0 6px 0; outline:none}
.control-row{display:flex; gap:8px; align-items:center; margin-bottom:8px; min-height:32px}
.control-row label{flex:0 0 130px; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
input[type=range]{flex:1}
.control-value{width:86px; padding:4px; text-align:right; background:transparent; color:var(--fg); border:1px solid rgba(255,255,255,0.06); font-family:monospace}
select.control-value{flex:1; min-width:120px; padding:4px}
.row-buttons{display:flex; gap:8px; margin-top:8px}
button{background:transparent; color:var(--fg); border:1px solid rgba(255,255,255,0.08); padding:8px; cursor:pointer}
button:hover{background:rgba(255,255,255,0.02)}

/* Right preview column */
.preview-column{flex:1 1 auto; min-width:320px; display:flex; flex-direction:column; gap:12px}
.preview-top{display:flex; align-items:center; justify-content:space-between; gap:12px}
.preview-container{position:relative; border:1px solid rgba(255,255,255,0.06); background:#070707; overflow:visible; padding:8px; display:flex; align-items:center; justify-content:center}
.main-canvas-wrap{width:100%; display:flex; align-items:center; justify-content:center;}

/* displayCanvas will get style.width set by script to control fitting and aspect */
#displayCanvas{ display:block; border-radius:2px; background:transparent; }

/* overlay original: absolutely positioned on top of the canvas but not allowed to change layout */
.overlay-original{ position:absolute; top:8px; left:8px; right:8px; bottom:8px; display:flex; align-items:center; justify-content:center; pointer-events:none;}
.overlay-original canvas{ width:100%; height:auto; display:block; opacity:0; transition:opacity 180ms ease }
/* toggle show class to reveal original overlay */
.overlay-original.show canvas{ opacity:1 }

/* Layer preview window: single container with grid inside */
.layer-preview-window{ border:1px solid rgba(255,255,255,0.06); background:#050505; padding:10px; overflow:auto; width:100%;}
.layer-grid{ display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); align-items:start }
/* layer item */
.layer-item{ border:1px solid rgba(255,255,255,0.03); padding:8px; border-radius:6px; display:flex; flex-direction:column; gap:8px; background:transparent}
.layer-title-row{display:flex; align-items:center; justify-content:space-between}
.layer-title{ color:var(--muted); font-size:13px; margin:0}
.layer-canvas{ width:100%; height:auto; border:1px solid rgba(255,255,255,0.03); background:#0a0a0a; display:block }

/* modal */
.modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; opacity:0; pointer-events:none; transition:opacity 200ms ease; z-index:3000}
.modal-overlay.show{ opacity:1; pointer-events:auto}
.modal{ background:#111; border:1px solid rgba(255,255,255,0.06); border-radius:8px; padding:12px; max-width:92vw; width:880px; max-height:90vh; overflow:auto}

/* small responsive */
@media (max-width:900px){ body{padding:10px} .controls-panel{order:2; width:100%} .preview-column{order:1; width:100%} .control-row label{flex:0 0 110px} }
</style>
</head>
<body>
  <div class="container">
    <div class="controls-panel">
      <h1>Digital Grain Studio</h1>
      <p class="muted">Sections collapsed by default except a few expanded ones per your request.</p>

      <div style="margin:10px 0">
        <label style="font-weight:bold; display:block; margin-bottom:6px;">Image Upload</label>
        <input id="imageUpload" type="file" accept="image/*" style="width:100%; padding:8px; box-sizing:border-box;">
      </div>

      <!-- Noise Basics expanded by default -->
      <details open>
        <summary>Noise Basics</summary>
        <div class="control-row">
          <label for="strength">Noise Strength (σ)</label>
          <input id="strength" type="range" min="0" max="150" step="0.01" value="50">
        </div>
        <div class="control-row">
          <label for="noiseType">Noise Type</label>
          <select id="noiseType" class="control-value">
            <option value="color">Color</option>
            <option value="grayscale" selected>Grayscale</option>
            <option value="blend">Blend (saturation)</option>
          </select>
        </div>
        <div class="control-row" id="satControls" style="display:flex">
          <label for="satStrength">Sat Change</label>
          <input id="satStrength" type="range" min="0" max="4" step="0.01" value="1">
        </div>
        <div class="control-row" id="satPerNoiseRow" style="display:flex">
          <label for="satPerNoise">Noise Sat Impact</label>
          <input id="satPerNoise" type="range" min="-100" max="100" step="0.1" value="0">
        </div>
      </details>

      <!-- Noise Shape & Blur expanded by default -->
      <details open>
        <summary>Noise Shape & Blur</summary>
        <div class="control-row">
          <label for="noiseSize">Noise Size</label>
          <input id="noiseSize" type="range" min="0" max="1000" step="0.01" value="4">
        </div>
        <div class="control-row">
          <label for="blurriness">Blurriness</label>
          <input id="blurriness" type="range" min="0" max="1000" step="0.01" value="160">
        </div>
      </details>

      <details>
        <summary>Noise Masking</summary>
        <div class="control-row">
          <label for="enableShadows">Noise in Shadows</label>
          <input id="enableShadows" type="checkbox" style="transform:scale(1.15)">
        </div>
        <div class="control-row">
          <label for="shadowThreshold">Shadow Threshold</label>
          <input id="shadowThreshold" type="range" min="0" max="1" step="0.0001" value="0.3">
        </div>
        <div class="control-row">
          <label for="shadowFade">Shadow Fade</label>
          <input id="shadowFade" type="range" min="0" max="1" step="0.0001" value="0.2">
        </div>

        <div style="height:6px;"></div>

        <div class="control-row">
          <label for="enableHighlights">Noise in Highlights</label>
          <input id="enableHighlights" type="checkbox" style="transform:scale(1.15)">
        </div>
        <div class="control-row">
          <label for="highlightThreshold">Highlight Threshold</label>
          <input id="highlightThreshold" type="range" min="0" max="1" step="0.0001" value="0.7">
        </div>
        <div class="control-row">
          <label for="highlightFade">Highlight Fade</label>
          <input id="highlightFade" type="range" min="0" max="1" step="0.0001" value="0.2">
        </div>
      </details>

      <!-- Blend & Visibility expanded by default -->
      <details open>
        <summary>Blend & Visibility</summary>
        <div class="control-row">
          <label for="blendMode">Blend Mode</label>
          <select id="blendMode" class="control-value">
            <option value="source-over">Normal</option>
            <option value="overlay" selected>Overlay</option>
            <option value="screen">Screen</option>
            <option value="multiply">Multiply</option>
            <option value="lighter">Add</option>
            <option value="difference">Subtract</option>
          </select>
        </div>
        <div class="control-row">
          <label for="opacity">Noise Opacity</label>
          <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.25">
        </div>
      </details>

      <details>
        <summary>Image Adjustments</summary>
        <div class="control-row">
          <label for="brightness">Brightness</label>
          <input id="brightness" type="range" min="-100" max="100" step="1" value="0">
        </div>
        <div class="control-row">
          <label for="contrast">Contrast</label>
          <input id="contrast" type="range" min="-300" max="300" step="1" value="100">
        </div>
        <div class="control-row">
          <label for="saturationAdj">Saturation</label>
          <input id="saturationAdj" type="range" min="-100" max="100" step="0.1" value="0">
        </div>
      </details>

      <details>
        <summary>HDR Emulation</summary>
        <div class="control-row">
          <label for="hdrTolerance">Tolerance</label>
          <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35">
        </div>
        <div class="control-row">
          <label for="hdrAmount">Amount (%)</label>
          <input id="hdrAmount" type="range" min="0" max="100" step="1" value="20">
        </div>
      </details>

      <details>
        <summary>Transparent Pixels</summary>
        <div class="control-row">
          <label for="ignoreAlphaToggle">Ignore Transparent Areas</label>
          <input id="ignoreAlphaToggle" type="checkbox" style="transform:scale(1.15)">
        </div>
        <div class="control-row">
          <label for="ignoreAlphaStrength">Ignore Strength</label>
          <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100">
        </div>
      </details>

      <div style="display:flex; gap:8px; margin-top:8px;">
        <button id="realtimeToggle">Realtime: ON</button>
        <button id="applyBtn" title="Apply changes when realtime is OFF">Apply Changes</button>
      </div>

      <div class="row-buttons" style="margin-top:10px">
        <button id="helpBtn">Help / Manual</button>
        <button id="compareBtn">Compare</button>
        <button id="downloadImage" disabled>Download Image</button>
      </div>
    </div>

    <div class="preview-column">
      <div class="preview-top">
        <h3 style="margin:0">Main Preview (hover to reveal original)</h3>
        <div class="muted">Main preview fills available area and keeps aspect ratio. Wheel scrolling no longer changes blend.</div>
      </div>

      <div id="previewArea" class="preview-container" style="min-height:160px;">
        <div class="main-canvas-wrap" id="canvasWrap" style="width:100%; padding:8px 0;">
          <!-- display canvas; script controls CSS width/height to fit viewport with aspect preserved -->
          <canvas id="displayCanvas"></canvas>
        </div>
        <div class="overlay-original" id="overlayOriginal">
          <canvas id="overlayCanvas"></canvas>
        </div>
      </div>

      <div class="preview-top">
        <h3 style="margin:0">Layers & Mask Preview</h3>
        <div class="muted">All layers live inside this single window below the main preview</div>
      </div>

      <!-- single layer preview window, fixed max height (viewport height) and internal grid -->
      <div id="layerPreviewWindow" class="layer-preview-window" style="max-height:60vh">
        <div id="layerGrid" class="layer-grid"></div>
      </div>

    </div>
  </div>

  <!-- Compare modal -->
  <div id="compareModal" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="compareTitle">
      <h2 id="compareTitle">Compare — Original vs Edited</h2>
      <div style="display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap;">
        <canvas id="compareOriginal" style="border:1px solid #333; background:#000"></canvas>
        <canvas id="compareEdited" style="border:1px solid #333; background:#000"></canvas>
      </div>
      <div style="display:flex; gap:8px; justify-content:center; margin-top:12px">
        <button id="exportSideBySide">Export Side-by-Side</button>
        <button id="exportStacked">Export Stacked</button>
        <button id="closeCompare">Close</button>
      </div>
    </div>
  </div>

<script>
/* -------------------------
   Elements & state
   ------------------------- */
const fileInput = document.getElementById('imageUpload');
const displayCanvas = document.getElementById('displayCanvas');
const overlayCanvas = document.getElementById('overlayCanvas');
const overlayWrap = document.getElementById('overlayOriginal');

const strengthRange = document.getElementById('strength');
const noiseTypeSelect = document.getElementById('noiseType');
const satStrength = document.getElementById('satStrength');
const satPerNoise = document.getElementById('satPerNoise');

const noiseSizeRange = document.getElementById('noiseSize');
const blurrinessRange = document.getElementById('blurriness');

const enableShadows = document.getElementById('enableShadows');
const shadowThreshold = document.getElementById('shadowThreshold');
const shadowFade = document.getElementById('shadowFade');

const enableHighlights = document.getElementById('enableHighlights');
const highlightThreshold = document.getElementById('highlightThreshold');
const highlightFade = document.getElementById('highlightFade');

const blendModeSelect = document.getElementById('blendMode');
const opacityRange = document.getElementById('opacity');

const brightnessRange = document.getElementById('brightness');
const contrastRange = document.getElementById('contrast');
const saturationAdjRange = document.getElementById('saturationAdj');

const hdrTolerance = document.getElementById('hdrTolerance');
const hdrAmount = document.getElementById('hdrAmount');

const ignoreAlphaToggle = document.getElementById('ignoreAlphaToggle');
const ignoreAlphaStrength = document.getElementById('ignoreAlphaStrength');

const layerGrid = document.getElementById('layerGrid');
const layerPreviewWindow = document.getElementById('layerPreviewWindow');

const realtimeToggle = document.getElementById('realtimeToggle');
const applyBtn = document.getElementById('applyBtn');
const helpBtn = document.getElementById('helpBtn');
const compareBtn = document.getElementById('compareBtn');
const downloadBtn = document.getElementById('downloadImage');

const compareModal = document.getElementById('compareModal');
const compareOriginal = document.getElementById('compareOriginal');
const compareEdited = document.getElementById('compareEdited');
const exportSideBySideBtn = document.getElementById('exportSideBySide');
const exportStackedBtn = document.getElementById('exportStacked');
const closeCompareBtn = document.getElementById('closeCompare');

let baseImageCanvas = null;      // full-resolution original
let adjustedImageData = null;    // ImageData after adjustments
let lastNoiseCanvas = null;      // full-resolution noise canvas
let lastMasks = {};              // {combined, shadows, highlights}
let previews = [];               // {name, canvas} list for grid

let originalImageLoaded = false;
let realtime = true; // realtime preview on by default

/* -------------------------
   Utilities
   ------------------------- */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function gaussianRandom(mean=0,std=1){
  let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v) * std + mean;
}
function rgbToHsl(r,g,b){
  const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2;
  if(max===min){h=s=0;} else {
    const d = max-min;
    s = l>0.5? d/(2-max-min) : d/(max+min);
    switch(max){case r: h=(g-b)/d + (g<b?6:0); break; case g: h=(b-r)/d + 2; break; default: h=(r-g)/d +4}
    h /= 6;
  }
  return {h,s,l};
}
function hslToRgb(h,s,l){
  let r,g,b;
  if(s===0) r=g=b=l; else {
    const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p;};
    const q = l<0.5? l*(1+s) : l + s - l*s; const p = 2*l - q;
    r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);
  }
  return {r,g,b};
}
function smoothstep(min,max,value){
  if(min>max) [min,max]=[max,min];
  const x = Math.max(0, Math.min(1, (value-min)/(max-min)));
  return x*x*(3-2*x);
}
/* slider mapping */
const MAX_NOISE_SIZE = 200.0; const MAX_BLUR = 5.0; const SLIDER_MAX = 1000.0; const ZOOM_EXPONENT = 3.0;
function noiseSizeFromSlider(s){ const t = Math.pow(s/SLIDER_MAX, ZOOM_EXPONENT); return 1.0 + (MAX_NOISE_SIZE-1.0)*t; }
function blurFromSlider(s){ const t = Math.pow(s/SLIDER_MAX, ZOOM_EXPONENT); return MAX_BLUR * t; }
function maskSliderToValue(s){ const v = Math.max(0, Math.min(1, Number(s))); return v*v; }

/* -------------------------
   Main display fit logic
   - if user hasn't scrolled (window.scrollY === 0) we scale the main preview so it fits between its top and the bottom of the viewport
   - otherwise we let it use full width (user may have scrolled intentionally)
   ------------------------- */
function fitMainPreview(){
  if (!originalImageLoaded) return;
  const w = baseImageCanvas.width, h = baseImageCanvas.height;
  const previewArea = document.getElementById('previewArea');
  const areaRect = previewArea.getBoundingClientRect();
  // compute available width and height for canvas inside preview area (minus padding ~16)
  const maxWidth = Math.max(100, areaRect.width - 24);
  // if user hasn't scrolled, constrain by viewport bottom
  const marginBottomIfNotScrolled = 24;
  let maxHeight;
  if (window.scrollY === 0) {
    const availableHeight = window.innerHeight - areaRect.top - marginBottomIfNotScrolled;
    maxHeight = Math.max(60, availableHeight - 16); // small padding
  } else {
    // allow more height (let it expand based on width)
    maxHeight = window.innerHeight * 0.9;
  }
  // choose scale to preserve aspect ratio
  const scale = Math.min(maxWidth / w, maxHeight / h);
  const cssWidth = Math.round(w * scale);
  const cssHeight = Math.round(h * scale);
  // set CSS size of display canvas and overlay to match
  displayCanvas.style.width = cssWidth + 'px';
  displayCanvas.style.height = cssHeight + 'px';
  overlayCanvas.style.width = cssWidth + 'px';
  overlayCanvas.style.height = cssHeight + 'px';
  // also set previewArea minHeight so border sits around canvas nicely
  previewArea.style.minHeight = (cssHeight + 24) + 'px';
}

/* -------------------------
   Apply adjustments (brightness/contrast/sat/HDR) -> adjustedImageData
   ------------------------- */
function applyAdjustmentsAndHDR(){
  if (!baseImageCanvas) return;
  const w = baseImageCanvas.width, h = baseImageCanvas.height;
  const ctx = baseImageCanvas.getContext('2d');
  const src = ctx.getImageData(0,0,w,h);
  const out = new ImageData(new Uint8ClampedArray(src.data), w, h);
  const d = out.data;
  const bright = parseFloat(brightnessRange.value) || 0;
  const cont = parseFloat(contrastRange.value) || 100;
  const sat = parseFloat(saturationAdjRange.value) || 0;
  const factor_cont = cont / 100;
  const factor_sat = 1 + sat / 100;
  const offset_bright = bright * 2.55;
  const tol = parseFloat(hdrTolerance.value) || 0.35;
  const amt = parseFloat(hdrAmount.value) || 0;
  for (let i=0;i<d.length;i+=4){
    let r = d[i], g = d[i+1], b = d[i+2];
    const lum = r*0.299 + g*0.587 + b*0.114;
    r = lum + (r - lum) * factor_sat;
    g = lum + (g - lum) * factor_sat;
    b = lum + (b - lum) * factor_sat;
    r = (r - 128) * factor_cont + 128;
    g = (g - 128) * factor_cont + 128;
    b = (b - 128) * factor_cont + 128;
    r += offset_bright; g += offset_bright; b += offset_bright;
    const nl = (0.299*r + 0.587*g + 0.114*b) / 255;
    if (nl < tol){
      const strength = (amt / 100) * (1 - nl / tol);
      r = r * (1 - strength); g = g * (1 - strength); b = b * (1 - strength);
    }
    d[i] = clamp(r,0,255); d[i+1] = clamp(g,0,255); d[i+2] = clamp(b,0,255);
  }
  adjustedImageData = out;
}

/* -------------------------
   Generate full-resolution noise canvas
   ------------------------- */
function generateNoiseFullCanvas(w,h,params){
  const { std, noiseType, blurSlider, noiseSlider, satStrengthVal, satPerNoiseVal, ignoreAlpha, ignoreAlphaStrength } = params;
  const blurPx = blurFromSlider(blurSlider);
  const noiseSize = noiseSizeFromSlider(noiseSlider);
  const smallW = Math.max(1, Math.round(w / noiseSize));
  const smallH = Math.max(1, Math.round(h / noiseSize));
  const smallCanvas = document.createElement('canvas'); smallCanvas.width = smallW; smallCanvas.height = smallH;
  const sCtx = smallCanvas.getContext('2d');
  const img = sCtx.createImageData(smallW, smallH);
  const sd = img.data;
  const isColor = noiseType === 'color';
  for (let y=0;y<smallH;y++){
    for (let x=0;x<smallW;x++){
      const i = (y*smallW + x)*4;
      let vr = 128 + gaussianRandom(0, std);
      let vg = 128 + gaussianRandom(0, std);
      let vb = 128 + gaussianRandom(0, std);
      if (!isColor) { vr = vg = vb; }
      sd[i]=clamp(vr,0,255); sd[i+1]=clamp(vg,0,255); sd[i+2]=clamp(vb,0,255); sd[i+3]=255;
    }
  }
  sCtx.putImageData(img,0,0);
  const nf = document.createElement('canvas'); nf.width = w; nf.height = h;
  const nfCtx = nf.getContext('2d'); nfCtx.imageSmoothingEnabled = true;
  if (blurPx>0){ nfCtx.filter = `blur(${blurPx}px)`; nfCtx.drawImage(smallCanvas,0,0,w,h); nfCtx.filter='none'; }
  else nfCtx.drawImage(smallCanvas,0,0,w,h);

  if (noiseType === 'blend'){
    const noiseMap = nfCtx.getImageData(0,0,w,h);
    const baseData = adjustedImageData ? adjustedImageData.data : baseImageCanvas.getContext('2d').getImageData(0,0,w,h).data;
    const out = nfCtx.createImageData(w,h);
    for (let i=0;i<out.data.length;i+=4){
      const v = noiseMap.data[i]/255;
      const centered = (v - 0.5) * 2;
      const combined = (parseFloat(satStrength.value)||1) * (1 + (parseFloat(satPerNoise.value)||0)/100);
      const delta = centered * combined;
      const r = baseData[i], g = baseData[i+1], b = baseData[i+2];
      const hsl = rgbToHsl(r/255,g/255,b/255);
      hsl.s = clamp(hsl.s + delta, 0, 2);
      const rgb = hslToRgb(hsl.h,hsl.s,hsl.l);
      out.data[i]=Math.round(rgb.r*255); out.data[i+1]=Math.round(rgb.g*255); out.data[i+2]=Math.round(rgb.b*255); out.data[i+3]=255;
    }
    nfCtx.putImageData(out,0,0);
  }

  // apply mask alpha for shadows/highlights and ignore alpha
  if (enableShadows.checked || enableHighlights.checked || ignoreAlpha){
    const nd = nfCtx.getImageData(0,0,w,h);
    const ndData = nd.data;
    const baseData = adjustedImageData ? adjustedImageData.data : baseImageCanvas.getContext('2d').getImageData(0,0,w,h).data;
    const sh_th = maskSliderToValue(parseFloat(shadowThreshold.value||0.3));
    const sh_f = maskSliderToValue(parseFloat(shadowFade.value||0.2));
    const hi_th = maskSliderToValue(parseFloat(highlightThreshold.value||0.7));
    const hi_f = maskSliderToValue(parseFloat(highlightFade.value||0.2));
    for (let i=0;i<ndData.length;i+=4){
      const r = baseData[i]/255, g = baseData[i+1]/255, b = baseData[i+2]/255;
      const lum = r*0.299 + g*0.587 + b*0.114;
      let sMask = 0, hMask = 0;
      if (enableShadows.checked){ const low = sh_th - sh_f/2, high = sh_th + sh_f/2; sMask = 1 - smoothstep(low, high, lum); }
      if (enableHighlights.checked){ const low = hi_th - hi_f/2, high = hi_th + hi_f/2; hMask = smoothstep(low, high, lum); }
      let tot = Math.max(sMask, hMask);
      if (ignoreAlpha && baseImageCanvas){
        const alpha = baseImageCanvas.getContext('2d').getImageData( (i/4)%w , Math.floor((i/4)/w), 1, 1).data[3] / 255 || 1;
        tot *= (1 - ignoreAlphaStrength * (1 - alpha));
      }
      ndData[i+3] = Math.round(255 * tot);
    }
    nfCtx.putImageData(nd,0,0);
  }

  return nf;
}

/* -------------------------
   Compose final composite, draw to display & overlay, build previews & masks
   ------------------------- */
function composeAndRender(){
  if (!originalImageLoaded) return;
  applyAdjustmentsAndHDR();
  const w = baseImageCanvas.width, h = baseImageCanvas.height;

  const params = {
    std: parseFloat(strengthRange.value)||0,
    noiseType: noiseTypeSelect.value,
    blurSlider: parseFloat(blurrinessRange.value)||0,
    noiseSlider: parseFloat(noiseSizeRange.value)||1,
    satStrengthVal: parseFloat(satStrength.value)||1,
    satPerNoiseVal: parseFloat(satPerNoise.value)||0,
    ignoreAlpha: ignoreAlphaToggle.checked,
    ignoreAlphaStrength: (parseFloat(ignoreAlphaStrength.value)||100)/100
  };

  lastNoiseCanvas = generateNoiseFullCanvas(w,h,params);

  // composite final
  const comp = document.createElement('canvas'); comp.width = w; comp.height = h;
  const cctx = comp.getContext('2d');
  cctx.putImageData(adjustedImageData,0,0);
  cctx.globalAlpha = parseFloat(opacityRange.value) || 1;
  cctx.globalCompositeOperation = blendModeSelect.value || 'source-over';
  cctx.drawImage(lastNoiseCanvas,0,0);
  cctx.globalAlpha = 1.0;
  cctx.globalCompositeOperation = 'source-over';

  // draw to displayCanvas pixel buffer
  displayCanvas.width = w; displayCanvas.height = h;
  const dctx = displayCanvas.getContext('2d'); dctx.clearRect(0,0,w,h);
  dctx.drawImage(comp,0,0);

  // overlay original
  overlayCanvas.width = w; overlayCanvas.height = h;
  const octx = overlayCanvas.getContext('2d'); octx.clearRect(0,0,w,h); octx.drawImage(baseImageCanvas,0,0);

  // build masks
  buildMasks(w,h);

  // build layer grid previews
  buildLayerGrid(comp, lastNoiseCanvas);

  // enable main download
  downloadBtn.disabled = false;

  // fit main preview to available space (if user hasn't scrolled)
  fitMainPreview();
}

/* -------------------------
   Build masks canvases (full-res)
   ------------------------- */
function buildMasks(w,h){
  const shadows = document.createElement('canvas'); shadows.width=w; shadows.height=h;
  const highlights = document.createElement('canvas'); highlights.width=w; highlights.height=h;
  const combined = document.createElement('canvas'); combined.width=w; combined.height=h;
  const sctx=shadows.getContext('2d'), hctx=highlights.getContext('2d'), cctx=combined.getContext('2d');
  const src = adjustedImageData.data;
  const sImg = sctx.createImageData(w,h), hImg = hctx.createImageData(w,h), cImg = cctx.createImageData(w,h);
  const sh_th = maskSliderToValue(parseFloat(shadowThreshold.value||0.3));
  const sh_f = maskSliderToValue(parseFloat(shadowFade.value||0.2));
  const hi_th = maskSliderToValue(parseFloat(highlightThreshold.value||0.7));
  const hi_f = maskSliderToValue(parseFloat(highlightFade.value||0.2));
  for (let i=0;i<src.length;i+=4){
    const r = src[i]/255, g = src[i+1]/255, b = src[i+2]/255;
    const lum = r*0.299 + g*0.587 + b*0.114;
    let sMask=0, hMask=0;
    if (enableShadows.checked){ const low = sh_th - sh_f/2, high = sh_th + sh_f/2; sMask = 1 - smoothstep(low, high, lum); }
    if (enableHighlights.checked){ const low = hi_th - hi_f/2, high = hi_th + hi_f/2; hMask = smoothstep(low, high, lum); }
    const tot = Math.max(sMask, hMask);
    const gs = Math.round(255*sMask), gh = Math.round(255*hMask), gc = Math.round(255*tot);
    sImg.data[i]=sImg.data[i+1]=sImg.data[i+2]=gs; sImg.data[i+3]=255;
    hImg.data[i]=hImg.data[i+1]=hImg.data[i+2]=gh; hImg.data[i+3]=255;
    cImg.data[i]=cImg.data[i+1]=cImg.data[i+2]=gc; cImg.data[i+3]=255;
  }
  sctx.putImageData(sImg,0,0); hctx.putImageData(hImg,0,0); cctx.putImageData(cImg,0,0);
  lastMasks = { shadows, highlights, combined };
}

/* -------------------------
   Build grid previews in single window
   Each preview canvas is made at full resolution (canvas.width/height = original),
   but CSS sets width:100% so the grid cell displays a scaled version.
   ------------------------- */
function buildLayerGrid(compositeCanvas, noiseCanvas){
  layerGrid.innerHTML = '';
  previews = [];
  const w = baseImageCanvas.width, h = baseImageCanvas.height;
  // helper
  function appendItem(name, srcCanvas){
    const item = document.createElement('div'); item.className = 'layer-item';
    const titleRow = document.createElement('div'); titleRow.className='layer-title-row';
    const title = document.createElement('div'); title.className='layer-title'; title.textContent = name;
    const actions = document.createElement('div');
    const dlBtn = document.createElement('button'); dlBtn.textContent='Download';
    dlBtn.title = 'Download full-resolution PNG';
    actions.appendChild(dlBtn);
    titleRow.appendChild(title); titleRow.appendChild(actions);
    const canvas = document.createElement('canvas'); canvas.className='layer-canvas';
    // pixel dims
    canvas.width = srcCanvas.width; canvas.height = srcCanvas.height;
    // CSS display dims handled by CSS - fill cell
    canvas.style.width = '100%'; canvas.style.height = 'auto';
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(srcCanvas,0,0);
    dlBtn.addEventListener('click', ()=> {
      const link = document.createElement('a'); link.href = canvas.toDataURL('image/png');
      link.download = `${name.replace(/\s+/g,'_').toLowerCase()}.png`; link.click();
    });
    item.appendChild(titleRow); item.appendChild(canvas);
    layerGrid.appendChild(item);
    previews.push({name, canvas, item});
  }
  // Base original
  appendItem('Base Original', baseImageCanvas);
  // Adjusted
  const adj = document.createElement('canvas'); adj.width=w; adj.height=h; adj.getContext('2d').putImageData(adjustedImageData,0,0);
  appendItem('Adjusted (with HDR)', adj);
  appendItem('HDR Emulation Result', adj);
  // Noise layer
  if (noiseCanvas) appendItem('Noise Layer', noiseCanvas);
  // Masks
  if (lastMasks.combined) appendItem('Mask (combined)', lastMasks.combined);
  if (lastMasks.shadows) appendItem('Shadows Mask', lastMasks.shadows);
  if (lastMasks.highlights) appendItem('Highlights Mask', lastMasks.highlights);
  // Composite
  appendItem('Composite (Edited)', compositeCanvas);
  // adjust layer preview window max height to be at most one viewport height (a "second page")
  layerPreviewWindow.style.maxHeight = Math.max(200, Math.min(window.innerHeight, Math.round(window.innerHeight * 0.9))) + 'px';
  layerPreviewWindow.style.overflow = 'auto';
}

/* -------------------------
   UI wiring & event handling
   - realtime: inputs call composition on input only when realtime true
   - always compose on 'change' events (release)
   - Apply button forces compose when realtime is off
   ------------------------- */
function setupUIListeners(){
  // list of inputs to wire for live/changed updates
  const inputElements = [
    strengthRange, noiseTypeSelect, satStrength, satPerNoise,
    noiseSizeRange, blurrinessRange,
    enableShadows, shadowThreshold, shadowFade,
    enableHighlights, highlightThreshold, highlightFade,
    blendModeSelect, opacityRange,
    brightnessRange, contrastRange, saturationAdjRange,
    hdrTolerance, hdrAmount,
    ignoreAlphaToggle, ignoreAlphaStrength
  ].filter(Boolean);

  inputElements.forEach(el => {
    el.addEventListener('input', (ev) => {
      if (realtime) { composeAndRender(); }
    });
    el.addEventListener('change', ()=> {
      // always apply at change
      composeAndRender();
    });
  });

  // realtime toggle
  realtimeToggle.addEventListener('click', ()=> {
    realtime = !realtime;
    realtimeToggle.textContent = 'Realtime: ' + (realtime ? 'ON' : 'OFF');
    // disable apply button when realtime on for clarity
    applyBtn.disabled = realtime;
    if (realtime) composeAndRender();
  });
  applyBtn.addEventListener('click', ()=> { composeAndRender(); });

  // other buttons
  document.getElementById('helpBtn').addEventListener('click', ()=> {
    alert('Quick tips:\n- Hover the main preview to see the original.\n- Realtime applies live updates (ON by default). Turn off to batch changes and press Apply.\n- Click a layer Download to export it at original resolution.\n- Compare opens side-by-side export options.');
  });

  compareBtn.addEventListener('click', ()=> {
    if (!originalImageLoaded) return;
    compareModal.classList.add('show'); compareModal.setAttribute('aria-hidden','false');
    drawCompareCanvases();
  });
  closeCompareBtn.addEventListener('click', ()=> { compareModal.classList.remove('show'); compareModal.setAttribute('aria-hidden','true'); });
  exportSideBySideBtn.addEventListener('click', ()=> exportCompare('side'));
  exportStackedBtn.addEventListener('click', ()=> exportCompare('stack'));

  // main download
  downloadBtn.addEventListener('click', ()=> {
    if (!originalImageLoaded) return;
    const link = document.createElement('a'); link.href = displayCanvas.toDataURL('image/png'); link.download = 'edited_image.png'; link.click();
  });

  // overlay show/hide: show original when hovering preview, hide when leaving
  const previewArea = document.getElementById('previewArea');
  previewArea.addEventListener('mouseenter', ()=> overlayWrap.classList.add('show'));
  previewArea.addEventListener('mouseleave', ()=> overlayWrap.classList.remove('show'));

  // remove the old wheel-to-change-blend behavior: do nothing special on wheel
  // Let the browser handle scroll normally
}

// compare helpers
function drawCompareCanvases(){
  const w = baseImageCanvas.width, h = baseImageCanvas.height;
  // size to fit modal area while preserving aspect
  const modal = document.querySelector('.modal');
  const rect = modal.getBoundingClientRect();
  const areaW = Math.floor((rect.width - 40) / 2);
  const scale = Math.min(1, areaW / w);
  const cw = Math.round(w * scale), ch = Math.round(h * scale);
  compareOriginal.width = cw; compareOriginal.height = ch;
  compareEdited.width = cw; compareEdited.height = ch;
  compareOriginal.getContext('2d').drawImage(baseImageCanvas,0,0,w,h,0,0,cw,ch);
  compareEdited.getContext('2d').drawImage(displayCanvas,0,0,w,h,0,0,cw,ch);
}
function exportCompare(mode){
  const w = baseImageCanvas.width, h = baseImageCanvas.height;
  let out;
  if (mode==='side'){ out = document.createElement('canvas'); out.width = w*2; out.height = h; const c = out.getContext('2d'); c.drawImage(baseImageCanvas,0,0); c.drawImage(displayCanvas,w,0); }
  else { out = document.createElement('canvas'); out.width = w; out.height = h*2; const c = out.getContext('2d'); c.drawImage(baseImageCanvas,0,0); c.drawImage(displayCanvas,0,h); }
  const link = document.createElement('a'); link.href = out.toDataURL('image/png'); link.download = (mode==='side' ? 'compare_side_by_side.png' : 'compare_stacked.png'); link.click();
  setTimeout(()=>{ compareModal.classList.remove('show'); compareModal.setAttribute('aria-hidden','true'); }, 300);
}

/* -------------------------
   File input handling
   ------------------------- */
fileInput.addEventListener('change', (ev)=> {
  const f = ev.target.files && ev.target.files[0]; if (!f) return;
  const reader = new FileReader();
  reader.onload = e => {
    const img = new Image();
    img.onload = () => loadImage(img);
    img.src = e.target.result;
  };
  reader.readAsDataURL(f);
});

function loadImage(img){
  const w = img.naturalWidth || img.width, h = img.naturalHeight || img.height;
  baseImageCanvas = document.createElement('canvas'); baseImageCanvas.width = w; baseImageCanvas.height = h;
  baseImageCanvas.getContext('2d').drawImage(img,0,0,w,h);
  originalImageLoaded = true;
  // initialize overlay/display canvases pixel dims
  displayCanvas.width = w; displayCanvas.height = h;
  overlayCanvas.width = w; overlayCanvas.height = h;
  // initial render
  composeAndRender();
}

/* -------------------------
   init
   ------------------------- */
(function init(){
  // ensure sat controls visible only when blend type is selected; default we show them (blend might not be selected)
  function updateSatVisibility(){
    const val = noiseTypeSelect.value;
    document.getElementById('satControls').style.display = (val === 'blend') ? 'flex' : 'none';
    document.getElementById('satPerNoiseRow').style.display = (val === 'blend') ? 'flex' : 'none';
  }
  noiseTypeSelect.addEventListener('change', ()=> { updateSatVisibility(); if (realtime) composeAndRender(); });
  updateSatVisibility();

  setupUIListeners();

  // realtime toggle initial state
  realtimeToggle.textContent = 'Realtime: ON';
  applyBtn.disabled = true;

  // responsive behavior: recompute layout on resize and on scroll (so if user hasn't scrolled we keep main preview fit)
  window.addEventListener('resize', ()=> {
    fitMainPreview();
    // also clamp layer window height
    layerPreviewWindow.style.maxHeight = Math.max(200, Math.min(window.innerHeight, Math.round(window.innerHeight * 0.9))) + 'px';
  });
  window.addEventListener('scroll', ()=> {
    // when user scrolls we allow main preview to be less constrained; recompute
    fitMainPreview();
  });
})();
</script>
</body>
</html>
