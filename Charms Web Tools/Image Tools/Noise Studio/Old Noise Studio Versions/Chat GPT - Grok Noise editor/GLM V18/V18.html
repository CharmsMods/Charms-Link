html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Digital Grain Studio â€” Node Graph</title>
    <style>
        :root {
            --bg: #000;
            --fg: #fff;
            --panel-max: 460px;
            --muted: #8c8c8c;
            --accent: #2a9df4;
            --border: rgba(255, 255, 255, 0.15);
            --node-bg: #1a1a1a;
            --node-header: #252525;
            --node-selected: #fff;
            --grid-color: rgba(255, 255, 255, 0.05);
            --grid-size: 20px;
            --socket-color: #555;
            --socket-hover: #fff;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            /* Prevent text selection during drag */
        }

        /* Allow text selection specifically for inputs */
        input,
        select,
        button {
            user-select: text;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        body {
            display: flex;
            gap: 0;
            align-items: stretch;
            height: 100vh;
            width: 100vw;
        }

        /* --- LEFT CONTROL PANEL --- */
        .controls-panel {
            flex: 0 0 var(--panel-max);
            max-width: var(--panel-max);
            min-width: 300px;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            background: #0a0a0a;
            z-index: 10;
        }

        .controls-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
            background: #111;
        }

        .controls-header h1 {
            font-size: 18px;
            margin: 0 0 4px 0;
            letter-spacing: -0.5px;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
            margin-bottom: 12px;
            display: block;
        }

        .controls-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .empty-state {
            color: var(--muted);
            text-align: center;
            margin-top: 40px;
            font-style: italic;
        }

        /* --- RIGHT PREVIEW / GRAPH AREA --- */
        .main-stage {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        .top-bar {
            height: 50px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            background: #0a0a0a;
        }

        .view-toggle {
            display: flex;
            background: #222;
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .view-btn {
            background: transparent;
            color: var(--muted);
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            transition: 0.2s;
        }

        .view-btn.active {
            background: var(--accent);
            color: #000;
            font-weight: bold;
        }

        .view-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: none;
            /* Toggled by JS */
        }

        .view-container.active {
            display: block;
        }

        /* --- PREVIEW MODE --- */
        .preview-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            background: repeating-linear-gradient(45deg, #111 0px, #111 10px, #0e0e0e 10px, #0e0e0e 20px);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 100%;
        }

        /* Overlay Elements */
        .overlay-original {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.2s ease;
        }

        .overlay-original canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
        }

        .overlay-original.show canvas {
            opacity: 1
        }

        #caPin {
            width: 12px;
            height: 12px;
            background: var(--accent);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: crosshair;
            z-index: 20;
            box-shadow: 0 0 5px #000;
            display: none;
        }

        #caPin.active {
            display: block;
        }

        /* Zoom / Lens */
        #zoomResIndicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 4px 8px;
            font-size: 10px;
            font-family: monospace;
            z-index: 20;
            display: none;
            border: 1px solid #0f0;
        }

        #zoomLens {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 2px solid var(--accent);
            overflow: hidden;
            pointer-events: none;
            display: none;
            z-index: 25;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        /* --- NODE GRAPH MODE --- */
        .graph-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #050505;
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            overflow: hidden;
            cursor: grab;
        }

        .graph-wrapper:active {
            cursor: grabbing;
        }

        .graph-content {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            /* width/height handled by JS for infinite scroll illusion */
            width: 100000px;
            height: 100000px;
        }

        /* Node Styles */
        .node {
            position: absolute;
            width: 180px;
            background: var(--node-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            z-index: 5;
            transition: box-shadow 0.2s, border-color 0.2s;
        }

        .node.selected {
            border-color: var(--node-selected);
            box-shadow: 0 0 15px rgba(42, 157, 244, 0.3);
        }

        .node-header {
            background: var(--node-header);
            padding: 8px 10px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            border-bottom: 1px solid var(--border);
            border-radius: 5px 5px 0 0;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .node-header:active {
            cursor: grabbing;
        }

        .node-delete {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid var(--muted);
            color: var(--muted);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
        }

        .node-delete:hover {
            background: #ff4444;
            color: white;
            border-color: #ff4444;
        }

        .node-body {
            padding: 10px;
            position: relative;
            min-height: 40px;
        }

        /* Connection Ports (Sockets) */
        .socket {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--socket-color);
            border: 2px solid var(--node-bg);
            border-radius: 50%;
            cursor: crosshair;
            transition: 0.2s;
            z-index: 10;
        }

        .socket:hover {
            background: var(--socket-hover);
            transform: scale(1.2);
        }

        /* Positioning */
        .socket.input {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .socket.output {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Specific Node Overrides */
        .node[data-type="image"] {
            border-color: #888;
        }

        .node[data-type="output"] {
            border-color: var(--accent);
        }

        .node[data-type="image"] .socket,
        .node[data-type="output"] .socket {
            cursor: default;
            pointer-events: none;
            opacity: 0.3;
        }

        /* SVG Connections Layer */
        #connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        path.connection {
            fill: none;
            stroke: #555;
            stroke-width: 2px;
            pointer-events: stroke;
            cursor: pointer;
            transition: stroke 0.2s;
        }

        path.connection:hover {
            stroke: var(--accent);
            stroke-width: 3px;
        }

        /* Node Menu */
        #node-menu-trigger {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }

        #node-menu {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 200px;
            background: #111;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            max-height: 60vh;
            overflow-y: auto;
            z-index: 99;
            display: none;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        #node-menu.show {
            display: block;
        }

        .menu-item {
            padding: 8px;
            border: 1px solid transparent;
            background: #1a1a1a;
            margin-bottom: 4px;
            font-size: 11px;
            cursor: grab;
            border-radius: 3px;
        }

        .menu-item:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* --- BOTTOM LAYER BREAKDOWN --- */
        .bottom-panel {
            height: 160px;
            border-top: 1px solid var(--border);
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
        }

        .bottom-header {
            padding: 6px 12px;
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: #111;
            display: flex;
            justify-content: space-between;
        }

        .layer-grid {
            display: flex;
            gap: 4px;
            padding: 8px;
            height: 100%;
            overflow-x: auto;
            background: #050505;
        }

        .layer-item {
            min-width: 100px;
            border: 1px solid var(--border);
            background: #000;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .layer-item:hover {
            border-color: var(--muted);
        }

        .layer-item.active {
            border-color: var(--accent);
        }

        .layer-title {
            font-size: 9px;
            text-align: center;
            padding: 4px;
            background: #111;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-canvas {
            width: 100%;
            flex: 1;
            background: #111;
            object-fit: contain;
        }

        /* --- UI CONTROLS (Shared) --- */
        .control-group {
            margin-bottom: 16px;
        }

        details {
            border: 1px solid var(--border);
            margin-bottom: 8px;
            padding: 6px;
            border-radius: 4px;
            background: #0a0a0a;
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            margin: 0 0 6px 0;
            outline: none;
            font-size: 12px;
            color: #ccc;
        }

        summary:hover {
            color: var(--accent);
        }

        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
            min-height: 24px;
        }

        .control-row label {
            flex: 0 0 100px;
            font-size: 11px;
            color: #bbb;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
            height: 4px;
            margin: 0;
        }

        .control-value {
            width: 40px;
            background: #000;
            border: 1px solid var(--border);
            color: #fff;
            font-size: 10px;
            padding: 2px;
            text-align: right;
            font-family: monospace;
        }

        select.control-value {
            padding: 2px;
            width: auto;
            flex: 1;
        }

        button.ui-btn {
            background: #222;
            color: #eee;
            border: 1px solid var(--border);
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            border-radius: 3px;
            transition: 0.2s;
        }

        button.ui-btn:hover:not(:disabled) {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        button.ui-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .row-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        /* Toggle Switch */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            accent-color: var(--accent);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: #111;
            border: 1px solid var(--border);
            padding: 20px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--accent);
            color: #000;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: bold;
            display: none;
            z-index: 3000;
        }

        /* Input styling */
        .file-input-wrapper {
            margin-top: 10px;
            text-align: center;
            border: 1px dashed var(--border);
            padding: 15px;
            border-radius: 4px;
            background: #080808;
        }

        .file-btn {
            background: #222;
            color: var(--accent);
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            margin-top: 4px;
            width: 100%;
            text-align: center;
            border: 1px solid var(--border);
        }

        .file-btn:hover {
            background: var(--accent);
            color: #000;
        }
    </style>
</head>

<body>

    <!-- Loading Indicator -->
    <div id="loading">PROCESSING GPU...</div>

    <!-- LEFT PANEL: CONTROLS -->
    <div class="controls-panel">
        <div class="controls-header">
            <h1>DIGITAL GRAIN [GPU]</h1>
            <span class="muted">WebGL2 Pipeline</span>
        </div>

        <div class="file-input-wrapper">
            <label for="imageUpload" style="cursor: pointer; display: block;">
                <span style="font-size: 24px;">ðŸ“‚</span>
                <div style="font-size: 11px; color: var(--accent); margin-top:4px;">LOAD SOURCE IMAGE</div>
            </label>
            <input id="imageUpload" type="file" accept="image/*" style="display: none;">

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 8px;">
                <button class="file-btn" id="downloadJsonBtn">SAVE .JSON</button>
                <button class="file-btn" id="uploadJsonTrigger">LOAD .JSON</button>
                <input id="jsonUpload" type="file" accept=".json" style="display: none;">
            </div>
        </div>

        <!-- Dynamic Controls Container -->
        <div id="dynamic-controls" class="controls-content">
            <div class="empty-state">
                Select a node in the graph to view controls.<br>
                Or add nodes to the graph to begin.
            </div>
        </div>

        <div class="row-buttons" style="padding: 16px; border-top: 1px solid var(--border);">
            <button id="downloadBtn" class="ui-btn" style="flex:1;" disabled>EXPORT IMG</button>
            <button id="compareBtn" class="ui-btn" style="flex:1;" disabled>COMPARE</button>
        </div>
    </div>

    <!-- RIGHT STAGE -->
    <div class="main-stage">

        <!-- Top Bar -->
        <div class="top-bar">
            <div class="view-toggle">
                <button class="view-btn" id="btn-view-graph">Node Graph</button>
                <button class="view-btn active" id="btn-view-preview">Preview</button>
            </div>

            <div style="display:flex; align-items:center; gap:12px;">
                <!-- Zoom Controls -->
                <div style="font-size:10px; color:var(--muted); display:flex; align-items:center; gap:4px;">
                    <span>HOVER ZOOM</span>
                    <input id="hoverZoomSlider" type="range" min="1" max="8" step="0.1" value="1" style="width:60px;">
                    <span id="hoverZoomValue" style="width:20px; text-align:center;">1x</span>
                </div>

                <button id="lensToggleBtn" class="ui-btn" style="padding:4px 8px; font-size:9px;">FULL</button>

                <label class="toggle-switch">
                    <input type="checkbox" id="previewLock">
                    <span>LOCK PREV</span>
                </label>

                <div style="font-size:10px; color:var(--muted); display:flex; align-items:center; gap:4px;">
                    <span>UPSCALE</span>
                    <input id="upscaleInput" type="text" value="1"
                        style="width:30px; background:#000; border:1px solid #333; color:#fff; text-align:center;"
                        min="1" max="10">
                </div>
            </div>
        </div>

        <!-- VIEW: GRAPH -->
        <div id="view-graph" class="view-container">
            <div class="graph-wrapper" id="graphWrapper">
                <div class="graph-content" id="graphContent">
                    <svg id="connections-layer"></svg>
                    <!-- Nodes injected here -->
                </div>

                <!-- Menu Trigger -->
                <button id="node-menu-trigger" class="ui-btn">+ ADD NODE</button>

                <!-- Node List Menu -->
                <div id="node-menu">
                    <div style="font-size:10px; color:var(--muted); margin-bottom:4px; text-transform:uppercase;">Drag
                        to graph</div>
                    <!-- Items injected via JS -->
                </div>
            </div>
        </div>

        <!-- VIEW: PREVIEW -->
        <div id="view-preview" class="view-container active">
            <div class="preview-wrapper" id="previewContainer">
                <canvas id="displayCanvas"></canvas>

                <!-- Overlay Original -->
                <div class="overlay-original" id="overlayOriginal">
                    <canvas id="overlayCanvas"></canvas>
                </div>

                <!-- Chromatic Pin -->
                <div id="caPin"></div>

                <!-- Lens -->
                <div id="zoomLens">
                    <canvas id="lensCanvas" style="position:absolute; top:0; left:0;"></canvas>
                </div>

                <!-- Res Info -->
                <div id="zoomResIndicator"></div>
            </div>
        </div>

        <!-- Bottom: Layer Breakdown -->
        <div class="bottom-panel">
            <div class="bottom-header">
                <span>Layer Breakdown (Isolated)</span>
                <span>Click node to isolate</span>
            </div>
            <div class="layer-grid" id="layerGrid">
                <!-- Layer previews injected here -->
            </div>
        </div>
    </div>

    <!-- Compare Modal -->
    <div id="compareModal" class="modal-overlay">
        <div class="modal">
            <h2 style="margin-top:0; text-align:center;">Comparison & Export</h2>
            <div style="display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap;">
                <div>
                    <div style="text-align:center; font-size:10px; color:#888; margin-bottom:5px;">ORIGINAL</div>
                    <canvas id="compareOriginal"
                        style="max-height: 50vh; max-width: 40vw; border: 1px solid #333;"></canvas>
                </div>
                <div>
                    <div style="text-align:center; font-size:10px; color:#888; margin-bottom:5px;">PROCESSED</div>
                    <canvas id="compareProcessed"
                        style="max-height: 50vh; max-width: 40vw; border: 1px solid #333;"></canvas>
                </div>
            </div>
            <div style="text-align: center; display: flex; gap: 10px; justify-content: center;">
                <button id="exportSideBySide" class="ui-btn">SIDE-BY-SIDE</button>
                <button id="exportStacked" class="ui-btn">STACKED</button>
                <button id="closeCompare" class="ui-btn">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="modal-overlay">
        <div class="modal" style="max-width:300px; text-align:center;">
            <h3 style="margin-top:0;">Remove Node?</h3>
            <p style="font-size:12px; color:#aaa;">This will remove the node and all its connections.</p>
            <div style="margin-top:20px; display:flex; justify-content:center; gap:10px;">
                <button id="confirmDelete" class="ui-btn" style="background:#800; border-color:#f00;">DELETE</button>
                <button id="cancelDelete" class="ui-btn">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- SHADERS -->
    <script type="x-shader/x-vertex" id="vs-quad">
#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
v_uv = a_uv;
gl_Position = vec4(a_pos, 0.0, 1.0);
}
</script>

    <!-- Master Noise Shader (Includes Basics, Blur, Blend, Masking, Alpha) -->
    <script type="x-shader/x-fragment" id="fs-noise-layer">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_mask; // Optional texture for complex masks if needed, but we use procedural here

// Noise Params
uniform int u_type; // 0=Color, 1=Gray, 2=Blend(Sat)
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;

// Blur Params
uniform float u_blurAmt;

// Blend Params
uniform int u_mode; // 0=Normal, 1=Overlay, 2=Screen, 3=Mult, 4=Add, 5=Diff
uniform float u_opacity;
uniform float u_str; // Strength multiplier

// Saturation Params
uniform float u_satStr;
uniform float u_satImp;

// Masking
uniform int u_useS; uniform float u_sth; uniform float u_sfa;
uniform int u_useH; uniform float u_hth; uniform float u_hfa;

// Alpha
uniform int u_ignA; uniform float u_ignAstr;

float hash12(vec2 p) {
vec3 p3 = fract(vec3(p.xyx) * .1031);
p3 += dot(p3, p3.yzx + 33.33);
return fract((p3.x + p3.y) * p3.z);
}

// Simple gaussian blur simulation within single pass (limited kernel size)
vec3 getBlurredNoise(vec2 uv, float scale, float blur) {
vec3 col = vec3(0.0);
float total = 0.0;
// Simple 3x3 or 5x5 depending on blur, but optimization needed.
// Doing a simplified approximation for real-time performance
// We sample hash at nearby UVs

if (blur < 0.1) {
vec2 pos = uv * u_res / max(1.0, u_scale);
vec2 cell = floor(pos);
float r = hash12(cell + u_seed);
float g = hash12(cell + u_seed + 1.23);
float b = hash12(cell + u_seed + 2.45);
return vec3(r,g,b);
}

// Box blur approx
for(float x=-2.0; x<=2.0; x++){
for(float y=-2.0; y<=2.0; y++){
vec2 offset = vec2(x,y) * blur * 0.005;
vec2 pos = (uv + offset) * u_res / max(1.0, u_scale);
vec2 cell = floor(pos);
float r = hash12(cell + u_seed);
float g = hash12(cell + u_seed + 1.23);
float b = hash12(cell + u_seed + 2.45);
col += vec3(r,g,b);
total += 1.0;
}
}
return col / total;
}

float overlay(float b, float n) {
return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

void main() {
vec4 bc = texture(u_base, v_uv);
float lum = dot(bc.rgb, vec3(0.299,0.587,0.114));

// 1. Generate Noise
vec3 nRaw = getBlurredNoise(v_uv, u_scale, u_blurAmt);

// 2. Apply Noise Type Logic
vec3 nFinal;
if (u_type == 1) { // Grayscale
nFinal = vec3(nRaw.r);
} else if (u_type == 2) { // Saturation Blend Mode (Special)
float centered = (nRaw.r - 0.5) * 2.0;
float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
vec3 satColor = mix(vec3(lum), bc.rgb, 1.0 + delta * (u_str/50.0));
outColor = vec4(satColor, bc.a);
return; // Early exit for Sat mode
} else {
nFinal = nRaw;
}

// 3. Blend Modes
vec3 res;
if (u_mode == 0) res = mix(bc.rgb, nFinal, u_opacity);
else if (u_mode == 1) {
res.r = overlay(bc.r, nFinal.r);
res.g = overlay(bc.g, nFinal.g);
res.b = overlay(bc.b, nFinal.b);
}
else if (u_mode == 2) res = 1.0 - (1.0 - bc.rgb) * (1.0 - nFinal);
else if (u_mode == 3) res = bc.rgb * nFinal;
else if (u_mode == 4) res = bc.rgb + nFinal;
else if (u_mode == 5) res = abs(bc.rgb - nFinal);
else res = bc.rgb;

// 4. Luminance Masking
float sMask = 0.0;
if (u_useS == 1) {
float low = u_sth - u_sfa * 0.5;
float high = u_sth + u_sfa * 0.5;
sMask = 1.0 - smoothstep(low, high, lum);
}
float hMask = 0.0;
if (u_useH == 1) {
float low = u_hth - u_hfa * 0.5;
float high = u_hth + u_hfa * 0.5;
hMask = smoothstep(low, high, lum);
}
float maskVal = max(sMask, hMask);

// 5. Alpha & Strength
float alphaFactor = 1.0;
if (u_ignA == 1) {
alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
}

float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0);
vec3 finalRGB = mix(bc.rgb, res, clamp(finalOp, 0.0, 1.0));

outColor = vec4(clamp(finalRGB, 0.0, 1.0), bc.a);
}
</script>

    <!-- Adjustments Shader (Brightness, Contrast, Saturation, Warmth, Sharpen, HDR) -->
    <script type="x-shader/x-fragment" id="fs-adjust">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform vec2 u_step;

void main() {
vec4 c = texture(u_tex, v_uv);
vec3 rgb = c.rgb;
float lum = dot(rgb, vec3(0.299,0.587,0.114));

// Saturation
rgb = mix(vec3(lum), rgb, 1.0 + u_sat);
// Contrast
rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;
// Brightness
rgb += u_bright/100.0;
// Warmth
if (u_warmth != 0.0) {
vec3 warmColor = vec3(1.0, 0.9, 0.8);
vec3 coolColor = vec3(0.8, 0.9, 1.1);
float t = clamp(u_warmth / 100.0, -1.0, 1.0);
vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
float mask = smoothstep(0.0, 1.0, lum);
rgb = mix(rgb, rgb * tint, abs(t) * mask);
}
// HDR
if (lum < u_hdrTol && u_hdrTol > 0.0) {
float f = (u_hdrAmt/100.0) * (1.0 - lum/u_hdrTol);
rgb *= (1.0 - f);
}
// Sharpening
if (u_sharp > 0.0) {
vec4 sum = vec4(0.0);
sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
sum += texture(u_tex, v_uv + vec2(-u_step.x, u_step.y));
sum += texture(u_tex, v_uv + vec2( u_step.x, u_step.y));
vec4 edge = c - (sum * 0.25);
rgb += edge.rgb * (u_sharp / 10.0);
}
outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script>

    <!-- Chromatic Aberration -->
    <script type="x-shader/x-fragment" id="fs-chroma">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

void main() {
if (u_amt <= 0.0) { outColor = texture(u_tex, v_uv); return; }
vec2 dir = v_uv - u_center;
float dist = length(dir);
float clearMask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
float str = dist * dist * (u_amt / 1000.0);
str *= (1.0 - clearMask);

vec4 result = vec4(0.0);
if (u_blur > 0.0) {
float totalWeight = 0.0;
for(float i = -2.0; i <= 2.0; i++) {
float t = i * u_blur * 0.002;
float w = exp(-(i*i)/2.0);
float r = texture(u_tex, v_uv - dir * str + vec2(t, -t)).r;
float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5)).g;
float b = texture(u_tex, v_uv + dir * str + vec2(-t, t)).b;
result += vec4(r, g, b, 1.0) * w;
totalWeight += w;
}
result /= totalWeight;
result.a = texture(u_tex, v_uv).a;
} else {
float r = texture(u_tex, v_uv - dir * str).r;
float g = texture(u_tex, v_uv).g;
float b = texture(u_tex, v_uv + dir * str).b;
float a = texture(u_tex, v_uv).a;
result = vec4(r, g, b, a);
}
outColor = result;
}
</script>

    <!-- Dithering -->
    <script type="x-shader/x-fragment" id="fs-dither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_type; // 0 Bayer, 1 Random
uniform float u_bitDepth; // 1-8
uniform float u_paletteSize; // 2-256
uniform float u_str; // 0-1
uniform float u_scale; // 1-16

float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

// Bayer Matrix 4x4
float bayer4x4(vec2 uv) {
int x = int(mod(uv.x, 4.0));
int y = int(mod(uv.y, 4.0));
if (x==0&&y==0) return 0.0/16.0; if (x==1&&y==0) return 8.0/16.0; if (x==2&&y==0) return 2.0/16.0; if (x==3&&y==0) return 10.0/16.0;
if (x==0&&y==1) return 12.0/16.0; if (x==1&&y==1) return 4.0/16.0; if (x==2&&y==1) return 14.0/16.0; if (x==3&&y==1) return 6.0/16.0;
if (x==0&&y==2) return 3.0/16.0; if (x==1&&y==2) return 11.0/16.0; if (x==2&&y==2) return 1.0/16.0; if (x==3&&y==2) return 9.0/16.0;
if (x==0&&y==3) return 15.0/16.0; if (x==1&&y==3) return 7.0/16.0; if (x==2&&y==3) return 13.0/16.0; if (x==3&&y==3) return 5.0/16.0;
return 0.0;
}

void main() {
vec4 c = texture(u_tex, v_uv);
vec3 rgb = c.rgb;
vec2 coord = v_uv * vec2(800.0, 600.0) / u_scale; // Estimate screen coords

float noise = 0.0;
if(u_type == 0) noise = bayer4x4(coord);
else noise = hash(coord);

float levels = pow(2.0, u_bitDepth);
float palette = u_paletteSize;

// Quantize
vec3 q = floor(rgb * levels) / levels;

// Apply dither offset
float offset = (noise - 0.5) * u_str;
vec3 dithered = q + offset;

outColor = vec4(clamp(dithered, 0.0, 1.0), c.a);
}
</script>

    <!-- Corruption -->
    <script type="x-shader/x-fragment" id="fs-corruption">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_algo; // 0 JPEG, 1 Pixelate, 2 Bleed
uniform float u_iter;
uniform float u_scale; // Resolution scale

void main() {
vec2 uv = v_uv;
vec4 c = vec4(0.0);

if(u_algo == 1) { // Pixelate
vec2 pixels = vec2(1.0) / (u_scale * 0.01 + 1.0);
vec2 coord = floor(uv * pixels) / pixels;
c = texture(u_tex, coord);
}
else if (u_algo == 0) { // JPEG Blocks (Simulated via sorting or channel shift)
// Simplified blocky artifact
float bSize = 8.0 * u_scale * 0.02 + 1.0;
vec2 coord = floor(uv * bSize) / bSize;
c = texture(u_tex, coord);
// Add some color bleed
c.r = texture(u_tex, coord + vec2(0.01,0.0)).r;
}
else { // Color Bleed
c = texture(u_tex, uv);
float s = u_scale * 0.05;
if(mod(uv.y * s, 1.0) < 0.5) c.rb = texture(u_tex, uv + vec2(0.02, 0.0)).rb;
}
outColor = c;
}
</script>

    <!-- Cell Shading -->
    <script type="x-shader/x-fragment" id="fs-cell">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_levels;
uniform float u_bias;
uniform float u_gamma;
uniform int u_qMode; // 0 Lum, 1 RGB, 2 HSV
uniform int u_edgeMethod; // 0 None, 1 Sobel, 2 Laplacian
uniform float u_edgeStr;
uniform float u_edgeThick;
uniform bool u_colorPreserve;

vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

void main() {
vec4 c = texture(u_tex, v_uv);
vec3 rgb = c.rgb;
vec3 val = rgb;

if(u_qMode == 0) val = vec3(dot(rgb, vec3(0.299,0.587,0.114)));
else if(u_qMode == 2) val = vec3(rgb2hsv(rgb).b); // Value

// Gamma
val = pow(val, vec3(u_gamma));
// Quantize
val = floor(val * u_levels + u_bias) / u_levels;

vec3 outRgb = rgb;
if(u_qMode == 0 || u_qMode == 2) {
if(u_colorPreserve) outRgb = mix(vec3(dot(rgb, vec3(0.299,0.587,0.114))), rgb, val.r); // Approx
else outRgb = val;
} else {
outRgb = val;
}

// Edge Detection
if(u_edgeMethod > 0) {
vec2 step = vec2(0.005) * u_edgeThick;
float tl = dot(texture(u_tex, v_uv + vec2(-step.x, -step.y)).rgb, vec3(0.299,0.587,0.114));
float tr = dot(texture(u_tex, v_uv + vec2( step.x, -step.y)).rgb, vec3(0.299,0.587,0.114));
float bl = dot(texture(u_tex, v_uv + vec2(-step.x, step.y)).rgb, vec3(0.299,0.587,0.114));
float br = dot(texture(u_tex, v_uv + vec2( step.x, step.y)).rgb, vec3(0.299,0.587,0.114));
float edge = 0.0;
if(u_edgeMethod == 1) edge = abs(tl + 2.0*tr + br - bl - 2.0*br - br); // Simplified Sobel
if(u_edgeMethod == 2) edge = 4.0 * dot(rgb,vec3(0.299)) - tl-tr-bl-br; // Laplacian

if(edge > 0.05) outRgb = vec3(0.0);
}

outColor = vec4(clamp(outRgb, 0.0, 1.0), c.a);
}
</script>

    <!-- Halftoning -->
    <script type="x-shader/x-fragment" id="fs-halftone">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_size;
uniform float u_str;
uniform int u_pat; // 0 Circle, 1 Line, 2 Cross
uniform int u_cMode; // 0 Lum, 1 RGB
uniform bool u_gray;
uniform bool u_invert;

float pattern(vec2 uv, float size) {
uv = mod(uv, size);
float d = length(uv - size*0.5);
if(u_pat == 1) return abs(uv.x - size*0.5); // Line
if(u_pat == 2) return max(abs(uv.x - size*0.5), abs(uv.y - size*0.5)); // Cross
return d; // Circle
}

void main() {
vec4 c = texture(u_tex, v_uv);
vec2 px = v_uv * vec2(800,600); // Approx pixels
float size = u_size * 2.0;

vec3 rgb = c.rgb;
if(u_cMode == 0) rgb = vec3(dot(rgb, vec3(0.299,0.587,0.114)));

vec3 val = 1.0 - smoothstep(size*0.4, size*0.4 + u_str, pattern(px, size) * (1.0 - rgb));

if(u_gray) val = vec3(val.r);
if(u_invert) val = 1.0 - val;

outColor = vec4(val, c.a);
}
</script>

    <!-- Bilateral Filter -->
    <script type="x-shader/x-fragment" id="fs-bilateral">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_rad;
uniform float u_cSig; // Color Sigma
uniform float u_sSig; // Spatial Sigma

void main() {
vec4 c = texture(u_tex, v_uv);
vec3 sum = vec3(0.0);
float totalWeight = 0.0;

// Simplified separable or small kernel for WebGL perf
// 5x5 kernel
for(float x=-2.0; x<=2.0; x++){
for(float y=-2.0; y<=2.0; y++){
vec2 offset = vec2(x,y) * u_rad;
vec4 s = texture(u_tex, v_uv + offset * 0.005); // 0.005 approx pixel size
float spaceDist = dot(vec2(x,y), vec2(x,y));
float colorDist = distance(c.rgb, s.rgb);

float w = exp(-spaceDist/(2.0*u_sSig*u_sSig)) * exp(-colorDist*colorDist/(2.0*u_cSig*u_cSig));
sum += s.rgb * w;
totalWeight += w;
}
}
outColor = vec4(sum/totalWeight, c.a);
}
</script>

    <!-- Output / Copy -->
    <script type="x-shader/x-fragment" id="fs-copy">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
void main() {
outColor = texture(u_tex, v_uv);
}
</script>

    <!-- MAIN SCRIPT -->
    <script>
        // --- DATA & CONFIG ---
        const NODE_TYPES = {
            'noise': {
                title: 'Noise Layer',
                controls: [
                    {
                        id: 'group_basics', title: 'Noise Basics', type: 'group', items: [
                            { id: 'strength', label: 'Strength', type: 'range', min: 0, max: 150, val: 40 },
                            { id: 'noiseType', label: 'Type', type: 'select', opts: ['Grayscale', 'Color', 'Blend (Sat)'], val: 1 },
                            { id: 'satStrength', label: 'Sat Strength', type: 'range', min: 0, max: 4, val: 1 },
                            { id: 'satPerNoise', label: 'Sat Impact', type: 'range', min: -100, max: 100, val: 0 },
                        ]
                    },
                    {
                        id: 'group_shape', title: 'Shape & Blur', type: 'group', items: [
                            { id: 'noiseSize', label: 'Scale', type: 'range', min: 0, max: 10, val: 0 },
                            { id: 'blurriness', label: 'Blurriness', type: 'range', min: 0, max: 100, val: 50 },
                        ]
                    },
                    {
                        id: 'group_blend', title: 'Blend & Opacity', type: 'group', items: [
                            { id: 'blendMode', label: 'Mode', type: 'select', opts: ['Normal', 'Overlay', 'Screen', 'Multiply', 'Add', 'Difference'], val: 1 },
                            { id: 'opacity', label: 'Opacity', type: 'range', min: 0, max: 1, step: 0.01, val: 0.5 },
                        ]
                    },
                    {
                        id: 'group_mask', title: 'Luminance Masking', type: 'group', items: [
                            { id: 'enableShadows', label: 'Enable Shadows', type: 'check', val: true },
                            { id: 'shadowThreshold', label: 'S. Threshold', type: 'range', min: 0, max: 1, step: 0.01, val: 0 },
                            { id: 'shadowFade', label: 'S. Fade', type: 'range', min: 0, max: 1, step: 0.01, val: 0 },
                            { id: 'enableHighlights', label: 'Enable Highlights', type: 'check', val: true },
                            { id: 'highlightThreshold', label: 'H. Threshold', type: 'range', min: 0, max: 1, step: 0.01, val: 0 },
                            { id: 'highlightFade', label: 'H. Fade', type: 'range', min: 0, max: 1, step: 0.01, val: 0 },
                        ]
                    },
                    {
                        id: 'group_alpha', title: 'Alpha Channel', type: 'group', items: [
                            { id: 'ignoreAlphaToggle', label: 'Ignore Alpha', type: 'check', val: true },
                            { id: 'ignoreAlphaStrength', label: 'Strength', type: 'range', min: 0, max: 100, val: 100 },
                        ]
                    }
                ]
            },
            'adjustments': {
                title: 'Adjustments',
                controls: [
                    { id: 'brightness', label: 'Brightness', type: 'range', min: -100, max: 100, val: 0 },
                    { id: 'contrast', label: 'Contrast', type: 'range', min: -100, max: 200, val: 0 },
                    { id: 'saturationAdj', label: 'Saturation', type: 'range', min: -100, max: 100, val: 0 },
                    { id: 'warmth', label: 'Warmth', type: 'range', min: -500, max: 500, val: 0 },
                    { id: 'sharpen', label: 'Sharpening', type: 'range', min: 0, max: 100, val: 0 },
                    { id: 'hdrTolerance', label: 'HDR Tol', type: 'range', min: 0, max: 1, step: 0.01, val: 0.35 },
                    { id: 'hdrAmount', label: 'HDR Amt', type: 'range', min: 0, max: 100, val: 0 },
                ]
            },
            'chroma': {
                title: 'Chromatic Ab.',
                controls: [
                    { id: 'aberrationAmount', label: 'Amount', type: 'range', min: 0, max: 1500, val: 0 },
                    { id: 'caRadius', label: 'Clear Radius', type: 'range', min: 0, max: 1000, val: 0 },
                    { id: 'caFalloff', label: 'Falloff', type: 'range', min: 0, max: 500, val: 0 },
                    { id: 'aberrationBlur', label: 'Edge Blur', type: 'range', min: 0, max: 100, val: 0 },
                    { id: 'resetCenterBtn', label: 'Reset Center', type: 'action' }
                ]
            },
            'dither': {
                title: 'Dithering',
                controls: [
                    { id: 'ditherEnable', label: 'Enable', type: 'check', val: false },
                    { id: 'ditherBitDepth', label: 'Bit Depth', type: 'range', min: 1, max: 8, val: 4 },
                    { id: 'ditherPaletteSize', label: 'Palette', type: 'range', min: 2, max: 256, val: 16 },
                    { id: 'ditherStrength', label: 'Strength', type: 'range', min: 0, max: 100, val: 50 },
                    { id: 'ditherScale', label: 'Scale', type: 'range', min: 1, max: 16, val: 1 },
                    { id: 'ditherType', label: 'Type', type: 'select', opts: ['Bayer', 'Noise'], val: 0 }
                ]
            },
            'corruption': {
                title: 'Corruption',
                controls: [
                    { id: 'corruptionEnable', label: 'Enable', type: 'check', val: false },
                    { id: 'corruptionIterations', label: 'Iterations', type: 'range', min: 0, max: 500, val: 0 },
                    { id: 'corruptionAlgorithm', label: 'Algo', type: 'select', opts: ['JPEG Blocks', 'Pixelation', 'Color Bleed'], val: 0 },
                    { id: 'corruptionResScale', label: 'Res Scale', type: 'range', min: 1, max: 100, val: 50 }
                ]
            },
            'cell': {
                title: 'Cell Shading',
                controls: [
                    { id: 'cellEnable', label: 'Enable', type: 'check', val: false },
                    { id: 'cellLevels', label: 'Levels', type: 'range', min: 2, max: 12, val: 4 },
                    { id: 'cellBias', label: 'Bias', type: 'range', min: -1, max: 1, step: 0.01, val: 0 },
                    { id: 'cellGamma', label: 'Gamma', type: 'range', min: 0.5, max: 2.2, step: 0.01, val: 1.0 },
                    { id: 'cellQuantMode', label: 'Quantize', type: 'select', opts: ['Luminance', 'RGB', 'HSV Value'], val: 0 },
                    { id: 'cellEdgeEnable', label: 'Edges', type: 'check', val: false },
                    { id: 'cellEdgeStr', label: 'Edge Str', type: 'range', min: 0, max: 1, step: 0.01, val: 0.8 },
                    { id: 'cellEdgeThick', label: 'Thick', type: 'range', min: 0.5, max: 3, step: 0.1, val: 1.0 },
                    { id: 'cellEdgeMethod', label: 'Method', type: 'select', opts: ['None', 'Sobel', 'Laplacian'], val: 1 },
                    { id: 'cellColorPreserve', label: 'Color Preserve', type: 'check', val: false }
                ]
            },
            'halftone': {
                title: 'Halftoning',
                controls: [
                    { id: 'halftoneEnable', label: 'Enable', type: 'check', val: false },
                    { id: 'halftoneSize', label: 'Dot Size', type: 'range', min: 1, max: 12, step: 0.1, val: 4 },
                    { id: 'halftoneIntensity', label: 'Intensity', type: 'range', min: 0, max: 1, step: 0.01, val: 0.8 },
                    { id: 'halftoneSharpness', label: 'Sharpness', type: 'range', min: 0, max: 1, step: 0.01, val: 0.5 },
                    { id: 'halftonePattern', label: 'Pattern', type: 'select', opts: ['Circle', 'Line', 'Cross', 'Diamond'], val: 0 },
                    { id: 'halftoneColorMode', label: 'Color Mode', type: 'select', opts: ['Luminance', 'RGB', 'CMY', 'CMYK'], val: 0 },
                    { id: 'halftoneGray', label: 'Grayscale', type: 'check', val: false },
                    { id: 'halftoneInvert', label: 'Invert', type: 'check', val: false }
                ]
            },
            'bilateral': {
                title: 'Bilateral Filter',
                controls: [
                    { id: 'bilateralEnable', label: 'Enable', type: 'check', val: false },
                    { id: 'bilateralRadius', label: 'Radius', type: 'range', min: 1, max: 30, val: 5 },
                    { id: 'bilateralColorSig', label: 'Color Sigma', type: 'range', min: 0.01, max: 1.0, step: 0.01, val: 0.1 },
                    { id: 'bilateralSpatialSig', label: 'Space Sigma', type: 'range', min: 0.5, max: 15.0, step: 0.1, val: 2.0 },
                    { id: 'bilateralHighPrec', label: 'High Precision', type: 'check', val: true }
                ]
            }
        };

        // --- GLOBAL STATE ---
        let gl, canvas;
        let programs = {};
        let textures = {};
        let framebuffers = {};
        let graphState = {
            nodes: [],
            connections: [],
            nextId: 1,
            selectedNodeId: null,
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0
        };
        let sourceImage = null; // HTMLImageElement
        let sourceTexture = null;
        let canvasWidth = 0, canvasHeight = 0;
        let animationId = null;
        let needsRender = true;

        // --- WEBGL SETUP ---
        function initWebGL() {
            canvas = document.getElementById('displayCanvas');
            gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true, antialias: false });
            if (!gl) alert("WebGL2 not supported");

            // Quad Buffer
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1,
                -1, 1, 0, 1, 1, -1, 1, 0, 1, 1, 1, 1
            ]), gl.STATIC_DRAW);

            // Compile Shaders
            const vsSource = document.getElementById('vs-quad').textContent.trim();
            const shaderIds = ['fs-noise-layer', 'fs-adjust', 'fs-chroma', 'fs-dither', 'fs-corruption', 'fs-cell', 'fs-halftone', 'fs-bilateral', 'fs-copy'];

            shaderIds.forEach(id => {
                const fsSource = document.getElementById(id).textContent.trim();
                programs[id.replace('fs-', '')] = createProgram(vsSource, fsSource);
            });

            resizeCanvas();
        }

        function createShader(type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }

        function createProgram(vsSource, fsSource) {
            const p = gl.createProgram();
            const vs = createShader(gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
            gl.attachShader(p, vs);
            gl.attachShader(p, fs);
            gl.linkProgram(p);
            if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(p));
                return null;
            }

            // Bind standard attribs
            gl.useProgram(p);
            const posLoc = gl.getAttribLocation(p, 'a_pos');
            const uvLoc = gl.getAttribLocation(p, 'a_uv');

            // We assume the VBO is bound globally for simplicity
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
            gl.enableVertexAttribArray(uvLoc);
            gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);

            return p;
        }

        function createTexture(width, height, data = null) {
            const t = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, t);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            if (data) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            } else {
                // Placeholder 1x1 black
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
            }
            return t;
        }

        function createFramebuffer(tex) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            return fb;
        }

        function resizeCanvas() {
            // Display size
            const displayW = canvas.clientWidth;
            const displayH = canvas.clientHeight;

            // Internal render size depends on source and upscale
            if (sourceImage) {
                const scale = parseFloat(document.getElementById('upscaleInput').value) || 1;
                canvasWidth = sourceImage.width * scale;
                canvasHeight = sourceImage.height * scale;
            } else {
                canvasWidth = displayW;
                canvasHeight = displayH;
            }

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            gl.viewport(0, 0, canvasWidth, canvasHeight);
            needsRender = true;
        }

        function updateSourceTexture(img) {
            sourceImage = img;
            if (!sourceTexture) sourceTexture = createTexture(img.width, img.height, img);
            else {
                gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, img.width, img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
            }
            // Create ping pong buffers for rendering
            // We need large buffers for full res
            ['a', 'b'].forEach(k => {
                if (textures[k]) gl.deleteTexture(textures[k]);
                if (framebuffers[k]) gl.deleteFramebuffer(framebuffers[k]);
                textures[k] = createTexture(canvasWidth, canvasHeight);
                framebuffers[k] = createFramebuffer(textures[k]);
            });
            resizeCanvas();

            // Add image node if first time
            if (graphState.nodes.length === 0) {
                addNode('image', 50, 300);
                addNode('output', 850, 300);
            }
            needsRender = true;
        }

        // --- GRAPH RENDER LOGIC ---
        function render() {
            if (!needsRender || !sourceImage) return;

            document.getElementById('loading').style.display = 'block';

            // 1. Find path from Image -> Output
            const startNode = graphState.nodes.find(n => n.type === 'image');
            const endNode = graphState.nodes.find(n => n.type === 'output');
            let path = [];

            if (startNode && endNode) {
                path = findPath(startNode, endNode);
            }

            if (path.length > 0) {
                let readTex = sourceTexture;
                let writeFb = framebuffers.a;
                let writeTex = textures.a;

                // For each node in path (excluding start image node itself for the first pass)
                // path includes Image -> [Nodes] -> Output
                for (let i = 1; i < path.length; i++) {
                    const node = path[i];
                    const programName = getShaderForNode(node.type);
                    const prog = programs[programName];

                    gl.useProgram(prog);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, readTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(prog, 'u_res'), canvasWidth, canvasHeight);

                    // Bind Node Params
                    bindUniforms(prog, node.data, node.type);

                    // Pass: Input Texture -> Node Shader -> Write Framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, writeFb);
                    gl.viewport(0, 0, canvasWidth, canvasHeight);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);

                    // Swap Ping Pong
                    let tempFb = writeFb;
                    writeFb = (readTex === textures.a) ? framebuffers.b : framebuffers.a;
                    readTex = (readTex === textures.a) ? textures.b : textures.a;
                    // writeTex is irrelevant for next readTex assignment, just tracking logic
                    // Actually, simpler:
                    // Read was Texture A. We wrote to FB B (which holds Texture B).
                    // Next read should be Texture B. Write to Texture A.

                    if (readTex === textures.a) {
                        readTex = textures.b; // We just wrote to B
                        writeFb = framebuffers.a;
                    } else {
                        readTex = textures.a; // We just wrote to A
                        writeFb = framebuffers.b;
                    }
                }

                // Final Result is in 'readTex'. Draw to screen.
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                const copyProg = programs['copy'];
                gl.useProgram(copyProg);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readTex);
                gl.uniform1i(gl.getUniformLocation(copyProg, 'u_tex'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Update Layer Breakdown Previews (Isolated)
                // For every node in path (except Image and Output), render Image -> Node -> Preview
                updateLayerPreviews(path);

            } else {
                // No valid path, just draw image
                const copyProg = programs['copy'];
                gl.useProgram(copyProg);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
                gl.uniform1i(gl.getUniformLocation(copyProg, 'u_tex'), 0);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                // Clear previews
                document.getElementById('layerGrid').innerHTML = '';
            }

            // Update Overlay Original
            const ovCanvas = document.getElementById('overlayCanvas');
            if (sourceImage && (ovCanvas.width !== sourceImage.width)) {
                ovCanvas.width = sourceImage.width;
                ovCanvas.height = sourceImage.height;
                ovCanvas.getContext('2d').drawImage(sourceImage, 0, 0);
            }

            document.getElementById('loading').style.display = 'none';
            needsRender = false;
        }

        function findPath(start, end) {
            // BFS to find path
            let queue = [[start]];
            let visited = new Set();

            while (queue.length > 0) {
                let path = queue.shift();
                let node = path[path.length - 1];

                if (node === end) return path;

                // Get neighbors (nodes connected to outputs of 'node')
                let conns = graphState.connections.filter(c => c.from === node.id);
                for (let c of conns) {
                    let next = graphState.nodes.find(n => n.id === c.to);
                    if (next && !visited.has(next.id)) {
                        visited.add(next.id);
                        let newPath = [...path, next];
                        queue.push(newPath);
                    }
                }
            }
            return [];
        }

        function getShaderForNode(type) {
            if (type === 'noise') return 'noise-layer';
            if (type === 'chroma') return 'chroma';
            if (type === 'adjustments') return 'adjust';
            if (type === 'dither') return 'dither';
            if (type === 'corruption') return 'corruption';
            if (type === 'cell') return 'cell';
            if (type === 'halftone') return 'halftone';
            if (type === 'bilateral') return 'bilateral';
            return 'copy';
        }

        function bindUniforms(prog, data, type) {
            // Helper to set uniform
            const set = (loc, val) => {
                if (Array.isArray(val)) gl.uniform1fv(loc, new Float32Array(val));
                else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
                else gl.uniform1f(loc, val);
            };

            // Map generic data keys to uniform names based on shader definitions
            // This is a bit manual, mapping the UI fields to GLSL uniforms

            // Common Image Res
            gl.uniform2f(gl.getUniformLocation(prog, 'u_origRes'), sourceImage.width, sourceImage.height);

            if (type === 'noise-layer') {
                gl.uniform1i(gl.getUniformLocation(prog, 'u_type'), data.noiseType);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_seed'), 123.45); // Fixed seed for now
                gl.uniform1f(gl.getUniformLocation(prog, 'u_scale'), data.noiseSize);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_blurAmt'), data.blurriness);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_mode'), data.blendMode);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_opacity'), data.opacity);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_str'), data.strength);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_satStr'), data.satStrength);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_satImp'), data.satPerNoise);

                gl.uniform1i(gl.getUniformLocation(prog, 'u_useS'), data.enableShadows);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sth'), data.shadowThreshold);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sfa'), data.shadowFade);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_useH'), data.enableHighlights);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hth'), data.highlightThreshold);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hfa'), data.highlightFade);

                gl.uniform1i(gl.getUniformLocation(prog, 'u_ignA'), data.ignoreAlphaToggle);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_ignAstr'), data.ignoreAlphaStrength);
            }
            else if (type === 'adjust') {
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bright'), data.brightness);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_cont'), data.contrast);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sat'), data.saturationAdj);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_warmth'), data.warmth);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sharp'), data.sharpen);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_step'), 1.0 / canvasWidth, 1.0 / canvasHeight);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hdrTol'), data.hdrTolerance);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hdrAmt'), data.hdrAmount);
            }
            else if (type === 'chroma') {
                gl.uniform1f(gl.getUniformLocation(prog, 'u_amt'), data.aberrationAmount);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_blur'), data.aberrationBlur);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_center'), 0.5, 0.5); // Center of UV
                gl.uniform1f(gl.getUniformLocation(prog, 'u_radius'), data.caRadius * 0.001); // Scale to UV
                gl.uniform1f(gl.getUniformLocation(prog, 'u_falloff'), data.caFalloff * 0.001);
            }
            else if (type === 'dither') {
                gl.uniform1i(gl.getUniformLocation(prog, 'u_type'), data.ditherType);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bitDepth'), data.ditherBitDepth);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_paletteSize'), data.ditherPaletteSize);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_str'), data.ditherStrength / 100.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_scale'), data.ditherScale);
            }
            else if (type === 'corruption') {
                gl.uniform1i(gl.getUniformLocation(prog, 'u_algo'), data.corruptionAlgorithm);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_iter'), data.corruptionIterations);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_scale'), data.corruptionResScale);
            }
            else if (type === 'cell') {
                gl.uniform1f(gl.getUniformLocation(prog, 'u_levels'), data.cellLevels);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bias'), data.cellBias);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_gamma'), data.cellGamma);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_qMode'), data.cellQuantMode);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_edgeMethod'), data.cellEdgeMethod);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_edgeStr'), data.cellEdgeStr);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_edgeThick'), data.cellEdgeThick);
                // u_colorPreserve handled in logic, needs bool uniform -> int
                gl.uniform1i(gl.getUniformLocation(prog, 'u_colorPreserve'), data.cellColorPreserve ? 1 : 0);
            }
            else if (type === 'halftone') {
                gl.uniform1f(gl.getUniformLocation(prog, 'u_size'), data.halftoneSize);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_str'), data.halftoneIntensity);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_pat'), data.halftonePattern);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_cMode'), data.halftoneColorMode);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_gray'), data.halftoneGray ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_invert'), data.halftoneInvert ? 1 : 0);
            }
            else if (type === 'bilateral') {
                gl.uniform1f(gl.getUniformLocation(prog, 'u_rad'), data.bilateralRadius);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_cSig'), data.bilateralColorSig);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sSig'), data.bilateralSpatialSig);
            }
        }

        function updateLayerPreviews(path) {
            const grid = document.getElementById('layerGrid');
            // Rebuild grid if count differs
            const existing = Array.from(grid.children);
            if (existing.length !== path.length - 2) { // Exclude Input & Output
                grid.innerHTML = '';
                path.forEach((node, idx) => {
                    if (node.type === 'image' || node.type === 'output') return;
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.dataset.id = node.id;
                    item.innerHTML = `<div class="layer-title">${NODE_TYPES[node.type].title}</div><canvas class="layer-canvas"></canvas>`;
                    item.onclick = () => selectNode(node.id);
                    grid.appendChild(item);
                });
            }

            // Render individual previews
            let readTex = sourceTexture;
            // We render Source -> Node -> Texture -> Preview Canvas

            // Temp small framebuffer for previews
            let pvFb = framebuffers.a;
            let pvTex = textures.a;

            for (let i = 1; i < path.length; i++) {
                const node = path[i];
                if (node.type === 'output') break;

                const domEl = grid.querySelector(`.layer-item[data-id="${node.id}"] canvas`);
                if (!domEl) continue;

                const progName = getShaderForNode(node.type);
                const prog = programs[progName];

                gl.useProgram(prog);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readTex); // Always source from Image? No, prompt says "isolated... applied to the original".
                // Re-read prompt: "Ensure that each 'Layer Breakdown' preview ONLY displays isolated changes in the respective layer, applied to the original image"
                // So readTex is ALWAYS sourceTexture for previews?
                // Let's implement that: Each preview is Original -> Node.
                gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_res'), canvasWidth, canvasHeight);

                bindUniforms(prog, node.data, node.type);

                // Render to small texture (canvas size of preview)
                if (domEl.width !== 100 || domEl.height !== 100) {
                    domEl.width = 100;
                    domEl.height = 100;
                    // Create texture for this preview if needed, or just render to canvas directly?
                    // WebGL can't render to 2d canvas directly. Need FBO.
                }

                // Actually, let's just render to a small 100x100 texture attached to 'pvFb'
                // But pvFb was sized to full canvas.
                // Optimization: Since previews are small, we can resize viewport.

                gl.bindFramebuffer(gl.FRAMEBUFFER, pvFb);
                gl.viewport(0, 0, 100, 100);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Copy pvTex to domEl via readPixels or draw to screen?
                // We can just re-use a small texture logic, but for speed:
                // Let's assume we can render directly to a small offscreen texture.
                // But creating textures per frame is bad.
                // Simple approach: readPixels.
                let pixels = new Uint8Array(100 * 100 * 4);
                gl.readPixels(0, 0, 100, 100, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                const ctx = domEl.getContext('2d');
                const imgData = ctx.createImageData(100, 100);
                imgData.data.set(pixels);
                ctx.putImageData(imgData, 0, 0);
            }

            // Restore FB
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }


        // --- GRAPH UI LOGIC ---

        function addNode(type, x, y) {
            const id = graphState.nextId++;
            // Default Data
            let data = {};
            const def = NODE_TYPES[type];
            if (def) {
                def.controls.forEach(c => {
                    if (c.items) c.items.forEach(i => data[i.id] = i.val);
                    else data[c.id] = c.val;
                });
            }

            const node = {
                id, type, x, y, data,
                inputs: type === 'image' ? 0 : 1,
                outputs: type === 'output' ? 0 : 1
            };

            graphState.nodes.push(node);
            renderNodeDOM(node);
            if (type !== 'image' && type !== 'output') {
                updateLayerPreviews([]); // Trigger grid update
            }
            return node;
        }

        function removeNode(id) {
            graphState.nodes = graphState.nodes.filter(n => n.id !== id);
            graphState.connections = graphState.connections.filter(c => c.from !== id && c.to !== id);
            document.getElementById(`node-${id}`).remove();
            // Remove SVG lines
            renderConnections();
            if (graphState.selectedNodeId === id) deselectNode();
            needsRender = true;
            updateLayerPreviews([]);
        }

        function renderNodeDOM(node) {
            const el = document.createElement('div');
            el.className = 'node';
            el.id = `node-${node.id}`;
            el.dataset.type = node.type;
            el.style.left = `${node.x}px`;
            el.style.top = `${node.y}px`;

            let title = node.type.toUpperCase();
            if (NODE_TYPES[node.type]) title = NODE_TYPES[node.type].title;

            let html = `<div class="node-header"><span>${title}</span>`;
            if (node.type !== 'image' && node.type !== 'output') {
                html += `<div class="node-delete" onclick="confirmDeleteNode(${node.id})">Ã—</div>`;
            }
            html += `</div><div class="node-body">`;

            if (node.type !== 'image') html += `<div class="socket input" onmousedown="startConn(event, ${node.id}, 'input')"></div>`;
            if (node.type !== 'output') html += `<div class="socket output" onmousedown="startConn(event, ${node.id}, 'output')"></div>`;

            html += `</div>`;
            el.innerHTML = html;

            // Selection & Drag
            el.onmousedown = (e) => {
                if (e.target.classList.contains('socket') || e.target.classList.contains('node-delete')) return;
                e.stopPropagation();
                selectNode(node.id);
                startDragNode(e, node.id);
            };

            document.getElementById('graphContent').appendChild(el);
        }

        function selectNode(id) {
            if (graphState.selectedNodeId) {
                const prev = document.getElementById(`node-${graphState.selectedNodeId}`);
                if (prev) prev.classList.remove('selected');
            }
            graphState.selectedNodeId = id;
            const curr = document.getElementById(`node-${id}`);
            if (curr) curr.classList.add('selected');

            // Populate Controls
            populateControls(id);
        }

        function deselectNode() {
            if (graphState.selectedNodeId) {
                const prev = document.getElementById(`node-${graphState.selectedNodeId}`);
                if (prev) prev.classList.remove('selected');
                graphState.selectedNodeId = null;
                document.getElementById('dynamic-controls').innerHTML = '<div class="empty-state">Select a node to edit controls</div>';
            }
        }

        function populateControls(id) {
            const node = graphState.nodes.find(n => n.id === id);
            if (!node) return;

            const container = document.getElementById('dynamic-controls');
            container.innerHTML = '';

            const def = NODE_TYPES[node.type];
            if (!def) return;

            def.controls.forEach(group => {
                const details = document.createElement('details');
                if (group.type !== 'group') details.open = true;

                const summary = document.createElement('summary');
                summary.textContent = group.title || group.label;
                details.appendChild(summary);

                const items = group.items || [group];
                items.forEach(item => {
                    const row = document.createElement('div');
                    row.className = 'control-row';

                    if (item.type === 'range') {
                        row.innerHTML = `
<label>${item.label}</label>
<input type="range" min="${item.min}" max="${item.max}" step="${item.step || 1}" value="${node.data[item.id]}" data-key="${item.id}">
<input type="text" class="control-value" value="${node.data[item.id]}" readonly>
`;
                        const range = row.querySelector('input[type=range]');
                        range.oninput = (e) => {
                            node.data[item.id] = parseFloat(e.target.value);
                            row.querySelector('.control-value').value = node.data[item.id];
                            needsRender = true;
                        };
                    } else if (item.type === 'select') {
                        let opts = item.opts.map((o, i) => `<option value="${i}">${o}</option>`).join('');
                        row.innerHTML = `
<label>${item.label}</label>
<select class="control-value" data-key="${item.id}">${opts}</select>
`;
                        const sel = row.querySelector('select');
                        sel.value = node.data[item.id];
                        sel.onchange = (e) => {
                            node.data[item.id] = parseInt(e.target.value);
                            needsRender = true;
                        };
                    } else if (item.type === 'check') {
                        row.innerHTML = `
<label>${item.label}</label>
<input type="checkbox" data-key="${item.id}" ${node.data[item.id] ? 'checked' : ''}>
`;
                        const chk = row.querySelector('input');
                        chk.onchange = (e) => {
                            node.data[item.id] = e.target.checked;
                            needsRender = true;
                        };
                    } else if (item.type === 'action') {
                        row.innerHTML = `<button class="ui-btn" style="flex:1; font-size:10px;">${item.label}</button>`;
                        row.querySelector('button').onclick = () => {
                            if (item.id === 'resetCenterBtn') {
                                // Logic handled in UI, reset data if needed
                                alert("Center reset (visual only for graph)");
                            }
                        };
                    }
                    details.appendChild(row);
                });
                container.appendChild(details);
            });
        }

        // --- GRAPH INTERACTION ---

        const graphWrapper = document.getElementById('graphWrapper');
        const graphContent = document.getElementById('graphContent');
        const svgLayer = document.getElementById('connections-layer');

        graphWrapper.addEventListener('mousedown', (e) => {
            if (e.target === graphWrapper || e.target === graphContent || e.target === svgLayer) {
                deselectNode();
                startDragGraph(e);
            }
        });

        graphWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.05;
            const oldScale = graphState.scale;
            if (e.deltaY < 0) graphState.scale += zoomSpeed;
            else graphState.scale -= zoomSpeed;
            graphState.scale = Math.max(0.1, Math.min(graphState.scale, 3));

            // Zoom towards mouse (simplified: zoom center)
            // Implementing zoom-to-cursor requires offset math
            // For now, simple zoom:
            graphContent.style.transform = `translate(${graphState.offsetX}px, ${graphState.offsetY}px) scale(${graphState.scale})`;
        });

        function startDragGraph(e) {
            graphState.isDragging = true;
            graphState.dragTarget = 'graph';
            graphState.lastMouseX = e.clientX;
            graphState.lastMouseY = e.clientY;
        }

        function startDragNode(e, id) {
            graphState.isDragging = true;
            graphState.dragTarget = id;
            graphState.lastMouseX = e.clientX;
            graphState.lastMouseY = e.clientY;
        }

        window.addEventListener('mousemove', (e) => {
            if (!graphState.isDragging) return;
            const dx = e.clientX - graphState.lastMouseX;
            const dy = e.clientY - graphState.lastMouseY;

            if (graphState.dragTarget === 'graph') {
                graphState.offsetX += dx;
                graphState.offsetY += dy;
                graphContent.style.transform = `translate(${graphState.offsetX}px, ${graphState.offsetY}px) scale(${graphState.scale})`;
            } else {
                // Drag Node
                const node = graphState.nodes.find(n => n.id === graphState.dragTarget);
                if (node) {
                    node.x += dx;
                    node.y += dy;
                    const el = document.getElementById(`node-${node.id}`);
                    el.style.left = `${node.x}px`;
                    el.style.top = `${node.y}px`;
                    renderConnections();
                }
            }
            graphState.lastMouseX = e.clientX;
            graphState.lastMouseY = e.clientY;
        });

        window.addEventListener('mouseup', () => {
            graphState.isDragging = false;
        });

        // --- CONNECTIONS ---

        let tempLine = null;
        let connStart = null;

        function startConn(e, nodeId, type) {
            e.stopPropagation();
            if (type === 'input') return; // Can only start from output
            connStart = { nodeId, type };

            // Create SVG line following mouse
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLine.setAttribute('stroke', '#fff');
            tempLine.setAttribute('stroke-width', '2');
            tempLine.setAttribute('fill', 'none');
            tempLine.setAttribute('stroke-dasharray', '5,5');
            svgLayer.appendChild(tempLine);

            const moveHandler = (ev) => {
                const pt1 = getSocketPos(nodeId, 'output');
                // Mouse pos in graph coordinates
                const rect = graphWrapper.getBoundingClientRect();
                const mx = (ev.clientX - rect.left - graphState.offsetX) / graphState.scale;
                const my = (ev.clientY - rect.top - graphState.offsetY) / graphState.scale;
                tempLine.setAttribute('d', `M ${pt1.x} ${pt1.y} L ${mx} ${my}`);
            };

            const upHandler = (ev) => {
                window.removeEventListener('mousemove', moveHandler);
                window.removeEventListener('mouseup', upHandler);
                if (tempLine) tempLine.remove();

                // Check drop target
                const target = ev.target;
                if (target.classList.contains('input')) {
                    const endNodeEl = target.closest('.node');
                    const endNodeId = parseInt(endNodeEl.id.replace('node-', ''));

                    // Validate
                    if (endNodeId !== connStart.nodeId) {
                        // Remove existing connection to this input if any (single input only)
                        graphState.connections = graphState.connections.filter(c => c.to !== endNodeId);
                        graphState.connections.push({
                            id: Date.now(),
                            from: connStart.nodeId,
                            to: endNodeId
                        });
                        renderConnections();
                        needsRender = true;
                    }
                }
                connStart = null;
            };

            window.addEventListener('mousemove', moveHandler);
            window.addEventListener('mouseup', upHandler);
        }

        function getSocketPos(nodeId, type) {
            const el = document.getElementById(`node-${nodeId}`);
            const sock = el.querySelector(`.${type}`);
            const r = sock.getBoundingClientRect();
            const wr = graphWrapper.getBoundingClientRect();
            // We need position relative to graphContent (which is scaled & translated)
            // The visual position in SVG space
            const x = (r.left + r.width / 2 - wr.left - graphState.offsetX) / graphState.scale;
            const y = (r.top + r.height / 2 - wr.top - graphState.offsetY) / graphState.scale;
            return { x, y };
        }

        function renderConnections() {
            svgLayer.innerHTML = '';
            graphState.connections.forEach(c => {
                const p1 = getSocketPos(c.from, 'output');
                const p2 = getSocketPos(c.to, 'input');

                // Bezier
                const dx = Math.abs(p1.x - p2.x) * 0.5;
                const d = `M ${p1.x} ${p1.y} C ${p1.x + dx} ${p1.y}, ${p2.x - dx} ${p2.y}, ${p2.x} ${p2.y}`;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                path.setAttribute('class', 'connection');
                path.onclick = (e) => {
                    graphState.connections = graphState.connections.filter(x => x.id !== c.id);
                    renderConnections();
                    needsRender = true;
                };
                svgLayer.appendChild(path);
            });
        }

        // --- NODE MENU DRAG & DROP ---

        const nodeMenu = document.getElementById('node-menu');
        document.getElementById('node-menu-trigger').onclick = () => {
            nodeMenu.classList.toggle('show');
        };

        Object.keys(NODE_TYPES).forEach(key => {
            const item = document.createElement('div');
            item.className = 'menu-item';
            item.textContent = NODE_TYPES[key].title;
            item.draggable = true;
            item.ondragstart = (e) => {
                e.dataTransfer.setData('type', key);
            };
            nodeMenu.appendChild(item);
        });

        graphWrapper.addEventListener('dragover', (e) => e.preventDefault());
        graphWrapper.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('type');
            if (!type) return;

            const rect = graphWrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left - graphState.offsetX) / graphState.scale;
            const y = (e.clientY - rect.top - graphState.offsetY) / graphState.scale;

            addNode(type, x, y);
            nodeMenu.classList.remove('show');
        });


        // --- INITIALIZATION ---

        window.onload = () => {
            initWebGL();
            requestAnimationFrame(loop);

            // View Toggle
            document.getElementById('btn-view-graph').onclick = () => {
                document.getElementById('btn-view-graph').classList.add('active');
                document.getElementById('btn-view-preview').classList.remove('active');
                document.getElementById('view-graph').classList.add('active');
                document.getElementById('view-preview').classList.remove('active');
            };
            document.getElementById('btn-view-preview').onclick = () => {
                document.getElementById('btn-view-preview').classList.add('active');
                document.getElementById('btn-view-graph').classList.remove('active');
                document.getElementById('view-preview').classList.add('active');
                document.getElementById('view-graph').classList.remove('active');
                needsRender = true; // Ensure we update canvas if hidden
            };

            // File Upload
            document.getElementById('imageUpload').onchange = (e) => {
                const file = e.target.files[0];
                const img = new Image();
                img.onload = () => updateSourceTexture(img);
                img.src = URL.createObjectURL(file);
            };

            // Delete Modal
            window.confirmDeleteNode = (id) => {
                document.getElementById('deleteModal').classList.add('show');
                document.getElementById('confirmDelete').onclick = () => {
                    removeNode(id);
                    document.getElementById('deleteModal').classList.remove('show');
                };
                document.getElementById('cancelDelete').onclick = () => {
                    document.getElementById('deleteModal').classList.remove('show');
                };
            };

            // Compare Modal
            const compareModal = document.getElementById('compareModal');
            document.getElementById('compareBtn').onclick = () => {
                if (!sourceImage) return;
                compareModal.classList.add('show');
                // Render original
                const c1 = document.getElementById('compareOriginal');
                c1.width = sourceImage.width; c1.height = sourceImage.height;
                c1.getContext('2d').drawImage(sourceImage, 0, 0);

                // Render processed (capture current canvas)
                const c2 = document.getElementById('compareProcessed');
                c2.width = canvasWidth; c2.height = canvasHeight;
                c2.getContext('2d').drawImage(canvas, 0, 0);
            };
            document.getElementById('closeCompare').onclick = () => compareModal.classList.remove('show');

            // Export Logic
            document.getElementById('downloadBtn').onclick = () => {
                if (!sourceImage) return;
                const link = document.createElement('a');
                link.download = 'grain_output.png';
                link.href = canvas.toDataURL();
                link.click();
            };

            // Upscale Input Listener
            document.getElementById('upscaleInput').onchange = resizeCanvas;
        };

        function loop() {
            render();
            requestAnimationFrame(loop);
        }

    </script>
</body>

</html>