<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Digital Grain Studio ‚Äî GPU Accelerated</title><style>:root{--bg:#000;--fg:#fff;--panel-max:460px;--muted:#8c8c8c;--accent:#2a9df4;--border:rgba(255, 255, 255, 0.08);--layer-h:40px;--tab-bg:#1a1a1a;--tab-active:#2a9df4}*{box-sizing:border-box}body,html{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'Courier New',monospace}body{padding:16px;display:flex;gap:16px;align-items:flex-start;min-height:100vh}.container{display:flex;gap:16px;width:100%;height:100%}.controls-panel{flex:0 0 var(--panel-max);max-width:var(--panel-max);min-width:320px;padding-right:10px;overflow-y:auto;height:100%;scrollbar-width:thin;scrollbar-color:var(--muted) var(--bg);display:flex;flex-direction:column}.controls-panel h1{font-size:18px;margin:0 0 4px 0;text-align:center;letter-spacing:-.5px}.muted{color:var(--muted);font-size:12px;margin-bottom:12px;display:block;text-align:center}.tab-toggle-container{display:flex;gap:4px;margin:10px 0;background:#111;padding:4px;border:1px solid var(--border);border-radius:4px}.tab-btn{flex:1;padding:8px;font-size:11px;background:#1a1a1a;color:var(--muted);border:none;cursor:pointer;transition:all .2s}.tab-btn.active{background:var(--accent);color:#000}.tab-content{display:none;flex-direction:column;gap:10px}.tab-content.active{display:flex}.drag-layer{background:#111;border:1px solid var(--border);padding:8px 12px;margin-bottom:6px;cursor:grab;display:flex;justify-content:space-between;align-items:center;user-select:none;font-size:13px;border-radius:4px}.drag-layer:active{cursor:grabbing;background:#222;border-color:var(--accent)}.drag-layer.dragging{opacity:.5}.drag-handle{color:var(--muted);margin-right:10px}.drag-controls{display:flex;align-items:center;gap:10px}.drag-toggle{cursor:pointer;accent-color:var(--accent)}details{border:1px solid var(--border);margin-bottom:8px;padding:6px;border-radius:4px;background:#0a0a0a}summary{cursor:pointer;font-weight:700;margin:0 0 6px 0;outline:0;user-select:none;font-size:13px}summary:hover{color:var(--accent)}.control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;min-height:28px}.control-row label{flex:0 0 120px;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px}input[type=range]{flex:1;accent-color:var(--accent);cursor:pointer}.control-value{width:60px;padding:2px 4px;text-align:right;background:#000;color:var(--fg);border:1px solid var(--border);font-family:monospace;font-size:11px}select.control-value{flex:1;min-width:120px;padding:4px}.row-buttons{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}.palette-list{display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;padding:4px;border:1px solid var(--border);min-height:32px;background:#050505}.palette-color-item{display:flex;align-items:center;background:#1a1a1a;border:1px solid var(--border);padding:2px;gap:4px}.palette-color-item input[type=color]{width:24px;height:24px;padding:0;border:none;background:0 0;cursor:pointer}.remove-color-btn{background:0 0;border:none;color:#f55;cursor:pointer;font-size:14px;padding:0 4px;line-height:1}.remove-color-btn:hover{color:red;background:rgba(255,0,0,.1)}button{background:#111;color:var(--fg);border:1px solid var(--border);padding:8px 12px;cursor:pointer;font-family:monospace;font-size:12px;transition:all .2s}button:hover:not(:disabled){background:var(--accent);color:#000;border-color:var(--accent)}button:disabled{opacity:.5;cursor:not-allowed}button.small-btn{padding:4px 8px;font-size:10px}.preview-column{flex:1 1 auto;min-width:320px;display:flex;flex-direction:column;gap:12px;height:100%;overflow:hidden}.preview-top{display:flex;align-items:center;justify-content:space-between;gap:12px}.preview-container{position:relative;border:1px solid var(--border);background:repeating-linear-gradient(45deg,#111 0,#111 10px,#0e0e0e 10px,#0e0e0e 20px);overflow:hidden;flex:1;display:flex;align-items:center;justify-content:center;min-height:300px}canvas{display:block;width:100%;height:100%;object-fit:contain;box-shadow:0 0 20px rgba(0,0,0,.5)}.overlay-original{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:10;transition:opacity .5s ease}.overlay-original canvas{width:100%;height:100%;object-fit:contain;opacity:0;transition:opacity .5s ease}.overlay-original.show canvas{opacity:1}#caPin{width:12px;height:12px;background:var(--accent);border:2px solid #fff;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);cursor:crosshair;z-index:20;box-shadow:0 0 5px #000;display:none}#caPin.active{display:block}#caPin::after{content:'';position:absolute;top:50%;left:50%;width:40px;height:40px;border:1px dashed rgba(255,255,255,.3);transform:translate(-50%,-50%);border-radius:50%;pointer-events:none}.layer-preview-window{border:1px solid var(--border);background:#050505;padding:8px;height:160px;flex:0 0 160px;overflow:hidden}.layer-grid{display:flex;gap:4px;height:100%}.layer-item{border:1px solid var(--border);flex:1;display:flex;flex-direction:column;background:#000;cursor:pointer;transition:border-color .2s;position:relative;min-width:60px}.layer-item:hover{border-color:var(--muted)}.layer-item.active{border-color:var(--accent)}.layer-title{color:var(--muted);font-size:9px;text-transform:uppercase;text-align:center;padding-top:4px;height:24px;line-height:1.2;word-wrap:break-word;padding:2px}.layer-canvas{width:100%;flex:1;background:#111;border-top:1px solid #222}.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.9);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s;z-index:3000}.modal-overlay.show{opacity:1;pointer-events:auto}.modal{background:#111;border:1px solid var(--border);padding:20px;max-width:90vw;max-height:90vh;overflow:auto;box-shadow:0 0 50px rgba(0,0,0,.8)}#loading{position:fixed;top:10px;right:10px;background:var(--accent);color:#000;padding:4px 8px;font-size:11px;font-weight:700;display:none;z-index:4000}.upscale-control{display:flex;align-items:center;gap:8px;font-size:11px;border:1px solid var(--border);padding:4px 8px;background:#0a0a0a;border-radius:4px}.upscale-input{width:40px;background:#000;border:1px solid var(--border);color:var(--fg);padding:2px;text-align:center;font-family:monospace}.lock-switch{display:flex;align-items:center;gap:6px;font-size:11px;cursor:pointer;user-select:none;margin-right:12px;border-right:1px solid var(--border);padding-right:12px}.lock-checkbox{accent-color:var(--accent);cursor:pointer}.json-btn{background:#222;border:1px solid var(--border);color:var(--accent);font-size:10px;padding:4px 8px;cursor:pointer;margin-top:4px;width:100%;text-align:center}.json-btn:hover{background:var(--accent);color:#000}@media (max-width:900px){body{padding:10px;flex-direction:column}.container{flex-direction:column}.controls-panel{width:100%;max-width:none;flex:none;height:auto;max-height:40vh}.preview-column{width:100%;height:50vh}}</style></head><body><div id="export-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:3999;flex-direction:column;align-items:center;justify-content:center;color:#fff;font-size:1.2em"><div id="export-status">PROCESSING 1/100...</div><button id="stopExportBtn" style="margin-top:20px;padding:10px 20px;background:#f55;color:#fff;border:1px solid #f77;font-size:.8em">CANCEL EXPORT</button></div><div id="loading">PROCESSING GPU...</div><div class="container"><div class="controls-panel"><h1>DIGITAL GRAIN [GPU]</h1><span class="muted">WebGL2 Accelerated Pipeline</span><div style="margin:10px 0;border:1px dashed var(--border);padding:10px;text-align:center"><div style="display:grid;grid-template-columns:1fr 1fr;gap:8px"><label for="imageUpload" style="cursor:pointer;display:block;background:#1a1a1a;padding:8px;border-radius:4px;border:1px solid var(--border)"><span style="font-size:24px;display:block;margin-bottom:5px">üìÇ</span> <span style="font-size:12px;color:var(--accent)">LOAD IMAGE</span></label> <label id="loadFolderBtn" style="cursor:pointer;display:block;background:#1a1a1a;padding:8px;border-radius:4px;border:1px solid var(--border)"><span style="font-size:24px;display:block;margin-bottom:5px">üóÇÔ∏è</span> <span style="font-size:12px;color:var(--accent)">LOAD FOLDER</span></label></div><input id="imageUpload" type="file" accept="image/*" style="display:none"><div id="image-navigation" style="display:none;margin-top:10px;flex-direction:column;align-items:center;justify-content:center;gap:10px"><div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center"><button id="prevImageBtn" class="small-btn">‚óÑ Prev</button> <span id="imageCounter" style="font-size:12px;color:var(--muted);min-width:80px;text-align:center">Image 1 of 1</span> <button id="nextImageBtn" class="small-btn">Next ‚ñ∫</button></div><input type="range" id="imageScrubber" style="width:80%;accent-color:var(--accent)" min="0" max="0" value="0"><div style="display:flex;align-items:center;gap:10px;margin-top:8px"><button id="playBtn" class="small-btn">PLAY ‚ñ∫</button> <input type="number" id="playFps" class="upscale-input" value="10" style="width:50px"> <span style="font-size:11px;color:var(--muted)">FPS</span> <span id="actualFps" style="font-size:11px;color:var(--accent);min-width:90px">(Actual: --)</span></div><div style="display:flex;align-items:center;gap:10px;margin-top:8px;border-top:1px solid var(--border);padding-top:8px;width:100%;justify-content:center"><label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer"><input type="checkbox" id="keepFolderStructureToggle" style="accent-color:var(--accent)"> <span>KEEP FOLDER STRUCTURE ON EXPORT</span></label></div></div><div style="background:rgba(255,255,255,.05);padding:8px;margin-top:10px;border-radius:4px;border:1px solid var(--border)"><div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px"><label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer;color:var(--muted)" title="Save the original image inside the JSON file"><input type="checkbox" id="jsonIncludeImage" checked="checked" style="accent-color:var(--accent)"> <span>Include Image</span></label> <button class="json-btn" id="downloadJsonBtn" style="padding:4px 12px;font-size:11px;width:auto">SAVE .JSON</button></div><div style="display:flex;align-items:center;gap:5px"><select id="jsonImportMode" style="background:var(--bg);color:var(--text);border:1px solid var(--border);font-size:10px;padding:4px;border-radius:3px;outline:0;width:90px"><option value="both" selected="selected">Import All</option><option value="settings">Settings Only</option><option value="image">Image Only</option></select> <button class="json-btn" id="uploadJsonTrigger" style="padding:4px 12px;font-size:11px;flex-grow:1">LOAD .JSON</button></div><input id="jsonUpload" type="file" accept=".json" style="display:none"></div></div><div class="tab-toggle-container"><button class="tab-btn active" data-tab="tab-controls">Controls</button> <button class="tab-btn" data-tab="tab-layers">Render Layer Order</button></div><div id="tab-controls" class="tab-content active"><details open><summary>System & Performance</summary><div class="control-row" title="If enabled, removes the 2048px preview limit. Requires a powerful GPU for large images."><label>High Quality Preview</label> <input id="clampPreviewToggle" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Full Res</label></div><div class="control-row" style="font-size:9px;color:var(--muted);border-top:1px solid var(--border);padding-top:8px;margin-top:8px"><span>MAX GPU TEXTURE:</span> <span id="gpuMaxRes" style="margin-left:auto;font-family:monospace;color:var(--accent)">QUERYING...</span></div></details><details open><summary>Noise <input id="noiseEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Noise Strength</label> <input id="strength" type="range" min="0" max="150" step="0.1" value="40"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Noise Type</label> <select id="noiseType" class="control-value"><option value="1" selected="selected">Grayscale</option><option value="0">Color</option><option value="3">Blue Noise</option><option value="4">Blue Noise (Color)</option><option value="2">Blend (Sat)</option><option value="5">Perlin (Cloudy)</option><option value="6">Worley (Cellular)</option><option value="7">Scanlines</option><option value="8">Speckle (Dust)</option><option value="9">Glitch</option><option value="10">Anisotropic (Fiber)</option><option value="11">Voronoi Mosaic</option><option value="12">Crosshatch</option></select></div><div class="control-row"><label>Sat Strength</label> <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sat Impact</label> <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div id="noiseParamsHeader" style="display:none;border-top:1px dashed var(--border);margin:8px 0;padding-top:8px;font-size:10px;color:var(--accent);opacity:.8;text-transform:uppercase;letter-spacing:1px">Advanced Settings</div><div id="noiseParamRowA" class="control-row" style="display:none"><label id="noiseLabelA">Param A</label> <input id="noiseParamA" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div id="noiseParamRowB" class="control-row" style="display:none"><label id="noiseLabelB">Param B</label> <input id="noiseParamB" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div id="noiseParamRowC" class="control-row" style="display:none"><label id="noiseLabelC">Param C</label> <input id="noiseParamC" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Scale (Size)</label> <input id="noiseSize" type="range" min="0" max="10" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Blurriness</label> <input id="blurriness" type="range" min="0" max="100" step="1" value="2"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Blend Mode</label> <select id="blendMode" class="control-value"><option value="0">Normal</option><option value="1" selected="selected">Overlay</option><option value="2">Screen</option><option value="3">Multiply</option><option value="4">Add</option><option value="5">Difference</option></select></div><div class="control-row"><label>Opacity</label> <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Luma Masking</label> <input id="noiseLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Color Exclusion</label> <input id="noiseColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="noiseExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="noiseExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="noiseColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="noiseColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Invert Mask</label> <input id="noiseInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div><div class="control-row"><label>Skin Protection</label> <input id="skinProtection" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Alpha Channel</summary><div class="control-row"><label>Ignore Alpha</label> <input id="ignoreAlphaToggle" type="checkbox" checked="checked"></div><div class="control-row"><label>Strength</label> <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Adjustments <input id="adjustEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Brightness</label> <input id="brightness" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast</label> <input id="contrast" type="range" min="-100" max="200" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Saturation</label> <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Warmth</label> <input id="warmth" type="range" min="-500" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpening</label> <input id="sharpen" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpen Threshold</label> <input id="sharpenThreshold" type="range" min="0" max="100" step="1" value="5"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="adjColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="adjExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="adjExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="adjColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="adjColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="adjLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="adjShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="adjShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="adjHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="adjHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:5px"></div><div class="control-row"><label>Invert Mask</label> <input id="adjInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div></details><details><summary>HDR Emulation <input id="hdrEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Tolerance</label> <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Amount</label> <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Chromatic Aberration <input id="caEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Amount</label> <input id="aberrationAmount" type="range" min="0" max="1500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Clear Radius</label> <input id="caRadius" type="range" min="0" max="1000" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Radius Falloff</label> <input id="caFalloff" type="range" min="0" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Blur</label> <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Zoom Blur</label> <input id="aberrationZoomBlur" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Link Falloff to Blur</label> <input id="caFalloffToBlur" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enabled</label></div><div style="text-align:right;margin-top:5px"><button id="resetCenterBtn" class="small-btn">RESET CENTER</button></div></details><details><summary>Blur</summary><div class="control-row"><label>Enable</label> <input id="blurEnable" type="checkbox" checked="checked"></div><div class="control-row"><label>Amount</label> <input id="blurAmount" type="range" min="0" max="1000" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Type</label> <select id="blurType" class="control-value"><option value="0" selected="selected">Gaussian</option><option value="1">Box</option><option value="2">Motion</option></select></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="blurColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="blurTargetColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="blurTargetColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="blurColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="blurColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="blurLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="blurShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="blurShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="blurHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="blurHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:5px"></div><div class="control-row"><label>Invert Mask</label> <input id="blurInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div></details><details><summary>Dithering</summary><div class="control-row"><label>Enable</label> <input id="ditherEnable" type="checkbox"></div><div class="control-row"><label>Bit Depth</label> <input id="ditherBitDepth" type="range" min="1" max="8" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Palette Size</label> <input id="ditherPaletteSize" type="range" min="2" max="256" step="1" value="16"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Dither Strength</label> <input id="ditherStrength" type="range" min="0" max="1000" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Scale</label> <input id="ditherScale" type="range" min="1" max="16" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Dither Type</label> <select id="ditherType" class="control-value"><option value="0" selected="selected">Bayer (Ordered)</option><option value="1">Noise (Random)</option></select></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="ditherColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="ditherExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="ditherExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="ditherColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="ditherColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="ditherLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="ditherShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="ditherShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="ditherHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="ditherHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:5px"></div><div class="control-row"><label>Invert Mask</label> <input id="ditherInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div><div class="control-row"><label>Soft Mask Depth</label> <input id="ditherSoftMask" type="checkbox" checked="checked"> <label style="color:var(--muted);margin-left:auto">Enabled</label></div></details><details><summary>Corruption</summary><div class="control-row"><label>Enable</label> <input id="corruptionEnable" type="checkbox"></div><div class="control-row"><label>Iterations</label> <input id="corruptionIterations" type="range" min="0" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Algorithm</label> <select id="corruptionAlgorithm" class="control-value"><option value="0" selected="selected">JPEG Blocks</option><option value="1">Pixelation</option><option value="2">Color Bleed</option></select></div><div class="control-row"><label>Resolution Scale</label> <input id="corruptionResScale" type="range" min="1" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Cell Shading</summary><div class="control-row"><label>Enable</label> <input id="cellEnable" type="checkbox"></div><div class="control-row"><label>Shading Levels</label> <input id="cellLevels" type="range" min="2" max="12" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast Bias</label> <input id="cellBias" type="range" min="-1" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Gamma Curve</label> <input id="cellGamma" type="range" min="0.5" max="2.2" step="0.01" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Quantize Mode</label> <select id="cellQuantMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option><option value="2">HSV Value</option></select></div><div class="control-row"><label>Band Mapping</label> <select id="cellBandMap" class="control-value"><option value="0" selected="selected">Linear</option><option value="1">Smoothstep</option><option value="2">Posterize</option></select></div><div style="height:5px"></div><div class="control-row"><label>Edges Enable</label> <input id="cellEdgeEnable" type="checkbox"></div><div class="control-row"><label>Edge Strength</label> <input id="cellEdgeStr" type="range" min="0" max="5" step="0.01" value="0.8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Thickness</label> <input id="cellEdgeThick" type="range" min="0.5" max="10" step="0.1" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Method</label> <select id="cellEdgeMethod" class="control-value"><option value="0">None</option><option value="1" selected="selected">Sobel</option><option value="2">Laplacian</option></select></div><div class="control-row"><label>Color Preserve</label> <input id="cellColorPreserve" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Quant Luma Only</label></div></details><details><summary>Halftoning</summary><div class="control-row"><label>Enable</label> <input id="halftoneEnable" type="checkbox"></div><div class="control-row"><label>Dot Size</label> <input id="halftoneSize" type="range" min="1" max="12" step="0.1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Intensity</label> <input id="halftoneIntensity" type="range" min="0" max="1" step="0.01" value="0.8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpness</label> <input id="halftoneSharpness" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Pattern Type</label> <select id="halftonePattern" class="control-value"><option value="0" selected="selected">Circular</option><option value="1">Line</option><option value="2">Cross</option><option value="3">Diamond</option></select></div><div class="control-row"><label>Color Mode</label> <select id="halftoneColorMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option><option value="2">CMY</option><option value="3">CMYK</option></select></div><div class="control-row"><label>Sampling</label> <select id="halftoneSample" class="control-value"><option value="0" selected="selected">Center</option><option value="1">Average</option><option value="2">Rotated Grid</option></select></div><div class="control-row"><label>Grayscale</label> <input id="halftoneGray" type="checkbox"></div><div class="control-row"><label>Screen Lock</label> <input id="halftoneScreenLock" type="checkbox" checked="checked"></div><div class="control-row"><label>Invert</label> <input id="halftoneInvert" type="checkbox"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="halftoneColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div><div style="display:flex;align-items:center;gap:5px"><input id="halftoneExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="halftoneExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div></div><div class="control-row"><label>Color Tolerance</label> <input id="halftoneColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="halftoneColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="halftoneLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="halftoneShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="halftoneShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="halftoneHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="halftoneHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Bilateral Filter</summary><div class="control-row"><label>Enable</label> <input id="bilateralEnable" type="checkbox"></div><div class="control-row"><label>Radius</label> <input id="bilateralRadius" type="range" min="1" max="30" step="1" value="5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Sigma</label> <input id="bilateralColorSig" type="range" min="0.01" max="1.0" step="0.01" value="0.1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Spatial Sigma</label> <input id="bilateralSpatialSig" type="range" min="0.5" max="15.0" step="0.1" value="2.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Iterations</label> <input id="bilateralIter" type="range" min="1" max="20" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>High Precision</label> <input id="bilateralHighPrec" type="checkbox" checked="checked"></div><div class="control-row"><label>Kernel Type</label> <select id="bilateralKernel" class="control-value"><option value="0" selected="selected">Gaussian</option><option value="1">Box</option></select></div><div class="control-row"><label>Edge Preservation</label> <select id="bilateralEdgeMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option></select></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="bilateralColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label> <input id="bilateralExcludeColor" type="color" value="#000000" style="width:60px;height:24px"></div><div class="control-row"><label>Color Tolerance</label> <input id="bilateralColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="bilateralColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="bilateralLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="bilateralShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="bilateralShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="bilateralHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="bilateralHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Palette Reconstructor</summary><div class="control-row"><label>Enable</label> <input id="paletteEnable" type="checkbox"></div><div class="control-row"><label>Global Blend</label> <input id="paletteBlend" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div><div class="row-buttons" style="margin-top:5px"><button id="addPaletteColor" class="small-btn">+ ADD COLOR</button> <button id="pickPaletteColorBtn" class="small-btn eyedropper-btn" data-target="pickPaletteColor" title="Pick from canvas">üñåÔ∏è PICK FROM CANVAS</button> <button id="randomPalette" class="small-btn">RANDOMIZE</button> <button id="clearPalette" class="small-btn">CLEAR</button> <button id="extractPalette" class="small-btn">Upload Palette Image</button> <input type="file" id="paletteImageUpload" style="display:none" accept="image/*"></div><div class="control-row"><label>Smoothing Type</label> <select id="paletteSmoothingType"><option value="0">Box</option><option value="1">Gaussian</option></select></div><div class="control-row"><label>Palette Smoothing</label> <input id="paletteSmoothing" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row" style="margin-top:5px"><label>Extract Count</label> <input id="extractCount" type="range" min="2" max="200" value="8" step="1"> <input type="text" class="control-value" readonly="readonly"></div><div id="paletteList" class="palette-list"></div></details><details id="edgeDetails"><summary>Edge Effects</summary><div class="control-row"><label>Enable</label> <input id="edgeEnable" type="checkbox"></div><div class="control-row"><label>Global Blend</label> <input id="edgeBlend" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Mode</label> <select id="edgeMode"><option value="0">Edge Overlay</option><option value="1">Saturation Mask</option></select></div><div class="control-row"><label>Edge Strength</label> <input id="edgeStrength" type="range" min="0" max="1000" step="1" value="500"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Tolerance</label> <input id="edgeTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div id="edgeSatControls" style="display:none;border-top:1px dashed #333;padding-top:10px;margin-top:10px"><div class="control-row"><label>Foreground Sat</label> <input id="edgeFgSat" type="range" min="0" max="200" step="1" value="150"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Background Sat</label> <input id="edgeBgSat" type="range" min="0" max="200" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Bloom Spread</label> <input id="edgeBloom" type="range" min="0" max="50" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Bloom Smoothness</label> <input id="edgeSmooth" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div></div></details><div class="row-buttons"><button id="downloadBtn" disabled="disabled">DOWNLOAD FULL RES</button> <button id="downloadCurrentBtn" disabled="disabled">DOWNLOAD CURRENT</button> <button id="compareBtn" disabled="disabled">COMPARE / EXPORT</button></div></div><div id="tab-layers" class="tab-content"><div style="font-size:11px;color:var(--muted);margin-bottom:10px">Drag to reorder render pipeline:</div><div id="layer-drag-list"></div></div></div><div class="preview-column"><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Main Preview</h3><div style="display:flex;align-items:center"><div class="upscale-control" style="margin-right:8px" title="Zoom level when hovering over preview. Press TAB to lock."><span style="color:var(--muted);font-size:9px;margin-right:8px;border-right:1px solid var(--border);padding-right:8px">TAB TO LOCK</span> <span>HOVER ZOOM</span> <input id="hoverZoomSlider" type="range" min="1" max="8" step="0.1" value="1" style="width:60px;accent-color:var(--accent)"> <span id="hoverZoomValue" style="min-width:28px;text-align:center">1x</span></div><button id="fullscreenPreviewBtn" class="small-btn" style="margin-right:8px;padding:4px 8px;font-size:9px" title="Open detached fullscreen preview">POP-OUT</button> <button id="lensToggleBtn" class="small-btn" style="margin-right:12px;padding:4px 8px;font-size:9px" title="Toggle between Full zoom and Lens zoom">FULL</button> <label class="lock-switch" title="Lock Preview to prevent Original Image overlay"><input type="checkbox" id="previewLock" class="lock-checkbox"> <span>LOCK PREVIEW</span></label><div class="upscale-control"><span>UPSCALE (x)</span> <input id="upscaleInput" class="upscale-input" type="text" value="1" min="1" max="10"></div></div></div><div class="preview-container" id="previewContainer"><canvas id="displayCanvas"></canvas><div id="caPin"></div><div class="overlay-original" id="overlayOriginal"><canvas id="overlayCanvas"></canvas></div><div id="zoomResIndicator" style="position:absolute;bottom:8px;left:8px;background:rgba(0,0,0,.8);color:#0f0;padding:4px 8px;font-size:10px;font-family:monospace;z-index:20;display:none;border:1px solid #0f0"></div><div id="zoomLens" style="position:absolute;width:180px;height:180px;border-radius:50%;border:2px solid var(--accent);overflow:hidden;pointer-events:none;display:none;z-index:25;box-shadow:0 0 20px rgba(0,0,0,.8)"><canvas id="lensCanvas" style="position:absolute;top:0;left:0"></canvas></div></div><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Layer Breakdown</h3><div style="font-size:10px;color:var(--muted)">Click to view</div></div><div class="layer-preview-window"><div class="layer-grid" id="layerGrid"></div></div></div></div><div id="compareModal" class="modal-overlay"><div class="modal"><h2 style="margin-top:0">Comparison & Export</h2><div style="display:flex;gap:20px;margin-bottom:20px;justify-content:center;flex-wrap:wrap"><div><div class="muted">Original</div><canvas id="compareOriginal" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div><div><div class="muted">Processed</div><canvas id="compareProcessed" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div></div><div style="text-align:center;margin-bottom:15px;background:rgba(0,0,0,.3);padding:10px;border:1px solid #333"><div style="font-size:10px;color:var(--muted);text-transform:uppercase;margin-bottom:5px">Rendering Technical Data</div><div id="exportInfo" style="font-family:monospace;color:#0f0;font-size:11px">Requested: -- x -- | Actual: -- x -- (Scale: 1.0)</div></div><div style="text-align:center;display:flex;gap:10px;justify-content:center;flex-wrap:wrap"><button id="exportSideBySide">Export Side-by-Side</button> <button id="exportStacked">Export Stacked</button> <button id="closeCompare">Close</button></div></div></div><script type="x-shader/x-vertex" id="vs-quad">#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-adjust">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform float u_sharpThresh;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Balanced Sharpening (USM Approximation)
    if (u_sharp > 0.0) {
        vec3 blurred = (
            texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2( 0.0,      -u_step.y)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2( u_step.x, -u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2(-u_step.x,  0.0)).rgb * 0.125 +
            texture(u_tex, v_uv).rgb * 0.25 +
            texture(u_tex, v_uv + vec2( u_step.x,  0.0)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2( 0.0,       u_step.y)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2( u_step.x,  u_step.y)).rgb * 0.0625
        );
        vec3 diff = rgb - blurred;
        // u_sharpThresh 0-100. 
        // A common threshold range for USM is 0.001 to 0.1 in luma. 
        // Let's use a scale that makes the slider feel responsive.
        float th = (u_sharpThresh / 100.0) * 0.1; 
        float factor = smoothstep(th, th * 1.5 + 0.001, length(diff));
        rgb += diff * (u_sharp / 15.0) * factor;
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}</script><script type="x-shader/x-fragment" id="fs-mask">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; 
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.299,0.587,0.114));
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-colorMask">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;
uniform float u_tolerance;
uniform float u_fade;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float d = distance(c.rgb, u_targetColor);
    float mask = 1.0 - smoothstep(u_tolerance, u_tolerance + u_fade + 0.001, d);
    outColor = vec4(mask, mask, mask, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-noise">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; 
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; 
uniform float u_paramA;
uniform float u_paramB;
uniform float u_paramC;

float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec2 hash22(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

// Interleaved Gradient Noise
float IGN(vec2 p) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(p, magic.xy)));
}

float getBlue(vec2 p) {
    float white = IGN(p);
    float low = (IGN(p + vec2(1.0, 0.0)) + IGN(p - vec2(1.0, 0.0)) + IGN(p + vec2(0.0, 1.0)) + IGN(p - vec2(0.0, 1.0))) * 0.25;
    return clamp(white - low + 0.5, 0.0, 1.0); 
}

// Perlin Noise (Simple Value Noise variant for better GPU stability)
float perlin(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash12(i);
    float b = hash12(i + vec2(1.0, 0.0));
    float c = hash12(i + vec2(0.0, 1.0));
    float d = hash12(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

// Worley Noise
float worley(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);
    float d = 1.0;
    for(int y = -1; y <= 1; y++) {
        for(int x = -1; x <= 1; x++) {
            vec2 g = vec2(float(x), float(y));
            vec2 o = hash22(n + g);
            vec2 r = g + o - f;
            d = min(d, dot(r, r));
        }
    }
    return sqrt(d);
}

void main() {
    vec2 pos = v_uv * u_origRes; 
    float s = max(1.0, u_scale);
    vec2 cell = floor(pos / s);
    
    vec3 n;
    if (u_type == 1) { // Grayscale White
        n = vec3(hash12(cell + u_seed));
    } else if (u_type == 0) { // Color White
        n = vec3(hash12(cell + u_seed), hash12(cell + u_seed + 1.23), hash12(cell + u_seed + 2.45));
    } else if (u_type == 3) { // Blue Noise (Gray)
        n = vec3(getBlue(cell + u_seed * 11.0));
    } else if (u_type == 4) { // Blue Noise (Color)
        n = vec3(getBlue(cell + u_seed * 11.0), getBlue(cell + u_seed * 17.0 + 1.23), getBlue(cell + u_seed * 23.0 + 2.45));
    } else if (u_type == 5) { // Perlin (Cloudy)
        float octs = floor(u_paramA * 7.0) + 1.0; // 1-8 octaves
        float persistence = 0.5 + (u_paramC - 0.5) * 0.5;
        float noiseSum = 0.0;
        float amp = 1.0;
        float freq = 1.0 / (s * 10.0 + (u_paramB * 50.0));
        for(int i = 0; i < 8; i++) {
            if(float(i) >= octs) break;
            noiseSum += perlin(pos * freq + u_seed * 1.5) * amp;
            amp *= persistence;
            freq *= 2.0;
        }
        n = vec3(noiseSum);
    } else if (u_type == 6) { // Worley (Cellular)
        float jitter = u_paramA;
        float density = 1.0 / (s * 5.0 + (u_paramB * 20.0));
        vec2 p = pos * density;
        vec2 n_cell = floor(p);
        vec2 f = fract(p);
        float d = 1.0;
        for(int y = -1; y <= 1; y++) {
            for(int x = -1; x <= 1; x++) {
                vec2 g = vec2(float(x), float(y));
                vec2 o = hash22(n_cell + g) * jitter;
                vec2 r = g + o - f;
                float dist = mix(abs(r.x) + abs(r.y), length(r), u_paramC); // Morph between Manhattan and Euclidean
                d = min(d, dist);
            }
        }
        n = vec3(d);
    } else if (u_type == 7) { // Scanlines
        float thick = mix(0.1, 0.9, u_paramA);
        float jitter = (hash12(vec2(u_seed)) - 0.5) * u_paramB * 5.0;
        float line = sin((pos.y + jitter) / s * 3.14159) * 0.5 + 0.5;
        float val = step(thick, line);
        n = vec3(mix(val, val * hash12(cell + u_seed), u_paramC));
    } else if (u_type == 8) { // Speckle (Dust)
        float density = mix(0.8, 0.999, u_paramA);
        float h = hash12(cell + u_seed);
        float speck = smoothstep(density, density + mix(0.01, 0.1, u_paramB), h);
        float sizeVar = hash12(cell * 0.5 + u_seed);
        n = vec3(speck * mix(1.0, sizeVar, u_paramC));
    } else if (u_type == 9) { // Glitch
        float blockSize = s * (5.0 + u_paramA * 50.0);
        float block = floor(pos.y / blockSize);
        float shift = (hash12(vec2(block, u_seed)) - 0.5) * u_paramB * 100.0;
        float split = u_paramC * 10.0;
        n = vec3(
            hash12(floor((pos + vec2(shift - split, 0.0)) / s) + u_seed),
            hash12(floor((pos + vec2(shift, 0.0)) / s) + u_seed),
            hash12(floor((pos + vec2(shift + split, 0.0)) / s) + u_seed)
        );
    } else if (u_type == 10) { // Anisotropic (Fiber)
        float stretch = 0.01 + u_paramA * 0.5;
        float rot = u_paramB * 6.28;
        mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
        vec2 p = (m * pos) * vec2(stretch, 1.0) / s;
        float h = hash12(floor(p) + u_seed);
        n = vec3(mix(h, h * hash12(cell + u_seed), u_paramC));
    } else if (u_type == 11) { // Voronoi Mosaic
        float scale = 1.0 / (s * 10.0 + u_paramA * 40.0);
        vec2 p = pos * scale;
        vec2 n_cell = floor(p);
        vec2 f = fract(p);
        float d = 1.0;
        vec2 m_cell;
        for(int y = -1; y <= 1; y++) {
            for(int x = -1; x <= 1; x++) {
                vec2 g = vec2(float(x), float(y));
                vec2 o = hash22(n_cell + g) * u_paramB;
                vec2 r = g + o - f;
                float dist = dot(r, r);
                if (dist < d) { d = dist; m_cell = n_cell + g; }
            }
        }
        vec3 col = vec3(hash12(m_cell + u_seed), hash12(m_cell + u_seed + 1.1), hash12(m_cell + u_seed + 2.2));
        n = mix(col, vec3(sqrt(d)), u_paramC);
    } else if (u_type == 12) { // Crosshatch
        float dens = 1.0 / (s * (1.0 + u_paramA * 5.0));
        float angle = u_paramB * 1.57;
        mat2 m1 = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        mat2 m2 = mat2(cos(-angle), -sin(-angle), sin(-angle), cos(-angle));
        float l1 = step(0.8, sin((m1 * pos).x * dens) * 0.5 + 0.5);
        float l2 = step(0.8, sin((m2 * pos).x * dens) * 0.5 + 0.5);
        float hatch = max(l1, l2);
        n = vec3(mix(hatch, hatch * hash12(cell + u_seed), u_paramC));
    } else {
        n = vec3(hash12(cell + u_seed));
    }
    
    outColor = vec4(n, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-blur">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (32 taps, directional)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = 1.0 - abs(i) / 16.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.0);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 5.0 * 5.0)); // Larger sigma for wider kernel
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s * weight;
            total += weight;
        }
    }
    outColor = color / total;
}</script><script type="x-shader/x-fragment" id="fs-composite">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; 
uniform int u_nType; 
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; 
uniform float u_ignAstr;
uniform float u_skinProt;

float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

float getSkinMask(vec3 rgb) {
    float r = rgb.r * 255.0;
    float g = rgb.g * 255.0;
    float b = rgb.b * 255.0;
    float cb = 128.0 + ( -0.168736 * r - 0.331264 * g + 0.5 * b );
    float cr = 128.0 + ( 0.5 * r - 0.418688 * g - 0.081312 * b );
    float dist = length(vec2(cr - 153.0, cb - 102.0)) / 30.0;
    return 1.0 - smoothstep(0.8, 1.2, dist);
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); 
    vec3 n = nc.rgb;
    vec3 res;
    vec3 base = bc.rgb;
    
    if (u_nType == 2) {
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        float lum = dot(base, vec3(0.299,0.587,0.114));
        float effectStr = u_str/50.0;
        if (u_skinProt > 0.0) {
            float skin = getSkinMask(base);
            effectStr *= (1.0 - skin * (u_skinProt / 100.0));
        }
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * effectStr); 
        res = satColor;
    } else {
        vec3 noiseLayer = nc.rgb;
        if (u_mode == 0) { 
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { 
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { 
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { 
            res = base * noiseLayer;
        } else if (u_mode == 4) { 
            res = base + noiseLayer;
        } else if (u_mode == 5) { 
            res = abs(base - noiseLayer);
        }
        
        float maskVal = mc.r; 
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); 
        
        if (u_skinProt > 0.0) {
            float skin = getSkinMask(base);
            finalOp *= (1.0 - skin * (u_skinProt / 100.0));
        }

        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}</script><script type="x-shader/x-fragment" id="fs-chroma">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

uniform float u_zoomBlur;
uniform int u_falloffToBlur;

void main() {
    if (u_amt <= 0.0 && u_blur <= 0.0 && u_zoomBlur <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    
    // Calculate clear zone mask
    float clearMask = 0.0;
    if (u_radius > 0.0 || u_falloff > 0.0) {
        clearMask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    }
    
    float blurStr = u_blur;
    float zoomStr = u_zoomBlur;
    if (u_falloffToBlur == 1) {
        blurStr *= (1.0 - clearMask);
        zoomStr *= (1.0 - clearMask);
    }

    // Calculate aberration strength based on distance from center
    float str = dist * dist * (u_amt / 1000.0); 
    str *= (1.0 - clearMask); 
    
    vec4 result = vec4(0.0);
    
    // We combine edge blur (directional jitter) and zoom blur (radial jitter)
    if (blurStr > 0.0 || zoomStr > 0.0) {
        float totalWeight = 0.0;
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * blurStr * 0.002; 
            // Zoom blur: samples along the 'dir' vector
            vec2 zoomOff = dir * (i * zoomStr * 0.02);
            float w = exp(-(i*i)/2.0); 
            
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t) + zoomOff).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5) + zoomOff * 0.5).g; 
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t) + zoomOff * 1.5).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}</script><script type="x-shader/x-fragment" id="fs-radial">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform vec2 u_res;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

void main() {
    float dist = length(v_uv - u_center);
    float mask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    outColor = vec4(vec3(mask), 1.0);
}</script><script type="x-shader/x-fragment" id="fs-palette">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_palette[256];
uniform int u_paletteSize;
uniform float u_blend;
uniform float u_smoothing;
uniform int u_smoothingType;
uniform vec2 u_res;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec2 texel = 1.0 / u_res;
    
    if (u_smoothing > 0.0) {
        float sumW = 0.0;
        vec3 sumC = vec3(0.0);
        float r = u_smoothing / 10.0; // Effective radius
        
        for(float i = -1.0; i <= 1.0; i++) {
            for(float j = -1.0; j <= 1.0; j++) {
                vec2 off = vec2(i, j) * texel * r;
                float weight = 1.0;
                
                if (u_smoothingType == 1) {
                    // 3x3 Gaussian Weights
                    float distSq = i*i + j*j;
                    weight = exp(-distSq / 1.0); // Simple Gaussian
                }
                
                sumC += texture(u_tex, v_uv + off).rgb * weight;
                sumW += weight;
            }
        }
        original = sumC / sumW;
    }
    
    if (u_paletteSize == 0) {
        outColor = c;
        return;
    }
    
    float minDist = 1e10;
    vec3 bestColor = u_palette[0];
    
    for (int i = 0; i < u_paletteSize; i++) {
        float d = distance(original, u_palette[i]);
        if (d < minDist) {
            minDist = d;
            bestColor = u_palette[i];
        }
    }
    
    vec3 res = mix(original, bestColor, u_blend);
    outColor = vec4(clamp(res, 0.0, 1.0), c.a);
}</script><script type="x-shader/x-fragment" id="fs-edge">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;
uniform int u_mode; // 0=Overlay, 1=Saturation
uniform float u_strength;
uniform float u_tolerance;
uniform float u_bgSat;
uniform float u_fgSat;
uniform float u_bloom;
uniform float u_smooth;
uniform float u_blend;

float getLuma(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

void main() {
    vec2 texel = 1.0 / u_res;
    
    // Sobel Kernels
    float x = texel.x;
    float y = texel.y;
    
    float m00 = getLuma(texture(u_tex, v_uv + vec2(-x, -y)).rgb);
    float m01 = getLuma(texture(u_tex, v_uv + vec2( 0, -y)).rgb);
    float m02 = getLuma(texture(u_tex, v_uv + vec2( x, -y)).rgb);
    float m10 = getLuma(texture(u_tex, v_uv + vec2(-x,  0)).rgb);
    float m12 = getLuma(texture(u_tex, v_uv + vec2( x,  0)).rgb);
    float m20 = getLuma(texture(u_tex, v_uv + vec2(-x,  y)).rgb);
    float m21 = getLuma(texture(u_tex, v_uv + vec2( 0,  y)).rgb);
    float m22 = getLuma(texture(u_tex, v_uv + vec2( x,  y)).rgb);
    
    float gx = (m02 + 2.0*m12 + m22) - (m00 + 2.0*m10 + m20);
    float gy = (m00 + 2.0*m01 + m02) - (m20 + 2.0*m21 + m22);
    
    float edge = sqrt(gx*gx + gy*gy);
    
    // Threshold & Strength
    edge = smoothstep(u_tolerance / 100.0, (u_tolerance + 10.0) / 100.0, edge) * (u_strength / 100.0);
    edge = clamp(edge, 0.0, 1.0);
    
    vec4 c = texture(u_tex, v_uv);
    vec3 res = c.rgb;
    
    if (u_mode == 0) {
        // Overlay Mode
        res = mix(c.rgb, vec3(1.0), edge);
    } else {
        // Saturation Mask Mode
        float spreadMask = edge;
        if (u_bloom > 0.0) {
            // Efficient spatial spread: sample neighbors and take max
            float maxE = edge;
            float stepScale = u_bloom / 5.0; // Scale step size by bloom
            
            for(float i = -2.0; i <= 2.0; i += 1.0) {
                for(float j = -2.0; j <= 2.0; j += 1.0) {
                    if (i == 0.0 && j == 0.0) continue;
                    vec2 off = vec2(i, j) * texel * stepScale;
                    // Recalculate edge at neighbor (Simplified Sobel or just Luma diff?)
                    // For performance, we'll just use a slightly faster luma-based edge check for spread
                    vec3 nCol = texture(u_tex, v_uv + off).rgb;
                    float nLuma = getLuma(nCol);
                    // Standard Sobel is too heavy to run 25 times. 
                    // Let's use the luma difference from center as a proxy for "nearby edge"
                    float dist = length(vec2(i, j)) / 2.82; // Normalized dist
                    float e = smoothstep(u_tolerance / 100.0, (u_tolerance + 10.0) / 100.0, abs(nLuma - getLuma(c.rgb)) * 2.0);
                    maxE = max(maxE, e * (1.0 - dist * (u_smooth / 100.0)));
                }
            }
            spreadMask = clamp(maxE, 0.0, 1.0);
        }

        float lum = getLuma(c.rgb);
        vec3 bw = vec3(lum);
        
        // Background: Desaturated or partially saturated
        vec3 bg = mix(bw, c.rgb, u_bgSat / 100.0);
        // Foreground: Saturated
        vec3 fg = mix(bw, c.rgb, u_fgSat / 100.0);
        
        res = mix(bg, fg, spreadMask);
    }
    
    outColor = vec4(mix(c.rgb, res, u_blend / 100.0), c.a);
}</script><script type="x-shader/x-fragment" id="fs-copy">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_channel; 

void main() {
    vec4 c = texture(u_tex, v_uv);
    if (u_channel == 1) outColor = vec4(c.rrr, 1.0);
    else if (u_channel == 2) outColor = vec4(c.ggg, 1.0);
    else if (u_channel == 3) outColor = vec4(c.bbb, 1.0);
    else outColor = c;
}</script><script type="x-shader/x-fragment" id="fs-invert">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;

void main() {
    float mask = texture(u_tex, v_uv).r;
    float inv = 1.0 - mask;
    // We output inversed mask to R channel (and everything else for safety)
    outColor = vec4(inv, inv, inv, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-dither">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

// 8x8 Bayer matrix (normalized to 0-1)
float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    // Bayer 8x8 pattern values
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

// Hash for noise dithering
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    
    // Calculate scaled position for dither pattern
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    // Get threshold value based on dither type
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    // Calculate quantization levels
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    // Apply dithering with strength
    vec3 dithered = col.rgb + threshold * (u_strength) * (1.0 / levels);
    
    // Quantize to bit depth
    dithered = floor(dithered * levels + 0.5) / levels;
    
    // Apply palette quantization
    dithered = floor(dithered * u_paletteSize + 0.5) / u_paletteSize;
    
    outColor = vec4(clamp(dithered, 0.0, 1.0), col.a);
}</script><script type="x-shader/x-fragment" id="fs-corruption">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_algorithm; // 0=jpeg blocks, 1=pixelation, 2=color bleed
uniform float u_resScale; // 1-100 (lower = more corruption)
uniform vec2 u_res;
uniform float u_iteration; // current iteration for variation

void main() {
    // Calculate block size based on resolution scale (inverted: lower scale = bigger blocks)
    float blockSize = max(2.0, (100.0 - u_resScale) / 5.0 + 1.0);
    
    vec4 col;
    
    if (u_algorithm == 0) {
        // JPEG-like block artifacts
        vec2 blockPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        vec2 blockCenter = blockPos + (blockSize * 0.5) / u_res;
        
        // Sample from block center with some offset for artifact feel
        vec2 offset = (v_uv - blockPos) * u_res / blockSize;
        offset = floor(offset * 2.0) / 2.0 * blockSize / u_res;
        
        col = texture(u_tex, blockPos + offset);
        
        // Add slight color shifting at block edges
        vec2 edgeDist = abs(fract(v_uv * u_res / blockSize) - 0.5);
        float edge = smoothstep(0.3, 0.5, max(edgeDist.x, edgeDist.y));
        col.rgb = mix(col.rgb, col.rgb * 0.95, edge * 0.3);
        
    } else if (u_algorithm == 1) {
        // Pixelation - simple downscale/upscale
        vec2 pixelPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        col = texture(u_tex, pixelPos + (blockSize * 0.5) / u_res);
        
    } else {
        // Color bleed - horizontal color smearing
        float bleedAmount = blockSize / u_res.x;
        vec4 left = texture(u_tex, v_uv - vec2(bleedAmount, 0.0));
        vec4 center = texture(u_tex, v_uv);
        vec4 right = texture(u_tex, v_uv + vec2(bleedAmount, 0.0));
        
        // Shift color channels
        col.r = mix(center.r, right.r, 0.3);
        col.g = center.g;
        col.b = mix(center.b, left.b, 0.3);
        col.a = center.a;
    }
    
    outColor = col;
}</script><script type="x-shader/x-fragment" id="fs-cell">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_levels;         // 2-12
uniform float u_bias;         // -1.0 to 1.0 (contrast bias)
uniform float u_gamma;        // 0.5 to 2.2
uniform int u_quantMode;      // 0=Luma, 1=RGB, 2=HSV
uniform int u_bandMap;        // 0=Linear, 1=Smooth, 2=Poster
uniform int u_edgeMethod;     // 0=None, 1=Sobel, 2=Laplc
uniform float u_edgeStr;      // 0-1
uniform float u_edgeThick;    // 0.5-3.0
uniform int u_colorPreserve;  // 0/1 bool
uniform int u_edgeEnable;     // 0/1 bool

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float getLuma(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

float quantize(float val, int levels, float bias, float gamma) {
    // Apply bias
    val = clamp(val + bias, 0.0, 1.0);
    
    // Apply gamma
    val = pow(val, gamma);
    
    // Quantize
    float fLevels = float(levels);
    float q = floor(val * fLevels) / (fLevels - 1.0);
    
    // Map output based on band mode
    if (u_bandMap == 1) { // Smooth
        q = smoothstep(0.0, 1.0, q);
    } else if (u_bandMap == 2) { // Posterize hard
        q = floor(val * fLevels) / fLevels; 
    }
    
    return q;
}

float sobel(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l00 = getLuma(texture(u_tex, uv + vec2(-px.x, -px.y)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l20 = getLuma(texture(u_tex, uv + vec2(px.x, -px.y)).rgb);
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l02 = getLuma(texture(u_tex, uv + vec2(-px.x, px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l22 = getLuma(texture(u_tex, uv + vec2(px.x, px.y)).rgb);
    
    float gx = l00 + 2.0*l01 + l02 - (l20 + 2.0*l21 + l22);
    float gy = l00 + 2.0*l10 + l20 - (l02 + 2.0*l12 + l22);
    
    return sqrt(gx*gx + gy*gy);
}

float laplacian(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l11 = getLuma(texture(u_tex, uv).rgb); // Center
    
    return abs(l01 + l21 + l10 + l12 - 4.0 * l11) * 2.0;
}

void main() {
    vec4 base = texture(u_tex, v_uv);
    vec3 col = base.rgb;
    
    // Apply Quantization
    vec3 res = col;
    if (u_quantMode == 0) { // Luma
        float l = getLuma(col);
        float q = quantize(l, u_levels, u_bias, u_gamma);
        if (u_colorPreserve == 1) {
            // Preserve color, only quantize lightness
            vec3 hsv = rgb2hsv(col);
            hsv.z = q;
            res = hsv2rgb(hsv);
        } else {
            res = vec3(q);
        }
    } else if (u_quantMode == 1) { // RGB
        res.r = quantize(col.r, u_levels, u_bias, u_gamma);
        res.g = quantize(col.g, u_levels, u_bias, u_gamma);
        res.b = quantize(col.b, u_levels, u_bias, u_gamma);
    } else { // HSV Value
        vec3 hsv = rgb2hsv(col);
        hsv.z = quantize(hsv.z, u_levels, u_bias, u_gamma);
        res = hsv2rgb(hsv);
    }
    
    // Apply Edges
    if (u_edgeEnable == 1 && u_edgeMethod > 0) {
        float edge = 0.0;
        if (u_edgeMethod == 1) edge = sobel(v_uv);
        else if (u_edgeMethod == 2) edge = laplacian(v_uv);
        
        edge = smoothstep(0.1, 1.0, edge * 2.0); // Boost edge visibility
        res = mix(res, vec3(0.0), edge * u_edgeStr);
    }
    
    outColor = vec4(res, base.a);
}</script><script type="x-shader/x-fragment" id="fs-halftone">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform float u_size;           // 1-12
uniform float u_intensity;      // 0-1
uniform float u_sharpness;      // 0-1
uniform int u_pattern;          // 0=Circ, 1=Line, 2=Cross, 3=Diamond
uniform int u_colorMode;        // 0=Luma, 1=RGB, 2=CMY, 3=CMYK
uniform int u_sample;           // 0=Center, 1=Avg
uniform int u_gray;             // Bool
uniform int u_lock;             // Bool
uniform int u_invert;           // Bool

float getPattern(vec2 uv, float angle) {
    float s = sin(angle), c = cos(angle);
    vec2 p = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y) * u_res / u_size; // Map to pattern space
    vec2 grid = fract(p) - 0.5;
    
    float d = 0.0;
    if (u_pattern == 0) { // Circle
        d = length(grid) * 2.0; // 0-1 range center to corner
    } else if (u_pattern == 1) { // Line
        d = abs(grid.y) * 2.0;
    } else if (u_pattern == 2) { // Cross
        d = min(abs(grid.x), abs(grid.y)) * 2.0;
    } else { // Diamond
        d = (abs(grid.x) + abs(grid.y));
    }
    
    return d; // 0 at center/peak, 1 at edge
}

void main() {
    float angle = 0.0; // Default angle
    if (u_sample == 2) angle = 0.785; // 45 deg for rotated
    
    vec2 sampleUV = v_uv;
    if (u_lock == 0) {
        // Pattern follows image (UV space), scale by res ratio to keep square dots
        // Actually simpler: just rely on u_size scaling against u_res
    }
    
    vec4 col = texture(u_tex, v_uv);
    
    // Halftone Logic
    vec3 outRGB = vec3(0.0);
    
    if (u_colorMode == 0) { // Luminance
        float l = dot(col.rgb, vec3(0.299, 0.587, 0.114));
        float pat = getPattern(v_uv, 0.785); // 45 degree default for mono
        
        // Threshold
        // Pattern goes 0(black) to 1(white). Luma 0(black) to 1(white).
        // Standard HT: if luma > pattern -> white. 
        // With intensity: mix pattern with luma.
        
        // Soft edge based on sharpness
        float thresh = 1.0 - l * u_intensity; // Invert luma for pattern comparison
        float softness = 1.0 - u_sharpness;
        float val = smoothstep(thresh - softness, thresh + softness, pat);
        
        if (u_invert == 1) val = 1.0 - val;
        outRGB = vec3(val);
        
    } else if (u_colorMode == 1) { // RGB
        // Separate angles for R, G, B
        float pR = getPattern(v_uv, 0.26); // ~15 deg
        float pG = getPattern(v_uv, 1.30); // ~75 deg
        float pB = getPattern(v_uv, 0.0);  // 0 deg
        
        float soft = 1.0 - u_sharpness;
        
        float r = smoothstep((1.0 - col.r) - soft, (1.0 - col.r) + soft, pR);
        float g = smoothstep((1.0 - col.g) - soft, (1.0 - col.g) + soft, pG);
        float b = smoothstep((1.0 - col.b) - soft, (1.0 - col.b) + soft, pB);
        
        outRGB = vec3(r, g, b);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
        
    } else { // CMY / CMYK
        // Simple RGB -> CMY
        vec3 cmy = 1.0 - col.rgb;
        float k = 0.0;
        if (u_colorMode == 3) { // CMYK
            k = min(min(cmy.x, cmy.y), cmy.z);
            cmy = (cmy - k) / (1.0 - k);
        }
        
        // Angles: C=15, M=75, Y=0, K=45
        float pC = getPattern(v_uv, 0.26);
        float pM = getPattern(v_uv, 1.30);
        float pY = getPattern(v_uv, 0.0);
        float pK = getPattern(v_uv, 0.785);
        
        float soft = 1.0 - u_sharpness;
        
        // Halftone each channel (0=white, 1=ink). 
        // If pattern < ink_amount -> ink. 
        // Pattern 0(center) to 1(edge). Ink 0(none) to 1(full).
        // If pattern < cmy.r => ink.
        // Invert comparison for white checks?
        // Let's use: if pattern > (1.0 - ink) -> ink ?? No.
        
        // Standard: dot grows from center (0). so if pattern < ink -> ink.
        float hC = 1.0 - smoothstep(cmy.x - soft, cmy.x + soft, pC);
        float hM = 1.0 - smoothstep(cmy.y - soft, cmy.y + soft, pM);
        float hY = 1.0 - smoothstep(cmy.z - soft, cmy.z + soft, pY);
        float hK = 1.0 - smoothstep(k - soft, k + soft, pK);
        
        // Combine CMYK -> RGB
        // white - ink
        vec3 resCMY = vec3(hC, hM, hY);
        if (u_colorMode == 3) resCMY += vec3(hK);
        
        outRGB = 1.0 - clamp(resCMY, 0.0, 1.0);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
    }
    
    if (u_gray == 1) {
        float l = dot(outRGB, vec3(0.299, 0.587, 0.114));
        outRGB = vec3(l);
    }
    
    outColor = vec4(outRGB, col.a);
}</script><script type="x-shader/x-fragment" id="fs-bilateral">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_radius;        // 1-30
uniform float u_sigmaCol;    // 0.01 - 1.0
uniform float u_sigmaSpace;  // 0.5 - 15.0
uniform int u_kernel;        // 0=Gauss, 1=Box
uniform int u_edgeMode;      // 0=Luma, 1=RGB

float getDist(vec3 c1, vec3 c2) {
    if (u_edgeMode == 0) {
        float l1 = dot(c1, vec3(0.299, 0.587, 0.114));
        float l2 = dot(c2, vec3(0.299, 0.587, 0.114));
        return abs(l1 - l2);
    } else {
        return length(c1 - c2);
    }
}

void main() {
    vec4 centerCol = texture(u_tex, v_uv);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;
    
    // Separable optimization not easy for true bilateral without ping-pong
    // We will do a full kernel loop but skip somewhat to save perf if radius is high?
    // No, standard loop.
    
    int r = u_radius;
    float fs = u_sigmaSpace;
    float fc = u_sigmaCol;
    
    for (int x = -r; x <= r; x++) {
        for (int y = -r; y <= r; y++) {
            vec2 offset = vec2(float(x), float(y));
            vec2 uv = v_uv + offset / u_res;
            
            vec3 samp = texture(u_tex, uv).rgb;
            
            float spaceDistSq = dot(offset, offset);
            float colorDist = getDist(centerCol.rgb, samp);
            
            float wSpace = 1.0;
            if (u_kernel == 0) wSpace = exp(-spaceDistSq / (2.0 * fs * fs));
            
            float wColor = exp(-(colorDist * colorDist) / (2.0 * fc * fc));
            
            float w = wSpace * wColor;
            
            sum += samp * w;
            weightSum += w;
        }
    }
    
    outColor = vec4(sum / weightSum, centerCol.a);
}</script><script type="x-shader/x-fragment" id="fs-colorMask">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;  // RGB 0-1
uniform float u_tolerance;   // 0-1
uniform float u_fade;        // 0-1

void main() {
    vec4 c = texture(u_tex, v_uv);
    float dist = length(c.rgb - u_targetColor);
    float low = u_tolerance - u_fade * 0.5;
    float high = u_tolerance + u_fade * 0.5;
    float mask = smoothstep(low, high, dist);
    // mask = 0 when color matches (to exclude), 1 elsewhere
    outColor = vec4(mask, mask, mask, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-maskedBlur">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    float maskVal = texture(u_mask, v_uv).r;
    vec4 original = texture(u_tex, v_uv);
    
    if (maskVal < 0.01) {
        outColor = original;
        return;
    }
    
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (32 taps, directional)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = 1.0 - abs(i) / 16.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.0);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 5.0 * 5.0)); 
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s * weight;
            total += weight;
        }
    }
    
    vec4 blurred = color / total;
    outColor = mix(original, blurred, maskVal);
}</script><script type="x-shader/x-fragment" id="fs-maskedDither">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    float maskVal = texture(u_mask, v_uv).r;
    
    if (maskVal < 0.01) {
        outColor = col;
        return;
    }
    
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    // Corrected strength: u_strength is 0-1 from JS, matching fs-dither logic
    vec3 dithered = col.rgb + threshold * (u_strength) * (1.0 / levels);
    
    // Low bit-depth quantized color
    vec3 quantized = floor(dithered * levels + 0.5) / levels;
    quantized = floor(quantized * u_paletteSize + 0.5) / u_paletteSize;
    
    // Smooth LERP between original and low-depth dithered
    vec3 result = mix(col.rgb, quantized, maskVal);
    
    outColor = vec4(clamp(result, 0.0, 1.0), col.a);
}</script><script type="x-shader/x-fragment" id="fs-adjustMasked">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_useMask;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform float u_sharpThresh;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Sharpening
    if (u_sharp > 0.0) {
        vec4 sum = vec4(0.0);
        sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x,  u_step.y));
        vec4 edge = c - (sum * 0.25);
        rgb += edge.rgb * (u_sharp / 10.0); 
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    // Apply mask if enabled
    if (u_useMask == 1) {
        float maskVal = texture(u_mask, v_uv).r;
        rgb = mix(original, rgb, maskVal);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}</script><script>const state={gl:null,canvas:null,programs:{},textures:{},fbos:{},pingPong:[null,null],thumbnailFBO:null,baseImage:null,imageFiles:[],currentImageIndex:0,isMultiImageMode:!1,isExporting:!1,playInterval:null,isPlaying:!1,lastFrameTime:0,realtimeFps:0,frameRenderCount:0,width:1,height:1,renderWidth:1,renderHeight:1,fboWidth:0,fboHeight:0,busy:!1,upscaleFactor:1,renderOrder:["noise","adjust","hdr","ca","blur","cell","halftone","bilateral","dither","palette","edge","corruption"],activeLayerPreview:null,activeSection:"adjust",caCenter:{x:.5,y:.5},isDraggingPin:!1,layerTextures:{},layerVisibility:{noise:!0,adjust:!0,hdr:!0,ca:!0,blur:!0,cell:!0,halftone:!0,bilateral:!0,dither:!0,palette:!0,edge:!0,corruption:!0},palette:[],lastExtractionImage:null,pinIdleTimer:null,isPreviewLocked:!1,clampPreview:!0,isZoomLocked:!1,lastMousePos:{x:0,y:0},isZooming:!1,isLensMode:!1,keepFolderStructure:!1,allFiles:[]},UI={},LAYERS={noise:{name:"Noise Group",color:"#fff"},adjust:{name:"Adjustments",color:"#fff"},hdr:{name:"HDR Emulation",color:"#fff"},ca:{name:"Chromatic Aberration",color:"#fff"},blur:{name:"Blur",color:"#fff"},cell:{name:"Cell Shading",color:"#fff"},halftone:{name:"Halftoning",color:"#fff"},bilateral:{name:"Bilateral Filter",color:"#fff"},dither:{name:"Dithering",color:"#fff"},palette:{name:"Palette Reconstructor",color:"#fff"},edge:{name:"Edge Effects",color:"#fff"},corruption:{name:"Corruption",color:"#fff"},shadows:{name:"Shadows Mask",color:"#fff"},highlights:{name:"Highlights Mask",color:"#fff"}};function downloadPreset(){const e={values:{},checks:{},selects:{},renderOrder:state.renderOrder,layerVisibility:state.layerVisibility,upscaleFactor:state.upscaleFactor,caCenter:state.caCenter,palette:state.palette,imageData:null};document.querySelectorAll("input[type=range]").forEach(t=>e.values[t.id]=t.value),document.querySelectorAll("input[type=text].control-value").forEach(e=>{}),document.querySelectorAll("input[type=checkbox]").forEach(t=>{t.id.startsWith("drag-")||"jsonIncludeImage"===t.id||"previewLock"===t.id||(e.checks[t.id]=t.checked)}),document.querySelectorAll("select").forEach(t=>{"jsonImportMode"!==t.id&&(e.selects[t.id]=t.value)});const t=document.getElementById("jsonIncludeImage").checked;if(state.baseImage&&t)try{const t=document.createElement("canvas");t.width=state.baseImage.width,t.height=state.baseImage.height;t.getContext("2d").drawImage(state.baseImage,0,0),e.imageData=t.toDataURL("image/png")}catch(e){console.warn("Could not save image data (likely tainted canvas or too large):",e)}const a=new Blob([JSON.stringify(e,null,2)],{type:"application/json"}),r=URL.createObjectURL(a),o=document.createElement("a");o.href=r,o.download="grain-settings.json",o.click()}function uploadPreset(e){const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=e=>{try{const t=JSON.parse(e.target.result),a=document.getElementById("jsonImportMode").value,r=("both"===a||"image"===a)&&t.imageData,o="both"===a||"settings"===a;if(r){const e=new Image;e.onload=()=>{loadNewImage(e),o&&restoreSettings(t)},e.src=t.imageData}else o&&restoreSettings(t)}catch(e){alert("Error loading JSON: "+e)}},a.readAsText(t)}function restoreSettings(e){e.values&&Object.keys(e.values).forEach(t=>{const a=document.getElementById(t);a&&(a.value=e.values[t],a.nextElementSibling&&a.nextElementSibling.classList.contains("control-value")&&(a.nextElementSibling.value=e.values[t]),a.dispatchEvent(new Event("input")),a.dispatchEvent(new Event("change")))}),e.checks&&Object.keys(e.checks).forEach(t=>{const a=document.getElementById(t);a&&(a.checked=e.checks[t],a.dispatchEvent(new Event("change")))}),e.selects&&Object.keys(e.selects).forEach(t=>{const a=document.getElementById(t);a&&(a.value=e.selects[t],a.dispatchEvent(new Event("change")))}),e.renderOrder&&(state.renderOrder=e.renderOrder,setupDragLayerList()),e.layerVisibility&&(state.layerVisibility=e.layerVisibility,setupDragLayerList()),e.upscaleFactor&&(state.upscaleFactor=e.upscaleFactor,UI.upscaleInput.value=e.upscaleFactor),e.caCenter&&(state.caCenter=e.caCenter,updatePinPosition()),e.palette&&(state.palette=e.palette,updatePaletteUI()),requestRender()}async function loadFolder(){try{const e=await window.showDirectoryPicker(),t=[],a=[];UI.loading.textContent="SCANNING FOLDER...",UI.loading.style.display="block",await async function e(r,o=""){for await(const s of r.values())if("file"===s.kind){const e=await s.getFile();e.relativePath=o,a.push(e),e.type.startsWith("image/")&&t.push(e)}else"directory"===s.kind&&await e(s,o+s.name+"/")}(e),UI.loading.style.display="none",t.length>0?(state.imageFiles=t.sort((e,t)=>e.name.localeCompare(t.name,void 0,{numeric:!0})),state.allFiles=a,state.isMultiImageMode=!0,state.currentImageIndex=0,await loadImageFromFile(state.imageFiles[0]),updateUIMode()):alert("No images found in the selected folder.")}catch(e){console.error("Error loading folder:",e),UI.loading.style.display="none","AbortError"!==e.name&&alert("Could not load folder. Please ensure your browser supports the File System Access API and you have granted permission.")}}async function changeImage(e){if(!state.isMultiImageMode||0===state.imageFiles.length)return;let t=state.currentImageIndex+e;t<0||t>=state.imageFiles.length||(state.currentImageIndex=t,await loadImageFromFile(state.imageFiles[state.currentImageIndex]),updateUIMode())}async function loadImageFromFile(e){return new Promise((t,a)=>{const r=new Image,o=URL.createObjectURL(e);r.src=o,r.onload=()=>{loadNewImage(r),URL.revokeObjectURL(o),t()},r.onerror=e=>{URL.revokeObjectURL(o),a(e)}})}function updateUIMode(){const e=document.getElementById("image-navigation"),t=UI.imageScrubber;state.isMultiImageMode&&state.imageFiles.length>1?(e.style.display="flex",UI.imageCounter.textContent=`Image ${state.currentImageIndex+1} of ${state.imageFiles.length}`,UI.downloadBtn.textContent=`DOWNLOAD ALL (${state.imageFiles.length})`,t.max=state.imageFiles.length-1,t.value=state.currentImageIndex,UI.downloadCurrentBtn&&(UI.downloadCurrentBtn.style.display="block")):(e.style.display="none",UI.downloadBtn.textContent="DOWNLOAD FULL RES",UI.downloadCurrentBtn&&(UI.downloadCurrentBtn.style.display="none")),state.imageFiles.length>1&&(UI.prevImageBtn.disabled=0===state.currentImageIndex,UI.nextImageBtn.disabled=state.currentImageIndex===state.imageFiles.length-1)}async function downloadSingleImage(){UI.loading.textContent="PROCESSING GPU...",UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),reallocateBuffers(!0),renderFrame(!0);const e=document.createElement("a"),t=state.isMultiImageMode?state.imageFiles[state.currentImageIndex].name.split(".")[0]:"grain-export";e.download=`${t}-processed.png`,e.href=state.canvas.toDataURL("image/png",1),e.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function downloadAllImages(){let e;try{e=await window.showDirectoryPicker()}catch(e){if("AbortError"===e.name)return;return void alert("Could not open directory. Permission denied.")}state.isExporting=!0;const t=UI["export-overlay"];t.style.display="flex";const a=()=>{state.isExporting=!1};UI.stopExportBtn.addEventListener("click",a);const r=state.currentImageIndex,o=state.keepFolderStructure?state.allFiles:state.imageFiles;try{for(let t=0;t<o.length;t++){if(!state.isExporting){alert("Export cancelled.");break}const a=o[t];UI["export-status"].textContent=`EXPORTING ${t+1}/${o.length}...`;try{let r=e;if(state.keepFolderStructure&&a.relativePath){const e=a.relativePath.split("/").filter(e=>""!==e);for(const t of e)r=await r.getDirectoryHandle(t,{create:!0})}if(state.imageFiles.includes(a)){await loadImageFromFile(a),reallocateBuffers(!0),renderFrame(!0);const e=await new Promise(e=>state.canvas.toBlob(e,"image/png")),o=state.keepFolderStructure?a.name:`${t+1}.png`,s=await r.getFileHandle(o,{create:!0}),n=await s.createWritable();await n.write(e),await n.close()}else if(state.keepFolderStructure){const e=await r.getFileHandle(a.name,{create:!0}),t=await e.createWritable();await t.write(a),await t.close()}}catch(e){console.error(`Error exporting ${a.name}:`,e)}await new Promise(e=>setTimeout(e,10))}state.isExporting&&alert(`Export Complete. Processed ${state.imageFiles.length} images and copied ${state.allFiles.length-state.imageFiles.length} other files.`)}finally{state.isExporting=!1,t.style.display="none",UI.stopExportBtn.removeEventListener("click",a),await loadImageFromFile(state.imageFiles[r]),state.currentImageIndex=r,updateUIMode(),reallocateBuffers(!1),requestRender()}}function setupDragLayerList(){const e=document.getElementById("layer-drag-list");e.innerHTML="",state.renderOrder.forEach((t,a)=>{const r=document.createElement("div");r.className="drag-layer",r.draggable=!0,r.dataset.key=t;const o=state.layerVisibility[t]?"checked":"";r.innerHTML=`\n            <div style="display:flex; align-items:center;">\n                <span class="drag-handle">‚ò∞</span> \n                <input type="checkbox" class="drag-toggle" data-key="${t}" ${o}>\n            </div>\n            <span>${LAYERS[t].name}</span>\n        `,r.querySelector("input").addEventListener("change",e=>{state.layerVisibility[t]=e.target.checked,requestRender()}),r.addEventListener("dragstart",e=>{e.dataTransfer.setData("text/plain",a),r.classList.add("dragging")}),r.addEventListener("dragend",()=>r.classList.remove("dragging")),r.addEventListener("dragover",e=>e.preventDefault()),r.addEventListener("drop",e=>{e.preventDefault();const t=parseInt(e.dataTransfer.getData("text/plain")),r=a;if(t===r)return;const o=state.renderOrder.splice(t,1)[0];state.renderOrder.splice(r,0,o),setupDragLayerList(),setupLayerGridDOM(),requestRender()}),e.appendChild(r)})}window.addEventListener("DOMContentLoaded",async()=>{document.querySelectorAll("input, select, button, canvas").forEach(e=>{e.id&&(UI[e.id]=e)}),UI.layerGrid=document.getElementById("layerGrid"),UI.previewContainer=document.getElementById("previewContainer"),UI.overlayOriginal=document.getElementById("overlayOriginal"),UI.loading=document.getElementById("loading"),UI.hoverZoomValue=document.getElementById("hoverZoomValue"),UI.hoverZoomSlider=document.getElementById("hoverZoomSlider"),UI.zoomResIndicator=document.getElementById("zoomResIndicator"),UI.loadFolderBtn=document.getElementById("loadFolderBtn"),UI.prevImageBtn=document.getElementById("prevImageBtn"),UI.nextImageBtn=document.getElementById("nextImageBtn"),UI.imageCounter=document.getElementById("imageCounter"),UI.imageScrubber=document.getElementById("imageScrubber"),UI.playBtn=document.getElementById("playBtn"),UI.playFps=document.getElementById("playFps"),UI.actualFps=document.getElementById("actualFps"),UI["export-overlay"]=document.getElementById("export-overlay"),UI["export-status"]=document.getElementById("export-status"),UI.stopExportBtn=document.getElementById("stopExportBtn"),UI.caPin=document.getElementById("caPin"),UI.previewLock=document.getElementById("previewLock"),UI.resetCenterBtn=document.getElementById("resetCenterBtn"),UI.upscaleInput=document.getElementById("upscaleInput"),UI.clampPreviewToggle=document.getElementById("clampPreviewToggle"),UI.gpuMaxRes=document.getElementById("gpuMaxRes"),UI.exportInfo=document.getElementById("exportInfo"),UI.zoomLens=document.getElementById("zoomLens"),UI.lensToggleBtn=document.getElementById("lensToggleBtn"),UI.lensCanvas=document.getElementById("lensCanvas");["blurEnable","blurAmount","blurType","blurColorExclude","blurTargetColor","blurColorTolerance","blurColorFade","blurLumaMask","blurShadowThreshold","blurShadowFade","blurHighlightThreshold","blurHighlightFade","ditherEnable","ditherBitDepth","ditherPaletteSize","ditherStrength","ditherScale","ditherType","ditherColorExclude","ditherExcludeColor","ditherColorTolerance","ditherColorFade","ditherLumaMask","ditherShadowThreshold","ditherShadowFade","ditherHighlightThreshold","ditherHighlightFade","paletteEnable","paletteBlend","paletteSmoothing","paletteSmoothingType","paletteList","extractCount","edgeEnable","edgeBlend","edgeMode","edgeStrength","edgeTolerance","edgeFgSat","edgeBgSat","edgeBloom","edgeSmooth","edgeSatControls"].forEach(e=>{const t=document.getElementById(e);t&&(UI[e]=t)}),document.querySelectorAll(".tab-btn").forEach(e=>{e.addEventListener("click",e=>{document.querySelectorAll(".tab-btn").forEach(e=>e.classList.remove("active")),document.querySelectorAll(".tab-content").forEach(e=>e.classList.remove("active")),e.target.classList.add("active"),document.getElementById(e.target.dataset.tab).classList.add("active")})}),document.querySelectorAll("#controls details").forEach(e=>{e.addEventListener("toggle",t=>{if(e.open){document.querySelectorAll("#controls details").forEach(t=>{t!==e&&t.open&&(t.open=!1)});const t=e.querySelector("input, select");if(t){const e=getSectionFromId(t.id);e&&(state.activeSection=e,requestRender())}}})}),setupDragLayerList(),document.querySelectorAll("input[type=range]").forEach(e=>{const t=e.nextElementSibling;if(t&&t.classList.contains("control-value")){const a=()=>t.value=e.value;e.addEventListener("input",()=>{a(),requestRender()}),a()}}),UI.hoverZoomValue&&UI.hoverZoomValue.addEventListener("input",e=>{const t=parseFloat(e.target.value);isNaN(t)||(state.zoomLevel=t),requestRender()}),document.querySelectorAll("select, input[type=checkbox], input[type=color]").forEach(e=>{e.addEventListener("change",()=>{"clampPreviewToggle"===e.id&&(state.clampPreview=!e.checked,reallocateBuffers(state.isZooming)),requestRender()}),e.addEventListener("input",requestRender)}),UI.edgeMode.addEventListener("change",()=>{UI.edgeSatControls.style.display="1"===UI.edgeMode.value?"block":"none"}),UI.edgeMode.dispatchEvent(new Event("change"));const e=()=>"#"+Math.floor(16777215*Math.random()).toString(16).padStart(6,"0");UI.addPaletteColor.addEventListener("click",()=>{state.palette.push(e()),updatePaletteUI(),requestRender()});const t=document.createElement("input");let a;t.id="pickPaletteColor",t.type="color",t.style.display="none",document.body.appendChild(t),UI.pickPaletteColorInput=t,t.addEventListener("change",e=>{state.palette.push(e.target.value),updatePaletteUI(),requestRender()}),UI.clearPalette.addEventListener("click",()=>{state.palette=[],updatePaletteUI(),requestRender()}),UI.randomPalette.addEventListener("click",()=>{const t=state.palette.length;if(0===t){const t=Math.floor(5*Math.random())+3,a=new Set;for(;a.size<t;)a.add(e());state.palette=Array.from(a)}else for(let a=0;a<t;a++)state.palette[a]=e();updatePaletteUI(),requestRender()}),UI.extractPalette.addEventListener("click",()=>UI.paletteImageUpload.click()),UI.paletteImageUpload.addEventListener("change",e=>{const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=e=>{const t=new Image;t.onload=()=>{state.lastExtractionImage=t;const e=parseInt(UI.extractCount?.value||8);extractPaletteFromImage(t,e)},t.src=e.target.result},a.readAsDataURL(t)}),UI.extractCount.addEventListener("input",()=>{if(state.lastExtractionImage){const e=parseInt(UI.extractCount.value);extractPaletteFromImage(state.lastExtractionImage,e)}}),UI.previewLock.addEventListener("change",e=>{state.isPreviewLocked=e.target.checked,state.isPreviewLocked&&UI.overlayOriginal.classList.remove("show")}),UI.upscaleInput.addEventListener("change",e=>{let t=parseInt(e.target.value);(isNaN(t)||t<1)&&(t=1),t>10&&(t=10),e.target.value=t,state.upscaleFactor=t,state.baseImage&&(reallocateBuffers(!1),requestRender())}),UI.resetCenterBtn.addEventListener("click",()=>{state.caCenter={x:.5,y:.5},updatePinPosition(),requestRender()}),UI.caPin.addEventListener("mousedown",e=>{state.isDraggingPin=!0,state.isPreviewLocked||UI.overlayOriginal.classList.remove("show"),clearTimeout(state.pinIdleTimer),e.preventDefault()}),window.addEventListener("mouseup",()=>{state.isDraggingPin&&(state.isDraggingPin=!1,state.isPreviewLocked||(state.pinIdleTimer=setTimeout(()=>{UI.overlayOriginal.classList.add("show")},4e3)))}),window.addEventListener("mousemove",e=>{if(!state.isDraggingPin)return;const t=UI.previewContainer.getBoundingClientRect();let a=(e.clientX-t.left)/t.width,r=1-(e.clientY-t.top)/t.height;a=Math.max(0,Math.min(1,a)),r=Math.max(0,Math.min(1,r)),state.caCenter={x:a,y:r},updatePinPosition(),requestRender()});const r=UI.previewContainer,o=UI.displayCanvas;UI.lensToggleBtn.addEventListener("click",()=>{state.isLensMode=!state.isLensMode,UI.lensToggleBtn.textContent=state.isLensMode?"LENS":"FULL",UI.lensToggleBtn.style.background=state.isLensMode?"var(--accent)":"",UI.lensToggleBtn.style.color=state.isLensMode?"#000":"",i()});const s=180;UI.lensCanvas.width=s,UI.lensCanvas.height=s;const n=UI.lensCanvas.getContext("2d"),i=(e=!1)=>{state.isZoomLocked&&!e||(o.style.transform="",o.style.transformOrigin="",o.style.zIndex="",UI.zoomResIndicator.style.display="none",UI.zoomLens&&(UI.zoomLens.style.display="none"),state.isZooming&&(state.isZooming=!1,state.clampPreview&&(reallocateBuffers(!1),requestRender())))},l=e=>{const t=(e=>{let t=parseFloat(e);return isNaN(t)?1:t})(UI.hoverZoomSlider.value);if(t<=1)return void i();UI.overlayOriginal.classList.remove("show"),state.isZooming||(state.isZooming=!0,reallocateBuffers(!0),requestRender());const a=r.getBoundingClientRect();!state.isZoomLocked&&e&&(state.lastMousePos={x:e.clientX,y:e.clientY});const l=state.lastMousePos.x-a.left,u=state.lastMousePos.y-a.top;a.width,a.height;if(state.isLensMode){o.style.transform="",o.style.transformOrigin="",o.style.zIndex="",UI.zoomLens&&(UI.zoomLens.style.display="block",UI.zoomLens.style.left=l-90+"px",UI.zoomLens.style.top=u-90+"px");const e=o.width/o.height;let r,i,c,m;e>a.width/a.height?(r=a.width,i=a.width/e,c=0,m=(a.height-i)/2):(i=a.height,r=a.height*e,c=(a.width-r)/2,m=0);const d=(l-c)/r*o.width,g=(u-m)/i*o.height,f=s/t,p=d-f/2,h=g-f/2;n&&(n.clearRect(0,0,s,s),n.drawImage(o,Math.max(0,Math.min(p,o.width-f)),Math.max(0,Math.min(h,o.height-f)),f,f,0,0,s,s))}else{UI.zoomLens&&(UI.zoomLens.style.display="none"),o.style.zIndex="15";const e=o.width/o.height,r=a.width/a.height;let s=0,n=0,i=a.width,c=a.height;e>r?(c=a.width/e,n=(a.height-c)/2):(i=a.height*e,s=(a.width-i)/2);const m=(l-s)/i,d=(u-n)/c;o.style.transformOrigin=`${100*m}% ${100*d}%`,o.style.transform=`scale(${t})`}const c=state.width*state.upscaleFactor,m=state.height*state.upscaleFactor,d=o.width,g=o.height,f=d>=c&&g>=m?"‚úì FULL RES":"‚ö† SCALED",p=state.isLensMode?"LENS":"FULL";UI.zoomResIndicator.innerHTML=`Mode: ${p}<br>Source: ${c}√ó${m}<br>Canvas: ${d}√ó${g}<br>${f}`,UI.zoomResIndicator.style.display="block",UI.zoomResIndicator.style.color=d>=c&&g>=m?"#0f0":"#f80",UI.zoomResIndicator.style.borderColor=d>=c&&g>=m?"#0f0":"#f80"};r.addEventListener("mouseenter",e=>{parseFloat(UI.hoverZoomSlider.value)<=1&&!state.isPreviewLocked&&!state.activeLayerPreview&&UI.overlayOriginal.classList.add("show"),clearTimeout(a),l(e)}),r.addEventListener("mouseleave",e=>{UI.overlayOriginal.classList.remove("show"),clearTimeout(a),state.isZoomLocked||i()}),r.addEventListener("wheel",e=>{if(e.ctrlKey||e.metaKey){e.preventDefault();const t=UI.blendMode,a=t.options.length;let r=t.selectedIndex;r=(r+Math.sign(e.deltaY)+a)%a,t.selectedIndex=r,requestRender()}else{e.preventDefault();let t=parseFloat(UI.hoverZoomSlider.value);t+=.5*-Math.sign(e.deltaY),t=Math.max(1,Math.min(8,t)),UI.hoverZoomSlider.value=t,UI.hoverZoomSlider.dispatchEvent(new Event("input")),l(e)}},{passive:!1}),r.addEventListener("mousemove",e=>{clearTimeout(a);const t=parseFloat(UI.hoverZoomSlider.value);!state.isPreviewLocked&&!state.activeLayerPreview&&t<=1&&UI.overlayOriginal.classList.add("show"),l(e)}),window.addEventListener("keydown",e=>{if("Tab"===e.key){const t=UI.previewContainer.matches(":hover");(t||state.isZoomLocked)&&(e.preventDefault(),state.isZoomLocked=!state.isZoomLocked,state.isZoomLocked||t?state.isZoomLocked&&l():i(!0))}}),UI.downloadJsonBtn.addEventListener("click",downloadPreset),UI.uploadJsonTrigger.addEventListener("click",()=>UI.jsonUpload.click()),UI.jsonUpload.addEventListener("change",uploadPreset),initWebGL(),UI.imageUpload.addEventListener("change",e=>{const t=e.target.files[0];t&&(state.isMultiImageMode=!1,state.imageFiles=[t],state.currentImageIndex=0,loadImageFromFile(t).then(updateUIMode))}),UI.loadFolderBtn.addEventListener("click",loadFolder),UI.prevImageBtn.addEventListener("click",()=>changeImage(-1)),UI.nextImageBtn.addEventListener("click",()=>changeImage(1)),UI.imageScrubber.addEventListener("input",e=>{const t=parseInt(e.target.value,10);t!==state.currentImageIndex&&(state.currentImageIndex=t,requestAnimationFrame(()=>{loadImageFromFile(state.imageFiles[state.currentImageIndex]).then(updateUIMode)}))});UI.playBtn.addEventListener("click",()=>{state.isPlaying?(state.playInterval&&(clearInterval(state.playInterval),state.playInterval=null),state.isPlaying=!1,UI.playBtn.textContent="PLAY ‚ñ∫"):(()=>{state.playInterval&&clearInterval(state.playInterval),state.isPlaying=!0,UI.playBtn.textContent="STOP ‚ñ†";const e=parseInt(UI.playFps.value,10)||10;state.playInterval=setInterval(()=>{let e=(state.currentImageIndex+1)%state.imageFiles.length;state.currentImageIndex=e,loadImageFromFile(state.imageFiles[state.currentImageIndex]),updateUIMode()},1e3/e)})()}),UI.keepFolderStructureToggle.addEventListener("change",e=>{state.keepFolderStructure=e.target.checked}),UI.downloadBtn.addEventListener("click",()=>{state.isMultiImageMode&&state.imageFiles.length>1?downloadAllImages():downloadSingleImage()}),UI.downloadCurrentBtn=document.getElementById("downloadCurrentBtn"),UI.compareBtn.addEventListener("click",openCompare),UI.downloadCurrentBtn.addEventListener("click",downloadSingleImage),UI.closeCompare.addEventListener("click",()=>document.getElementById("compareModal").classList.remove("show")),UI.exportSideBySide.addEventListener("click",()=>exportComparison("side")),UI.exportStacked.addEventListener("click",()=>exportComparison("stack")),UI.noiseType.addEventListener("change",syncNoiseUI),syncNoiseUI();const u=document.createElement("style");u.textContent="\n                .eyedropper-btn { background: none; border: none; cursor: pointer; font-size: 1.2em; padding: 0 5px; opacity: 0.7; transition: opacity 0.2s; }\n                .eyedropper-btn:hover { opacity: 1; }\n                .eyedropper-active { cursor: crosshair !important; }\n            ",document.head.appendChild(u);let c=null;document.querySelectorAll(".eyedropper-btn").forEach(e=>{e.addEventListener("click",e=>{const t=e.target.dataset.target;c===t?(c=null,UI.displayCanvas.classList.remove("eyedropper-active")):(c=t,UI.displayCanvas.classList.add("eyedropper-active")),e.stopPropagation()})}),UI.displayCanvas.addEventListener("click",e=>{if(!c)return;const t=UI.displayCanvas.getBoundingClientRect(),a=e.clientX-t.left,r=e.clientY-t.top,o=state.gl,s=UI.displayCanvas,n=(s.width,s.height,state.width/state.height);let i,l,u,m;if(n>t.width/t.height?(i=t.width,l=t.width/n,u=0,m=(t.height-l)/2):(l=t.height,i=t.height*n,u=(t.width-i)/2,m=0),a<u||a>u+i||r<m||r>m+l)return;const d=(a-u)/i,g=(r-m)/l,f=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,f),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,state.textures.base,0);const p=Math.floor(d*state.width),h=Math.floor((1-g)*state.height),U=new Uint8Array(4);o.readPixels(p,h,1,1,o.RGBA,o.UNSIGNED_BYTE,U),o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(f);const E="#"+((1<<24)+(U[0]<<16)+(U[1]<<8)+U[2]).toString(16).slice(1),I=document.getElementById(c);I&&(I.value=E,I.dispatchEvent(new Event("input")),I.dispatchEvent(new Event("change"))),c=null,UI.displayCanvas.classList.remove("eyedropper-active")}),window.addEventListener("keydown",e=>{"Escape"===e.key&&c&&(c=null,UI.displayCanvas.classList.remove("eyedropper-active"))})});let renderRequested=!1;function requestRender(){!renderRequested&&state.baseImage&&(renderRequested=!0,requestAnimationFrame(()=>{renderFrame(),renderRequested=!1}))}function initWebGL(){state.canvas=UI.displayCanvas;const e=state.canvas.getContext("webgl2",{antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!0});if(!e)return void alert("WebGL2 not supported.");e.getExtension("EXT_color_buffer_float"),e.getExtension("OES_texture_float_linear"),state.gl=e,e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),state.programs={adjust:createProgram(e,"vs-quad","fs-adjust"),adjustMasked:createProgram(e,"vs-quad","fs-adjustMasked"),mask:createProgram(e,"vs-quad","fs-mask"),colorMask:createProgram(e,"vs-quad","fs-colorMask"),noise:createProgram(e,"vs-quad","fs-noise"),blur:createProgram(e,"vs-quad","fs-blur"),maskedBlur:createProgram(e,"vs-quad","fs-maskedBlur"),composite:createProgram(e,"vs-quad","fs-composite"),chroma:createProgram(e,"vs-quad","fs-chroma"),copy:createProgram(e,"vs-quad","fs-copy"),dither:createProgram(e,"vs-quad","fs-dither"),maskedDither:createProgram(e,"vs-quad","fs-maskedDither"),corruption:createProgram(e,"vs-quad","fs-corruption"),cell:createProgram(e,"vs-quad","fs-cell"),halftone:createProgram(e,"vs-quad","fs-halftone"),bilateral:createProgram(e,"vs-quad","fs-bilateral"),palette:createProgram(e,"vs-quad","fs-palette"),edge:createProgram(e,"vs-quad","fs-edge"),invert:createProgram(e,"vs-quad","fs-invert"),radial:createProgram(e,"vs-quad","fs-radial"),final:createProgram(e,"vs-quad","fs-final")};const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,-1,1,0,1,1,-1,1,0,1,1,1,1]),e.STATIC_DRAW),Object.values(state.programs).forEach(t=>{e.useProgram(t);const a=e.getAttribLocation(t,"a_pos"),r=e.getAttribLocation(t,"a_uv");e.enableVertexAttribArray(a),e.enableVertexAttribArray(r),e.vertexAttribPointer(a,2,e.FLOAT,!1,16,0),e.vertexAttribPointer(r,2,e.FLOAT,!1,16,8)});const a=createTexture(e,null,320,180),r=e.createFramebuffer();if(e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0),state.thumbnailFBO={fbo:r,tex:a,w:320,h:180},UI.gpuMaxRes){const t=e.getParameter(e.MAX_TEXTURE_SIZE);UI.gpuMaxRes.textContent=`${t}px`}}function loadNewImage(e){state.baseImage=e,state.width=e.width,state.height=e.height;const t=state.gl;state.textures.base&&(t.deleteTexture(state.textures.base),state.textures.base=null),state.textures.base=createTexture(t,e),state.fboWidth=0,state.fboHeight=0,reallocateBuffers(!1),UI.downloadBtn.disabled=!1,UI.downloadCurrentBtn.disabled=!1,UI.compareBtn.disabled=!1,UI.overlayCanvas.width=e.width,UI.overlayCanvas.height=e.height,UI.overlayCanvas.getContext("2d").drawImage(e,0,0),UI.caPin.classList.add("active"),setupLayerGridDOM(),requestRender()}function reallocateBuffers(e=!1){const t=state.gl,a=t.getParameter(t.MAX_TEXTURE_SIZE);let r,o;if(e){let e=state.width*state.upscaleFactor,t=state.height*state.upscaleFactor,s=1;(e>a||t>a)&&(s=Math.min(a/e,a/t)),r=Math.round(state.width*state.upscaleFactor*s),o=Math.round(state.height*state.upscaleFactor*s),state._exportScale=s}else{const e=state.clampPreview?2048:a;let t=state.width*state.upscaleFactor,s=state.height*state.upscaleFactor,n=1;if((t>e||s>e)&&(n=Math.min(e/t,e/s)),r=Math.round(t*n),o=Math.round(s*n),r>a||o>a){const e=Math.min(a/r,a/o);r=Math.floor(r*e),o=Math.floor(o*e)}state._exportScale=n}if(state.renderWidth=r,state.renderHeight=o,state.fboWidth===r&&state.fboHeight===o)return{w:r,h:o};state.fboWidth=r,state.fboHeight=o;const s=(e=!0)=>{const a=createTexture(t,null,r,o,e),s=t.createFramebuffer();return t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,a,0),{tex:a,fbo:s}};state.pingPong[0]?.tex&&(t.deleteTexture(state.pingPong[0].tex),t.deleteFramebuffer(state.pingPong[0].fbo)),state.pingPong[1]?.tex&&(t.deleteTexture(state.pingPong[1].tex),t.deleteFramebuffer(state.pingPong[1].fbo)),state.pingPong[0]=s(),state.pingPong[1]=s(),["tempNoise","blur1","blur2","preview"].forEach(e=>{state.textures[e]&&t.deleteTexture(state.textures[e]),state.fbos[e]&&t.deleteFramebuffer(state.fbos[e])});const n=s();state.textures.tempNoise=n.tex,state.fbos.tempNoise=n.fbo;const i=s();state.textures.blur1=i.tex,state.fbos.blur1=i.fbo;const l=s();state.textures.blur2=l.tex,state.fbos.blur2=l.fbo;const u=s();return state.textures.preview=u.tex,state.fbos.preview=u.fbo,{w:r,h:o}}function renderSingleLayer(e,t,a,r,o,s=!1){const n=state.renderWidth,i=state.renderHeight;if(e.viewport(0,0,n,i),"adjust"===t){if(!UI.adjustEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);let t=null;const n=UI.adjLumaMask?.checked,i=UI.adjColorExclude?.checked;if(n||i){if(e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.clearColor(1,1,1,1),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.DST_COLOR,e.ZERO),n&&(e.useProgram(state.programs.mask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useS"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.adjShadowThreshold?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.adjShadowFade?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useH"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.adjHighlightThreshold?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.adjHighlightFade?.value||0)),e.drawArrays(e.TRIANGLES,0,6)),i){const t=UI.adjExcludeColor?.value||"#000000",r=parseInt(t.slice(1,3),16)/255,o=parseInt(t.slice(3,5),16)/255,s=parseInt(t.slice(5,7),16)/255;e.useProgram(state.programs.colorMask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.colorMask,"u_tex"),0),e.uniform3f(e.getUniformLocation(state.programs.colorMask,"u_targetColor"),r,o,s),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI.adjColorTolerance?.value||10)/100),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI.adjColorFade?.value||0)/100),e.drawArrays(e.TRIANGLES,0,6)}e.disable(e.BLEND),t=state.textures.blur1,t&&UI.adjInvertMask?.checked&&(e.useProgram(state.programs.invert),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.invert,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),t=state.textures.blur2)}e.bindFramebuffer(e.FRAMEBUFFER,r);const l=state.programs.adjustMasked||state.programs.adjust;return e.useProgram(l),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(l,"u_tex"),0),e.uniform1f(e.getUniformLocation(l,"u_bright"),o.u_bright),e.uniform1f(e.getUniformLocation(l,"u_cont"),o.u_cont),e.uniform1f(e.getUniformLocation(l,"u_sat"),o.u_sat),e.uniform1f(e.getUniformLocation(l,"u_hdrTol"),0),e.uniform1f(e.getUniformLocation(l,"u_hdrAmt"),0),e.uniform1f(e.getUniformLocation(l,"u_warmth"),o.u_warmth),e.uniform1f(e.getUniformLocation(l,"u_sharp"),o.u_sharp),e.uniform1f(e.getUniformLocation(l,"u_sharpThresh"),o.u_sharpThresh),e.uniform2f(e.getUniformLocation(l,"u_step"),o.u_step[0],o.u_step[1]),t&&l?(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(l,"u_mask"),1),e.uniform1i(e.getUniformLocation(l,"u_useMask"),1)):l&&e.uniform1i(e.getUniformLocation(l,"u_useMask"),0),e.drawArrays(e.TRIANGLES,0,6),r}if("hdr"===t){if(!UI.hdrEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.adjust),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.adjust,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_bright"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_cont"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_sat"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_warmth"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_sharp"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_hdrTol"),o.u_hdrTol),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_hdrAmt"),o.u_hdrAmt),e.drawArrays(e.TRIANGLES,0,6)}else if("noise"===t){if(!UI.noiseEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.useProgram(state.programs.noise),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.tempNoise),e.uniform1i(e.getUniformLocation(state.programs.noise,"u_type"),parseInt(UI.noiseType.value)),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_seed"),100*Math.random()),e.uniform2f(e.getUniformLocation(state.programs.noise,"u_res"),n,i),e.uniform2f(e.getUniformLocation(state.programs.noise,"u_origRes"),state.width*state.upscaleFactor,state.height*state.upscaleFactor),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_scale"),parseFloat(UI.noiseSize.value)),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_paramA"),parseFloat(document.getElementById("noiseParamA").value)/100),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_paramB"),parseFloat(document.getElementById("noiseParamB").value)/100),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_paramC"),parseFloat(document.getElementById("noiseParamC").value)/100),e.drawArrays(e.TRIANGLES,0,6);const t=parseFloat(UI.blurriness.value)/100;let o=state.textures.tempNoise;if(t>0&&(e.useProgram(state.programs.blur),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.bindTexture(e.TEXTURE_2D,state.textures.tempNoise),e.uniform1i(e.getUniformLocation(state.programs.blur,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.blur,"u_dir"),1/n,0),e.uniform1f(e.getUniformLocation(state.programs.blur,"u_rad"),2*t),e.drawArrays(e.TRIANGLES,0,6),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.bindTexture(e.TEXTURE_2D,state.textures.blur1),e.uniform2f(e.getUniformLocation(state.programs.blur,"u_dir"),0,1/i),e.drawArrays(e.TRIANGLES,0,6),o=state.textures.blur2),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.clearColor(1,1,1,1),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.DST_COLOR,e.ZERO),UI.noiseLumaMask.checked&&(e.useProgram(state.programs.mask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useS"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.shadowThreshold.value)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.shadowFade.value)),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useH"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.highlightThreshold.value)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.highlightFade.value)),e.drawArrays(e.TRIANGLES,0,6)),UI.noiseColorExclude.checked){const t=hexToRgb(UI.noiseExcludeColor.value);e.useProgram(state.programs.colorMask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.colorMask,"u_tex"),0),e.uniform3f(e.getUniformLocation(state.programs.colorMask,"u_targetColor"),t.r,t.g,t.b),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI.noiseColorTolerance.value)/100),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI.noiseColorFade.value)/100),e.drawArrays(e.TRIANGLES,0,6)}e.disable(e.BLEND);let l=state.textures.blur1;if(UI.noiseInvertMask.checked){const t=o===state.textures.blur2?state.fbos.tempNoise:state.fbos.blur2,a=o===state.textures.blur2?state.textures.tempNoise:state.textures.blur2;e.useProgram(state.programs.invert),e.bindFramebuffer(e.FRAMEBUFFER,t),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,l),e.uniform1i(e.getUniformLocation(state.programs.invert,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),l=a}e.useProgram(state.programs.composite),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,o),e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,l),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_base"),0),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_noise"),1),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_mask"),2),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_mode"),parseInt(UI.blendMode.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_opacity"),parseFloat(UI.opacity.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_str"),parseFloat(UI.strength.value)),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_nType"),parseInt(UI.noiseType.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_satStr"),parseFloat(UI.satStrength.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_satImp"),parseFloat(UI.satPerNoise.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_skinProt"),parseFloat(UI.skinProtection.value)),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_ignA"),UI.ignoreAlphaToggle.checked?1:0),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_ignAstr"),parseFloat(UI.ignoreAlphaStrength.value)),e.drawArrays(e.TRIANGLES,0,6)}else if("ca"===t){if(!UI.caEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.chroma),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.chroma,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_amt"),o.u_ca_amt),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_blur"),o.u_ca_blur),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_zoomBlur"),parseFloat(UI.aberrationZoomBlur.value)/50),e.uniform2f(e.getUniformLocation(state.programs.chroma,"u_center"),o.u_ca_center[0],o.u_ca_center[1]),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_radius"),o.u_ca_rad),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_falloff"),o.u_ca_fall),e.uniform1i(e.getUniformLocation(state.programs.chroma,"u_falloffToBlur"),UI.caFalloffToBlur.checked?1:0),e.drawArrays(e.TRIANGLES,0,6)}else if("blur"===t){if(!UI.blurEnable?.checked)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);let t=null;const o=UI.blurLumaMask?.checked,s=UI.blurColorExclude?.checked;if(o||s){if(e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.clearColor(1,1,1,1),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.DST_COLOR,e.ZERO),o&&(e.useProgram(state.programs.mask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useS"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.blurShadowThreshold?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.blurShadowFade?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useH"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.blurHighlightThreshold?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.blurHighlightFade?.value||0)),e.drawArrays(e.TRIANGLES,0,6)),s){const t=UI.blurTargetColor?.value||"#000000",r=parseInt(t.slice(1,3),16)/255,o=parseInt(t.slice(3,5),16)/255,s=parseInt(t.slice(5,7),16)/255;e.useProgram(state.programs.colorMask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.colorMask,"u_tex"),0),e.uniform3f(e.getUniformLocation(state.programs.colorMask,"u_targetColor"),r,o,s),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI.blurColorTolerance?.value||10)/100),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI.blurColorFade?.value||20)/100),e.drawArrays(e.TRIANGLES,0,6)}e.disable(e.BLEND),e.disable(e.BLEND),t=state.textures.blur1,t&&UI.blurInvertMask?.checked&&(e.useProgram(state.programs.invert),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.tempNoise),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.invert,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),t=state.textures.tempNoise)}const l=parseFloat(UI.blurAmount?.value||0)/100;if(l>0){const o=t?state.programs.maskedBlur:state.programs.blur;e.useProgram(o),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(o,"u_tex"),0),e.uniform2f(e.getUniformLocation(o,"u_dir"),1/n,0),e.uniform1f(e.getUniformLocation(o,"u_rad"),2*l),e.uniform1i(e.getUniformLocation(o,"u_blurType"),parseInt(UI.blurType?.value||0)),t&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(o,"u_mask"),1)),e.drawArrays(e.TRIANGLES,0,6),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,state.textures.blur2),e.uniform1i(e.getUniformLocation(o,"u_tex"),0),e.uniform2f(e.getUniformLocation(o,"u_dir"),0,1/i),e.uniform1f(e.getUniformLocation(o,"u_rad"),2*l),e.uniform1i(e.getUniformLocation(o,"u_blurType"),parseInt(UI.blurType?.value||0)),t&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(o,"u_mask"),1)),e.drawArrays(e.TRIANGLES,0,6)}else e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6)}else if("cell"===t){if(!UI.cellEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.cell),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.cell,"u_res"),n,i),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_levels"),parseInt(UI.cellLevels?.value||4)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_bias"),parseFloat(UI.cellBias?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_gamma"),parseFloat(UI.cellGamma?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_quantMode"),parseInt(UI.cellQuantMode?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_bandMap"),parseInt(UI.cellBandMap?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_edgeMethod"),parseInt(UI.cellEdgeMethod?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_edgeStr"),parseFloat(UI.cellEdgeStr?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_edgeThick"),parseFloat(UI.cellEdgeThick?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_colorPreserve"),UI.cellColorPreserve?.checked?1:0),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_edgeEnable"),UI.cellEdgeEnable?.checked?1:0),e.drawArrays(e.TRIANGLES,0,6)}else if("halftone"===t){if(!UI.halftoneEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.halftone),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.halftone,"u_res"),n,i),e.uniform1f(e.getUniformLocation(state.programs.halftone,"u_size"),parseFloat(UI.halftoneSize?.value||4)),e.uniform1f(e.getUniformLocation(state.programs.halftone,"u_intensity"),parseFloat(UI.halftoneIntensity?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.halftone,"u_sharpness"),parseFloat(UI.halftoneSharpness?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_pattern"),parseInt(UI.halftonePattern?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_colorMode"),parseInt(UI.halftoneColorMode?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_sample"),parseInt(UI.halftoneSample?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_gray"),UI.halftoneGray?.checked?1:0),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_lock"),UI.halftoneScreenLock?.checked?1:0),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_invert"),UI.halftoneInvert?.checked?1:0),e.drawArrays(e.TRIANGLES,0,6)}else if("bilateral"===t){if(!UI.bilateralEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);Math.max(1,parseInt(UI.bilateralIter?.value||1));e.useProgram(state.programs.bilateral),e.uniform2f(e.getUniformLocation(state.programs.bilateral,"u_res"),n,i),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_radius"),parseInt(UI.bilateralRadius?.value||2)),e.uniform1f(e.getUniformLocation(state.programs.bilateral,"u_sigmaCol"),parseFloat(UI.bilateralColorSig?.value||.1)),e.uniform1f(e.getUniformLocation(state.programs.bilateral,"u_sigmaSpace"),parseFloat(UI.bilateralSpatialSig?.value||2)),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_kernel"),parseInt(UI.bilateralKernel?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_edgeMode"),parseInt(UI.bilateralEdgeMode?.value||0)),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6)}else if("dither"===t){if(!UI.ditherEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);let t=null;const o=UI.ditherLumaMask?.checked,l=UI.ditherColorExclude?.checked;if((o||l)&&state.fbos.blur1){if(e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.clearColor(1,1,1,1),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.DST_COLOR,e.ZERO),o&&(e.useProgram(state.programs.mask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useS"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.ditherShadowThreshold.value)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.ditherShadowFade.value)),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useH"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.ditherHighlightThreshold.value)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.ditherHighlightFade.value)),e.drawArrays(e.TRIANGLES,0,6)),l){const t=UI.ditherExcludeColor?.value||"#000000",r=parseInt(t.slice(1,3),16)/255,o=parseInt(t.slice(3,5),16)/255,s=parseInt(t.slice(5,7),16)/255;e.useProgram(state.programs.colorMask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.colorMask,"u_tex"),0),e.uniform3f(e.getUniformLocation(state.programs.colorMask,"u_targetColor"),r,o,s),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI.ditherColorTolerance?.value||10)/100),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI.ditherColorFade?.value||0)/100),e.drawArrays(e.TRIANGLES,0,6)}e.disable(e.BLEND),t=state.textures.blur1,t&&UI.ditherInvertMask?.checked&&(e.useProgram(state.programs.invert),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.invert,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),t=state.textures.blur2)}const u=t?state.programs.maskedDither:state.programs.dither;e.useProgram(u),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(u,"u_tex"),0),e.uniform1i(e.getUniformLocation(u,"u_type"),parseInt(UI.ditherType?.value||0)),e.uniform1f(e.getUniformLocation(u,"u_bitDepth"),parseFloat(UI.ditherBitDepth.value)),e.uniform1f(e.getUniformLocation(u,"u_paletteSize"),parseFloat(UI.ditherPaletteSize.value)),e.uniform1f(e.getUniformLocation(u,"u_strength"),parseFloat(UI.ditherStrength.value)/100),e.uniform1f(e.getUniformLocation(u,"u_scale"),parseFloat(UI.ditherScale.value)),e.uniform2f(e.getUniformLocation(u,"u_res"),n,i),e.uniform1f(e.getUniformLocation(u,"u_seed"),100*Math.random()),t&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(u,"u_mask"),1)),e.drawArrays(e.TRIANGLES,0,6)}else if("corruption"===t){if(!UI.corruptionEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.corruption),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.corruption,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.corruption,"u_algorithm"),parseInt(UI.corruptionAlgorithm?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.corruption,"u_resScale"),parseFloat(UI.corruptionResScale?.value||1)),e.uniform2f(e.getUniformLocation(state.programs.corruption,"u_res"),n,i),e.drawArrays(e.TRIANGLES,0,6)}else if("palette"===t){if(!UI.paletteEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.palette),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.palette,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.palette,"u_blend"),parseFloat(UI.paletteBlend?.value||100)/100),e.uniform1f(e.getUniformLocation(state.programs.palette,"u_smoothing"),parseFloat(UI.paletteSmoothing?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.palette,"u_smoothingType"),parseInt(UI.paletteSmoothingType?.value||0)),e.uniform2f(e.getUniformLocation(state.programs.palette,"u_res"),n,i);const t=Math.min(state.palette.length,256);e.uniform1i(e.getUniformLocation(state.programs.palette,"u_paletteSize"),t);const o=new Float32Array(768);for(let e=0;e<t;e++){const t=state.palette[e];o[3*e+0]=parseInt(t.slice(1,3),16)/255,o[3*e+1]=parseInt(t.slice(3,5),16)/255,o[3*e+2]=parseInt(t.slice(5,7),16)/255}e.uniform3fv(e.getUniformLocation(state.programs.palette,"u_palette"),o),e.drawArrays(e.TRIANGLES,0,6)}else if("edge"===t){if(!UI.edgeEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),void e.drawArrays(e.TRIANGLES,0,6);e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.edge),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.edge,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.edge,"u_res"),n,i),e.uniform1i(e.getUniformLocation(state.programs.edge,"u_mode"),parseInt(UI.edgeMode?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_strength"),parseFloat(UI.edgeStrength?.value||500)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_tolerance"),parseFloat(UI.edgeTolerance?.value||10)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_bgSat"),parseFloat(UI.edgeBgSat?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_fgSat"),parseFloat(UI.edgeFgSat?.value||150)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_bloom"),parseFloat(UI.edgeBloom?.value||10)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_smooth"),parseFloat(UI.edgeSmooth?.value||50)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_blend"),parseFloat(UI.edgeBlend?.value||100)),e.drawArrays(e.TRIANGLES,0,6)}}function renderFrame(e=!1){if(!state.baseImage)return;if(!e){const e=performance.now();if(state.lastFrameTime>0){const t=e-state.lastFrameTime;state.realtimeFps=1e3/t}state.lastFrameTime=e,state.frameRenderCount++,state.frameRenderCount%15==0&&(UI.actualFps.textContent=`(Actual: ${Math.round(state.realtimeFps)} FPS)`)}const t=state.gl,a=reallocateBuffers(e),r=a.w,o=a.h;t.viewport(0,0,r,o);let s=0,n=1,i=state.textures.base;if(e&&(r!==state.width||o!==state.height)){const e=document.createElement("canvas");e.width=r,e.height=o;e.getContext("2d").drawImage(state.baseImage,0,0,state.width,state.height,0,0,r,o),i=t.createTexture(),t.bindTexture(t.TEXTURE_2D,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)}t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[0].fbo),t.useProgram(state.programs.copy),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,i),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6),e&&i!==state.textures.base&&t.deleteTexture(i);const l={u_bright:parseFloat(UI.brightness.value),u_cont:parseFloat(UI.contrast.value),u_sat:parseFloat(UI.saturationAdj.value)/100,u_warmth:parseFloat(UI.warmth.value),u_sharp:parseFloat(UI.sharpen.value),u_sharpThresh:parseFloat(UI.sharpenThreshold.value),u_step:[1/r,1/o],u_hdrTol:parseFloat(UI.hdrTolerance.value),u_hdrAmt:parseFloat(UI.hdrAmount.value),u_ca_amt:calcCurve(parseFloat(UI.aberrationAmount.value),300,300),u_ca_blur:calcCurve(parseFloat(UI.aberrationBlur.value),100,100),u_ca_center:[state.caCenter.x,state.caCenter.y],u_ca_rad:parseFloat(UI.caRadius.value)/1e3,u_ca_fall:parseFloat(UI.caFalloff.value)/1e3};state.renderOrder.forEach(e=>{if(!state.layerVisibility[e])return;renderSingleLayer(t,e,state.pingPong[s].tex,state.pingPong[n].fbo,l),state.layerTextures[e]=state.pingPong[n].tex;let a=s;s=n,n=a}),t.bindFramebuffer(t.FRAMEBUFFER,null),t.canvas.width===r&&t.canvas.height===o||(t.canvas.width=r,t.canvas.height=o),t.viewport(0,0,r,o);const u=state.activeLayerPreview&&state.layerTextures[state.activeLayerPreview]?state.layerTextures[state.activeLayerPreview]:state.pingPong[s].tex;let c=0;if("shadows"===state.activeLayerPreview&&(c=2),"highlights"===state.activeLayerPreview&&(c=3),0===c?(t.useProgram(state.programs.final),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,u),t.uniform1i(t.getUniformLocation(state.programs.final,"u_tex"),0),t.uniform2f(t.getUniformLocation(state.programs.final,"u_res"),r,o)):(t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,u),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),c)),t.drawArrays(t.TRIANGLES,0,6),e)t.finish();else if(updateLayerPreviews(),state.previewWindow&&!state.previewWindow.closed)try{const e=state.previewWindow.document.getElementById("fs-canvas");if(e){e.width===r&&e.height===o||(e.width=r,e.height=o);e.getContext("2d").drawImage(t.canvas,0,0)}else state.previewWindow=null}catch(e){state.previewWindow=null,console.warn("Preview sync error:",e)}}function calcCurve(e,t,a=1){const r=e/t;return r*r*a}function updatePinPosition(){const e=100*state.caCenter.x,t=100*(1-state.caCenter.y);UI.caPin.style.left=e+"%",UI.caPin.style.top=t+"%"}function updatePaletteUI(){UI.paletteList.innerHTML="",state.palette.forEach((e,t)=>{const a=document.createElement("div");a.className="palette-color-item",a.innerHTML=`\n                    <input type="color" value="${e}">\n                    <button class="remove-color-btn" title="Remove">&times;</button>\n                `,a.querySelector("input").addEventListener("input",e=>{state.palette[t]=e.target.value,requestRender()}),a.querySelector(".remove-color-btn").addEventListener("click",()=>{state.palette.splice(t,1),updatePaletteUI(),requestRender()}),UI.paletteList.appendChild(a)})}function syncNoiseUI(){const e=parseInt(UI.noiseType.value),t=document.getElementById("noiseParamsHeader"),a=document.getElementById("noiseParamRowA"),r=document.getElementById("noiseParamRowB"),o=document.getElementById("noiseParamRowC"),s=document.getElementById("noiseLabelA"),n=document.getElementById("noiseLabelB"),i=document.getElementById("noiseLabelC");[t,a,r,o].forEach(e=>e.style.display="none");const l=(e,l,u)=>{t.style.display="block",e&&(a.style.display="flex",s.textContent=e),l&&(r.style.display="flex",n.textContent=l),u&&(o.style.display="flex",i.textContent=u)};switch(e){case 5:l("Complexity","Organic Flow","Octave Mix"),UI.noiseParamA.min=1,UI.noiseParamA.max=8,UI.noiseParamA.step=1,UI.noiseParamA.value>8&&(UI.noiseParamA.value=4);break;case 6:l("Cell Jitter","Density","Sphericity"),UI.noiseParamA.min=0,UI.noiseParamA.max=100,UI.noiseParamA.step=1;break;case 7:l("Line Thickness","Vertical Jitter","Sync Grain");break;case 8:l("Density","Sharpness","Variable Size");break;case 9:l("Block Size","Horiz Shift","RGB Split");break;case 10:l("Stretch","Rotation","Fiber Link");break;case 11:l("Cell Detail","Randomness","Smoothness");break;case 12:l("Line Density","Diagonal Angle","Pressure")}}async function extractPaletteFromImage(e,t){const a=document.createElement("canvas"),r=a.getContext("2d"),o=128;a.width=o,a.height=o,r.drawImage(e,0,0,o,o);const s=r.getImageData(0,0,o,o).data,n={};for(let e=0;e<s.length;e+=4){if(s[e+3]<128)continue;const t="#"+((1<<24)+(s[e]<<16)+(s[e+1]<<8)+s[e+2]).toString(16).slice(1).toUpperCase();n[t]=(n[t]||0)+1}const i=Object.entries(n).map(([e,t])=>({hex:e,freq:t,r:parseInt(e.slice(1,3),16),g:parseInt(e.slice(3,5),16),b:parseInt(e.slice(5,7),16)}));if(0===i.length)return;const l=[];i.sort((e,t)=>t.freq-e.freq),l.push(i[0]);const u=new Float32Array(i.length).fill(1e10),c=e=>{for(let t=0;t<i.length;t++){const a=i[t],r=Math.sqrt(Math.pow(a.r-e.r,2)+Math.pow(a.g-e.g,2)+Math.pow(a.b-e.b,2));r<u[t]&&(u[t]=r)}};c(l[0]);const m=Math.min(t,i.length);for(;l.length<m;){let e=-1,t=-1;for(let a=0;a<i.length;a++)u[a]>t&&(t=u[a],e=a);if(-1===e)break;const a=i[e];l.push(a),c(a)}state.palette=l.map(e=>e.hex),updatePaletteUI(),requestRender()}function createShader(e,t,a){const r=document.getElementById(a).text.trim(),o=e.createShader("vs-quad"==t?e.VERTEX_SHADER:e.FRAGMENT_SHADER);return e.shaderSource(o,r),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.error(e.getShaderInfoLog(o)),null)}function createProgram(e,t,a){const r=createShader(e,"vs-quad",t),o=createShader(e,"fs-fragment",a),s=e.createProgram();return e.attachShader(s,r),e.attachShader(s,o),e.linkProgram(s),s}function createTexture(e,t,a,r,o=!1){const s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR);const n=o?e.RGBA16F:e.RGBA,i=e.RGBA,l=o?e.HALF_FLOAT:e.UNSIGNED_BYTE;return t?e.texImage2D(e.TEXTURE_2D,0,n,i,l,t):e.texImage2D(e.TEXTURE_2D,0,n,a,r,0,i,l,null),s}function hexToRgb(e){return{r:parseInt(e.slice(1,3),16)/255,g:parseInt(e.slice(3,5),16)/255,b:parseInt(e.slice(5,7),16)/255}}async function downloadFullRes(){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),reallocateBuffers(!0),renderFrame(!0);const e=document.createElement("a");e.download="grain-export.png",e.href=state.canvas.toDataURL("image/png",1),e.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function openCompare(){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const e=document.getElementById("compareOriginal"),t=document.getElementById("compareProcessed"),a=state.width/state.height;e.width=600,e.height=600/a,t.width=600,t.height=600/a;const r=e.getContext("2d"),o=t.getContext("2d");if(r.drawImage(state.baseImage,0,0,e.width,e.height),o.drawImage(state.canvas,0,0,t.width,t.height),UI.exportInfo){const e=Math.round(state.width*state.upscaleFactor),t=Math.round(state.height*state.upscaleFactor),a=state.renderWidth,r=state.renderHeight,o=state._exportScale||1;UI.exportInfo.innerHTML=`Requested: ${e}x${t} | Actual: ${a}x${r} (Safe Scale: ${o.toFixed(2)})`,UI.exportInfo.style.color=o<1?"#ffaa00":"#0f0"}document.getElementById("compareModal").classList.add("show"),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function exportComparison(e){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const t=state.canvas.toDataURL(),a=new Image;a.src=t,await new Promise(e=>a.onload=e);const r=document.createElement("canvas"),o=state.canvas.width,s=state.canvas.height;if("side"===e){r.width=2*o,r.height=s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0,o,s),e.drawImage(a,o,0)}else{r.width=o,r.height=2*s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0,o,s),e.drawImage(a,0,s)}const n=document.createElement("a");n.download=`grain-compare-${e}.png`,n.href=r.toDataURL("image/png",.9),n.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}function openFullscreenPreview(){if(state.previewWindow&&!state.previewWindow.closed)return void state.previewWindow.focus();const e=window.open("","NoiseStudioPreview","width=800,height=600");if(!e)return void alert("Pop-up blocked. Please allow pop-ups for this site.");const t=e.document;t.open(),t.write(""),t.close(),t.title="Noise Studio Preview",t.body.style.margin="0",t.body.style.background="#111",t.body.style.height="100vh",t.body.style.display="flex",t.body.style.alignItems="center",t.body.style.justifyContent="center",t.body.style.overflow="hidden";const a=t.createElement("canvas");a.id="fs-canvas",a.style.maxWidth="100%",a.style.maxHeight="100%",a.style.objectFit="contain",a.style.boxShadow="0 0 20px rgba(0,0,0,0.5)",t.body.appendChild(a),state.previewWindow=e,setTimeout(()=>requestRender(),100)}function getSectionFromId(e){return e?e.startsWith("adj")||"brightness"===e||"contrast"===e||"saturationAdj"===e||"warmth"===e||"sharpen"===e?"adjust":e.startsWith("hdr")?"hdr":e.startsWith("noise")||"opacity"===e||"strength"===e||"blendMode"===e||e.startsWith("sat")||e.startsWith("ignore")?"noise":e.startsWith("blur")?"blur":e.startsWith("dither")?"dither":e.startsWith("cell")?"cell":e.startsWith("halftone")?"halftone":e.startsWith("bilateral")?"bilateral":e.startsWith("aberration")||e.startsWith("ca")?"ca":e.startsWith("corruption")?"corruption":e.startsWith("palette")?"palette":e.startsWith("edge")?"edge":"adjust":null}function setupLayerGridDOM(e){const t=UI.layerGrid;t.innerHTML="";const a=[{id:"chain",label:"Chain"},{id:"isolated",label:"Isolated"}];!{blur:!0,dither:!0,halftone:!0,bilateral:!0,adjust:!0,noise:!0}[e]?"ca"===e&&a.push({id:"falloff",label:"Falloff Map"}):(a.push({id:"mask_luma",label:"Luma Mask"}),a.push({id:"mask_color",label:"Color Mask"}),a.push({id:"mask_total",label:"Total Mask"}));const r=state.width/state.height,o=110*r;a.forEach(a=>{const r=document.createElement("div");r.className="layer-item",r.style.minWidth=`${Math.max(80,o)}px`,r.style.flex="0 0 auto";const s=e+"_"+a.id;state.activeLayerPreview===s&&r.classList.add("active"),r.onclick=()=>{const t=e+"_"+a.id;state.activeLayerPreview===t?(state.activeLayerPreview=null,r.classList.remove("active")):(state.activeLayerPreview=t,document.querySelectorAll(".layer-item").forEach(e=>e.classList.remove("active")),r.classList.add("active"),UI.overlayOriginal.classList.remove("show")),requestRender()},r.innerHTML=`\n                    <div class="layer-title">${a.label}</div>\n                    <canvas class="layer-canvas" id="thumb-${a.id}" width="${Math.round(o)}" height="110"></canvas>\n                `,t.appendChild(r)})}function updateLayerPreviews(){const e=state.gl;if(!state.baseImage)return;const t=state.activeSection||"adjust";if(state.lastActiveSectionDOM!==t&&(setupLayerGridDOM(t),state.lastActiveSectionDOM=t),!state.thumbnailFBO)return;drawToThumbnail(state.layerTextures[t],"thumb-chain");const a=state.renderOrder.indexOf(t),r=a>0?state.layerTextures[state.renderOrder[a-1]]:state.textures.base,o={u_bright:parseFloat(UI.brightness.value),u_cont:parseFloat(UI.contrast.value),u_sat:parseFloat(UI.saturationAdj.value)/100,u_warmth:parseFloat(UI.warmth.value),u_sharp:parseFloat(UI.sharpen.value),u_sharpThresh:parseFloat(UI.sharpenThreshold.value),u_step:[1/state.renderWidth,1/state.renderHeight],u_hdrTol:parseFloat(UI.hdrTolerance.value),u_hdrAmt:parseFloat(UI.hdrAmount.value),u_ca_amt:calcCurve(parseFloat(UI.aberrationAmount.value),300,300),u_ca_blur:calcCurve(parseFloat(UI.aberrationBlur.value),100,100),u_ca_center:[state.caCenter.x,state.caCenter.y],u_ca_rad:parseFloat(UI.caRadius.value)/1e3,u_ca_falloff:parseFloat(UI.caFalloff.value)/1e3};renderSingleLayer(e,t,r,state.fbos.preview,o,!0),drawToThumbnail(state.textures.preview,"thumb-isolated"),state.activeLayerPreview===t+"_isolated"&&(state.layerTextures[state.activeLayerPreview]=state.textures.preview);const s=document.getElementById("thumb-mask_luma"),n=document.getElementById("thumb-mask_color"),i=document.getElementById("thumb-mask_total");(s||n||i)&&(renderMaskForSection(t,r),s&&(drawToThumbnail(state.textures.maskLuma,"thumb-mask_luma",1),state.activeLayerPreview===t+"_mask_luma"&&(state.layerTextures[state.activeLayerPreview]=state.textures.maskLuma)),n&&(drawToThumbnail(state.textures.maskColor,"thumb-mask_color",0),state.activeLayerPreview===t+"_mask_color"&&(state.layerTextures[state.activeLayerPreview]=state.textures.maskColor)),i&&(drawToThumbnail(state.textures.maskTotal,"thumb-mask_total",0),state.activeLayerPreview===t+"_mask_total"&&(state.layerTextures[state.activeLayerPreview]=state.textures.maskTotal)));document.getElementById("thumb-falloff")&&(renderCAFalloff(),drawToThumbnail(state.textures.preview,"thumb-falloff"),state.activeLayerPreview===t+"_falloff"&&(state.layerTextures[state.activeLayerPreview]=state.textures.preview))}function renderMaskForSection(e,t){const a=state.gl,r=state.renderWidth,o=state.renderHeight;a.viewport(0,0,r,o),state.textures.maskLuma||(state.textures.maskLuma=createTexture(a,null,r,o),state.fbos.maskLuma=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskLuma),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,state.textures.maskLuma,0),state.textures.maskColor=createTexture(a,null,r,o),state.fbos.maskColor=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskColor),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,state.textures.maskColor,0),state.textures.maskTotal=createTexture(a,null,r,o),state.fbos.maskTotal=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskTotal),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,state.textures.maskTotal,0));let s="adjust"===e?"adj":e;a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskLuma),a.useProgram(state.programs.mask),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,t),a.uniform1i(a.getUniformLocation(state.programs.mask,"u_tex"),0),a.uniform1i(a.getUniformLocation(state.programs.mask,"u_useS"),1),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI[s+"ShadowThreshold"]?.value||UI.shadowThreshold?.value||0)),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI[s+"ShadowFade"]?.value||UI.shadowFade?.value||0)),a.uniform1i(a.getUniformLocation(state.programs.mask,"u_useH"),1),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI[s+"HighlightThreshold"]?.value||UI.highlightThreshold?.value||1)),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI[s+"HighlightFade"]?.value||UI.highlightFade?.value||0)),a.drawArrays(a.TRIANGLES,0,6),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskColor);const n=hexToRgb(UI[s+"ExcludeColor"]?.value||UI.noiseExcludeColor?.value||"#000000");a.useProgram(state.programs.colorMask),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,t),a.uniform1i(a.getUniformLocation(state.programs.colorMask,"u_tex"),0),a.uniform3f(a.getUniformLocation(state.programs.colorMask,"u_targetColor"),n.r,n.g,n.b),a.uniform1f(a.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI[s+"ColorTolerance"]?.value||UI.noiseColorTolerance?.value||.1)/100),a.uniform1f(a.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI[s+"ColorFade"]?.value||UI.noiseColorFade?.value||0)/100),a.drawArrays(a.TRIANGLES,0,6),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskTotal),a.clearColor(1,1,1,1),a.clear(a.COLOR_BUFFER_BIT),a.enable(a.BLEND),a.blendFunc(a.DST_COLOR,a.ZERO),(UI[s+"LumaMask"]?.checked||UI.noiseLumaMask?.checked)&&(a.useProgram(state.programs.copy),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.maskLuma),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_tex"),0),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_channel"),1),a.drawArrays(a.TRIANGLES,0,6)),(UI[s+"ColorExclude"]?.checked||UI.noiseColorExclude?.checked)&&(a.useProgram(state.programs.copy),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.maskColor),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_tex"),0),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_channel"),0),a.drawArrays(a.TRIANGLES,0,6)),a.disable(a.BLEND),(UI[s+"InvertMask"]?.checked||UI.noiseInvertMask?.checked)&&(a.useProgram(state.programs.invert),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.preview),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.maskTotal),a.uniform1i(a.getUniformLocation(state.programs.invert,"u_tex"),0),a.drawArrays(a.TRIANGLES,0,6),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskTotal),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.preview),a.useProgram(state.programs.copy),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_tex"),0),a.drawArrays(a.TRIANGLES,0,6))}function renderCAFalloff(){const e=state.gl,t=state.renderWidth,a=state.renderHeight;e.viewport(0,0,t,a),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.preview),e.useProgram(state.programs.radial),e.uniform2f(e.getUniformLocation(state.programs.radial,"u_res"),t,a),e.uniform2f(e.getUniformLocation(state.programs.radial,"u_center"),state.caCenter.x,state.caCenter.y),e.uniform1f(e.getUniformLocation(state.programs.radial,"u_radius"),parseFloat(UI.caRadius.value)/1e3),e.uniform1f(e.getUniformLocation(state.programs.radial,"u_falloff"),parseFloat(UI.caFalloff.value)/1e3),e.drawArrays(e.TRIANGLES,0,6)}function drawToThumbnail(e,t,a=0){const r=document.getElementById(t);if(!r||!e)return;const o=state.gl,s=r.width,n=r.height;o.bindFramebuffer(o.FRAMEBUFFER,state.thumbnailFBO.fbo),o.viewport(0,0,state.thumbnailFBO.w,state.thumbnailFBO.h),o.useProgram(state.programs.copy),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,e),o.uniform1i(o.getUniformLocation(state.programs.copy,"u_tex"),0),o.uniform1i(o.getUniformLocation(state.programs.copy,"u_channel"),a),o.drawArrays(o.TRIANGLES,0,6);const i=new Uint8Array(state.thumbnailFBO.w*state.thumbnailFBO.h*4);o.readPixels(0,0,state.thumbnailFBO.w,state.thumbnailFBO.h,o.RGBA,o.UNSIGNED_BYTE,i);const l=r.getContext("2d",{alpha:!1}),u=document.createElement("canvas");u.width=state.thumbnailFBO.w,u.height=state.thumbnailFBO.h;const c=u.getContext("2d"),m=state.thumbnailFBO.w,d=state.thumbnailFBO.h,g=new Uint8ClampedArray(m*d*4);for(let e=0;e<d;e++){const t=(d-1-e)*m*4,a=e*m*4;for(let e=0;e<4*m;e++)g[a+e]=i[t+e]}const f=new ImageData(g,m,d);c.putImageData(f,0,0),l.fillStyle="#000",l.fillRect(0,0,s,n),l.drawImage(u,0,0,m,d,0,0,s,n)}document.getElementById("fullscreenPreviewBtn").addEventListener("click",openFullscreenPreview)</script><script type="x-shader/x-fragment" id="fs-final">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    vec4 c = texture(u_tex, v_uv);
    // Standard 1-bit dither to prevent banding on 8-bit output
    float noise = (hash(v_uv * u_res) - 0.5) / 255.0;
    outColor = vec4(c.rgb + noise, c.a);
}</script></body></html>