<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Digital Grain Studio â€” GPU Accelerated</title><style>:root{--bg:#000;--fg:#fff;--panel-max:460px;--muted:#8c8c8c;--accent:#2a9df4;--border:rgba(255,255,255,0.08)}*{box-sizing:border-box}body,html{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'Courier New',monospace}body{padding:16px;display:flex;gap:16px;align-items:flex-start;min-height:100vh}.container{display:flex;gap:16px;width:100%;height:100%}.controls-panel{flex:0 0 var(--panel-max);max-width:var(--panel-max);min-width:260px;padding-right:10px;overflow-y:auto;height:100%;scrollbar-width:thin;scrollbar-color:var(--muted) var(--bg)}.controls-panel h1{font-size:18px;margin:0 0 4px 0;text-align:center;letter-spacing:-.5px}.muted{color:var(--muted);font-size:12px;margin-bottom:12px;display:block;text-align:center}details{border:1px solid var(--border);margin-bottom:8px;padding:6px;border-radius:4px;background:#0a0a0a}summary{cursor:pointer;font-weight:700;margin:0 0 6px 0;outline:0;user-select:none;font-size:13px}summary:hover{color:var(--accent)}.control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;min-height:28px}.control-row label{flex:0 0 130px;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px}input[type=range]{flex:1;accent-color:var(--accent);cursor:pointer}.control-value{width:70px;padding:2px 4px;text-align:right;background:#000;color:var(--fg);border:1px solid var(--border);font-family:monospace;font-size:11px}select.control-value{flex:1;min-width:120px;padding:4px}.row-buttons{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}button{background:#111;color:var(--fg);border:1px solid var(--border);padding:8px 12px;cursor:pointer;font-family:monospace;font-size:12px;transition:all .2s}button:hover:not(:disabled){background:var(--accent);color:#000;border-color:var(--accent)}button:disabled{opacity:.5;cursor:not-allowed}.preview-column{flex:1 1 auto;min-width:320px;display:flex;flex-direction:column;gap:12px;height:100%;overflow:hidden}.preview-top{display:flex;align-items:center;justify-content:space-between;gap:12px}.preview-container{position:relative;border:1px solid var(--border);background:repeating-linear-gradient(45deg,#111 0,#111 10px,#0e0e0e 10px,#0e0e0e 20px);overflow:hidden;flex:1;display:flex;align-items:center;justify-content:center;min-height:300px}canvas{display:block}#displayCanvas{width:100%;height:100%;object-fit:contain;box-shadow:0 0 20px rgba(0,0,0,.5)}.overlay-original{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:10}.overlay-original canvas{width:100%;height:100%;object-fit:contain;opacity:0;transition:opacity .2s ease}.overlay-original.show canvas{opacity:1}.layer-preview-window{border:1px solid var(--border);background:#050505;padding:10px;height:180px;flex:0 0 180px;overflow-y:auto}.layer-grid{display:flex;gap:10px}.layer-item{border:1px solid var(--border);padding:6px;min-width:140px;display:flex;flex-direction:column;gap:6px;background:#000}.layer-title{color:var(--muted);font-size:10px;text-transform:uppercase;text-align:center}.layer-canvas{width:100%;aspect-ratio:16/9;background:#111;border:1px solid #222;object-fit:contain}.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.9);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s;z-index:3000}.modal-overlay.show{opacity:1;pointer-events:auto}.modal{background:#111;border:1px solid var(--border);padding:20px;max-width:90vw;max-height:90vh;overflow:auto;box-shadow:0 0 50px rgba(0,0,0,.8)}#loading{position:fixed;top:10px;right:10px;background:var(--accent);color:#000;padding:4px 8px;font-size:11px;font-weight:700;display:none;z-index:4000}@media (max-width:900px){body{padding:10px;flex-direction:column}.container{flex-direction:column}.controls-panel{width:100%;max-width:none;flex:none;height:auto;max-height:40vh}.preview-column{width:100%;height:50vh}}</style></head><body><div id="loading">PROCESSING GPU...</div><div class="container"><div class="controls-panel"><h1>DIGITAL GRAIN [GPU]</h1><span class="muted">WebGL2 Accelerated Pipeline</span><div style="margin:10px 0;border:1px dashed var(--border);padding:10px;text-align:center"><label for="imageUpload" style="cursor:pointer;display:block"><span style="font-size:24px;display:block;margin-bottom:5px">ðŸ“‚</span> <span style="font-size:12px;color:var(--accent)">CLICK TO LOAD IMAGE</span></label> <input id="imageUpload" type="file" accept="image/*" style="display:none"></div><details open><summary>Noise Basics</summary><div class="control-row"><label>Noise Strength</label> <input id="strength" type="range" min="0" max="150" step="0.1" value="40"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Noise Type</label> <select id="noiseType" class="control-value"><option value="1" selected="selected">Grayscale</option><option value="0">Color</option><option value="2">Blend (Sat)</option></select></div><div class="control-row"><label>Sat Strength</label> <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sat Impact</label> <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details open><summary>Shape & Blur</summary><div class="control-row"><label>Scale (Size)</label> <input id="noiseSize" type="range" min="0" max="1000" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Blurriness</label> <input id="blurriness" type="range" min="0" max="1000" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details open><summary>Blend & Opacity</summary><div class="control-row"><label>Blend Mode</label> <select id="blendMode" class="control-value"><option value="0">Normal</option><option value="1" selected="selected">Overlay</option><option value="2">Screen</option><option value="3">Multiply</option><option value="4">Add</option><option value="5">Difference</option></select></div><div class="control-row"><label>Opacity</label> <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Luminance Masking</summary><div class="control-row"><label>Shadows</label> <input id="enableShadows" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0.3"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0.2"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Highlights</label> <input id="enableHighlights" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>H. Threshold</label> <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0.7"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0.2"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Adjustments</summary><div class="control-row"><label>Brightness</label> <input id="brightness" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast</label> <input id="contrast" type="range" min="-100" max="200" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Saturation</label> <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>HDR Emulation</summary><div class="control-row"><label>Tolerance</label> <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Amount</label> <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Chromatic Aberration</summary><div class="control-row"><label>Amount</label> <input id="aberrationAmount" type="range" min="0" max="300" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Blur</label> <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Center X</label> <input id="centerX" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Center Y</label> <input id="centerY" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Alpha Channel</summary><div class="control-row"><label>Ignore Alpha</label> <input id="ignoreAlphaToggle" type="checkbox" checked="checked"></div><div class="control-row"><label>Strength</label> <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div></details><div class="row-buttons"><button id="downloadBtn" disabled="disabled">DOWNLOAD FULL RES</button> <button id="compareBtn" disabled="disabled">COMPARE / EXPORT</button></div></div><div class="preview-column"><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Main Preview</h3><div style="font-size:11px;color:var(--muted)">Hover image to see original</div></div><div class="preview-container" id="previewContainer"><canvas id="displayCanvas"></canvas><div class="overlay-original" id="overlayOriginal"><canvas id="overlayCanvas"></canvas></div></div><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Layer Breakdown</h3></div><div class="layer-preview-window"><div class="layer-grid" id="layerGrid"></div></div></div></div><div id="compareModal" class="modal-overlay"><div class="modal"><h2 style="margin-top:0">Comparison & Export</h2><div style="display:flex;gap:20px;margin-bottom:20px;justify-content:center;flex-wrap:wrap"><div><div class="muted">Original</div><canvas id="compareOriginal" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div><div><div class="muted">Processed</div><canvas id="compareProcessed" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div></div><div style="text-align:center;display:flex;gap:10px;justify-content:center;flex-wrap:wrap"><button id="exportSideBySide">Export Side-by-Side</button> <button id="exportStacked">Export Stacked</button> <button id="closeCompare">Close</button></div></div></div><script type="x-shader/x-vertex" id="vs-quad">#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-adjust">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;

vec3 rgb2lum(vec3 c) { return vec3(dot(c, vec3(0.299, 0.587, 0.114))); }

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // HDR Emulation (Darken shadows based on tolerance)
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}</script><script type="x-shader/x-fragment" id="fs-mask">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; // bools passed as int
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.299,0.587,0.114));
    
    // Default to fully visible (white) if no masks are active
    if (u_useS == 0 && u_useH == 0) {
        outColor = vec4(1.0, 0.0, 0.0, 1.0);
        return;
    }
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-noise">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; // 0=color, 1=gray, 2=blend
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; // Original image resolution

// Dave Hoskins Hash without Sine (to avoid banding/patterns)
// https://www.shadertoy.com/view/4djSRW
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    // We want the noise size to be consistent regardless of the current preview resolution
    // So we use UV coordinates multiplied by the ORIGINAL resolution, then divided by scale
    vec2 pos = v_uv * u_origRes;
    
    // Pixelate based on scale
    vec2 cell = floor(pos / max(1.0, u_scale));
    
    vec3 n;
    if (u_type == 1) { // Gray
        float r = hash12(cell + u_seed);
        n = vec3(r);
    } else { // Color or Blend Base
        float r = hash12(cell + u_seed);
        float g = hash12(cell + u_seed + 1.23);
        float b = hash12(cell + u_seed + 2.45);
        n = vec3(r, g, b);
    }
    
    outColor = vec4(n, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-blur">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; // (1.0/width, 0) or (0, 1.0/height)
uniform float u_rad;

void main() {
    vec4 color = vec4(0.0);
    // Simple 9-tap gaussian approx
    float total = 0.0;
    // We sample -4 to 4
    for(float i = -4.0; i <= 4.0; i++) {
        float weight = exp(-(i*i) / (2.0 * 2.0)); // sigma ~ 2.0 static for shape, radius controlled by u_dir stride
        // adjust stride by radius
        vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad);
        color += s * weight;
        total += weight;
    }
    outColor = color / total;
}</script><script type="x-shader/x-fragment" id="fs-composite">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; // noise strength (0-150 mapped to 0-1)
uniform int u_nType; // Noise Type
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; // bool
uniform float u_ignAstr;

// Helper: Overlay
float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

vec3 rgb2hsl(vec3 c){
    float cmin = min(c.r, min(c.g, c.b));
    float cmax = max(c.r, max(c.g, c.b));
    float d = cmax - cmin;
    float l = (cmax + cmin) / 2.0;
    float s = l > 0.5 ? d / (2.0 - cmax - cmin) : d / (cmax + cmin);
    if (cmax == cmin) s = 0.0;
    // Hue not needed for saturation adjust only
    return vec3(0.0, s, l); // We cheat, only returning S and L correctly
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); // R=Combined mask intensity (0..1)
    
    // Calculate noise intensity
    // Normalize noise 0..1 to -1..1 centered, then scale by strength
    vec3 n = nc.rgb;
    
    // Blend Mode Logic
    vec3 res;
    vec3 base = bc.rgb;
    
    // 1. Prepare Noise Layer
    // For Blend Mode (Type 2), we ignore the noise texture color and use it as a sat map
    if (u_nType == 2) {
        // Saturation Blend
        // Use Red channel of noise as driver
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        
        float lum = dot(base, vec3(0.299,0.587,0.114));
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * (u_str/50.0)); // simple saturation mod
        res = satColor;
        // In this mode, we replace base, we don't overlay
    } else {
        // Standard Mixing
        // Remap noise 0..1 to effective range based on Strength
        // Basic idea: blend noise onto 0.5 grey, then blend that onto image
        // Better: Apply blending math directly
        
        vec3 noiseLayer = nc.rgb;
        
        // Mode switch
        if (u_mode == 0) { // Normal
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { // Overlay
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { // Screen
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { // Multiply
            res = base * noiseLayer;
        } else if (u_mode == 4) { // Add
            res = base + noiseLayer;
        } else if (u_mode == 5) { // Diff
            res = abs(base - noiseLayer);
        }
        
        // Interpolate between Base and BlendedResult based on Opacity * Mask * Strength
        float maskVal = mc.r; // Combined mask
        
        // If ignore alpha is on, reduce mask where alpha is low
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); // normalize strength a bit
        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}</script><script type="x-shader/x-fragment" id="fs-chroma">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;

void main() {
    if (u_amt <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    // Cubic falloff for nicer edge effect
    float str = dist * dist * (u_amt / 1000.0); // scale down UI value
    
    vec4 result = vec4(0.0);
    
    if (u_blur > 0.0) {
        // Multi-tap blur for the chromatic aberration
        float totalWeight = 0.0;
        // 5 samples
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * u_blur * 0.002; // scalar for blur spread
            float w = exp(-(i*i)/2.0); // gaussian weight
            
            // Sample with offset + blur offset
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t)).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5)).g; // Green slightly affected or just anchor
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t)).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        // Single tap
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}</script><script>const state={gl:null,canvas:null,programs:{},textures:{},fbos:{},thumbnailFBO:null,baseImage:null,width:1,height:1,fboWidth:0,fboHeight:0,busy:!1},UI={};window.addEventListener("DOMContentLoaded",async()=>{["imageUpload","displayCanvas","overlayCanvas","overlayOriginal","strength","noiseType","satStrength","satPerNoise","noiseSize","blurriness","blendMode","opacity","enableShadows","shadowThreshold","shadowFade","enableHighlights","highlightThreshold","highlightFade","brightness","contrast","saturationAdj","hdrTolerance","hdrAmount","ignoreAlphaToggle","ignoreAlphaStrength","aberrationAmount","aberrationBlur","centerX","centerY","downloadBtn","compareBtn","loading","layerGrid","compareOriginal","compareProcessed","closeCompare","exportSideBySide","exportStacked"].forEach(e=>UI[e]=document.getElementById(e)),document.querySelectorAll("input[type=range]").forEach(e=>{const t=e.nextElementSibling;if(t&&t.classList.contains("control-value")){const a=()=>t.value=e.value;e.addEventListener("input",()=>{a(),requestRender()}),a()}}),document.querySelectorAll("select, input[type=checkbox]").forEach(e=>{e.addEventListener("change",requestRender)}),initWebGL(),UI.imageUpload.addEventListener("change",e=>{const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=e=>{const t=new Image;t.onload=()=>loadNewImage(t),t.src=e.target.result},a.readAsDataURL(t)}),UI.downloadBtn.addEventListener("click",downloadFullRes),UI.compareBtn.addEventListener("click",openCompare),UI.closeCompare.addEventListener("click",()=>document.getElementById("compareModal").classList.remove("show")),UI.exportSideBySide.addEventListener("click",()=>exportComparison("side")),UI.exportStacked.addEventListener("click",()=>exportComparison("stack"));const e=document.getElementById("previewContainer");e.addEventListener("mouseenter",()=>UI.overlayOriginal.classList.add("show")),e.addEventListener("mouseleave",()=>UI.overlayOriginal.classList.remove("show"))});let renderRequested=!1;function requestRender(){!renderRequested&&state.baseImage&&(renderRequested=!0,requestAnimationFrame(()=>{renderFrame(),renderRequested=!1}))}function initWebGL(){state.canvas=UI.displayCanvas;const e=state.canvas.getContext("webgl2",{antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!0});if(!e)return void alert("WebGL2 not supported. Please use a modern browser.");e.getExtension("EXT_color_buffer_float"),e.getExtension("OES_texture_float_linear"),state.gl=e,e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),state.programs={adjust:createProgram(e,"vs-quad","fs-adjust"),mask:createProgram(e,"vs-quad","fs-mask"),noise:createProgram(e,"vs-quad","fs-noise"),blur:createProgram(e,"vs-quad","fs-blur"),composite:createProgram(e,"vs-quad","fs-composite"),chroma:createProgram(e,"vs-quad","fs-chroma"),copy:createProgram(e,"vs-quad","fs-chroma")};const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,-1,1,0,1,1,-1,1,0,1,1,1,1]),e.STATIC_DRAW),Object.values(state.programs).forEach(t=>{e.useProgram(t);const a=e.getAttribLocation(t,"a_pos"),r=e.getAttribLocation(t,"a_uv");e.enableVertexAttribArray(a),e.enableVertexAttribArray(r),e.vertexAttribPointer(a,2,e.FLOAT,!1,16,0),e.vertexAttribPointer(r,2,e.FLOAT,!1,16,8)});const a=createTexture(e,null,320,180),r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0),state.thumbnailFBO={fbo:r,tex:a,w:320,h:180}}function loadNewImage(e){state.baseImage=e,state.width=e.width,state.height=e.height;const t=state.gl;state.textures.base&&t.deleteTexture(state.textures.base),state.textures.base=createTexture(t,e),state.fboWidth=0,reallocateBuffers(!1),UI.downloadBtn.disabled=!1,UI.compareBtn.disabled=!1,UI.overlayCanvas.width=e.width,UI.overlayCanvas.height=e.height,UI.overlayCanvas.getContext("2d").drawImage(e,0,0),setupLayerGridDOM(),requestRender()}function reallocateBuffers(e=!1){const t=state.gl;let a,r;if(e)a=state.width,r=state.height;else{const e=2048;let t=1;(state.width>e||state.height>e)&&(t=Math.min(e/state.width,e/state.height)),a=Math.round(state.width*t),r=Math.round(state.height*t)}if(state.fboWidth===a&&state.fboHeight===r)return{w:a,h:r};state.fboWidth=a,state.fboHeight=r,["adjust","mask","noise","blur1","blur2","comp"].forEach(e=>{state.textures[e]&&t.deleteTexture(state.textures[e]),state.fbos[e]&&t.deleteFramebuffer(state.fbos[e])});const o=()=>{const e=createTexture(t,null,a,r),o=t.createFramebuffer();return t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),{tex:e,fbo:o}},s=o();state.textures.adjust=s.tex,state.fbos.adjust=s.fbo;const n=o();state.textures.mask=n.tex,state.fbos.mask=n.fbo;const i=o();state.textures.noise=i.tex,state.fbos.noise=i.fbo;const u=o();state.textures.blur1=u.tex,state.fbos.blur1=u.fbo;const m=o();state.textures.blur2=m.tex,state.fbos.blur2=m.fbo;const d=o();return state.textures.comp=d.tex,state.fbos.comp=d.fbo,{w:a,h:r}}function renderFrame(e=!1){if(!state.baseImage)return;const t=state.gl,a=reallocateBuffers(e),r=a.w,o=a.h;t.viewport(0,0,r,o),t.useProgram(state.programs.adjust),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.adjust),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.textures.base),t.uniform1i(t.getUniformLocation(state.programs.adjust,"u_tex"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_bright"),parseFloat(UI.brightness.value)),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_cont"),parseFloat(UI.contrast.value)),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_sat"),parseFloat(UI.saturationAdj.value)/100),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_hdrTol"),parseFloat(UI.hdrTolerance.value)),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_hdrAmt"),parseFloat(UI.hdrAmount.value)),t.drawArrays(t.TRIANGLES,0,6),t.useProgram(state.programs.mask),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.mask),t.bindTexture(t.TEXTURE_2D,state.textures.adjust),t.uniform1i(t.getUniformLocation(state.programs.mask,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.mask,"u_useS"),UI.enableShadows.checked?1:0),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.shadowThreshold.value)),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.shadowFade.value)),t.uniform1i(t.getUniformLocation(state.programs.mask,"u_useH"),UI.enableHighlights.checked?1:0),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.highlightThreshold.value)),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.highlightFade.value)),t.drawArrays(t.TRIANGLES,0,6),t.useProgram(state.programs.noise),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.noise),t.uniform1i(t.getUniformLocation(state.programs.noise,"u_type"),parseInt(UI.noiseType.value)),t.uniform1f(t.getUniformLocation(state.programs.noise,"u_seed"),100*Math.random()),t.uniform2f(t.getUniformLocation(state.programs.noise,"u_res"),r,o),t.uniform2f(t.getUniformLocation(state.programs.noise,"u_origRes"),state.width,state.height),t.uniform1f(t.getUniformLocation(state.programs.noise,"u_scale"),parseFloat(UI.noiseSize.value)),t.drawArrays(t.TRIANGLES,0,6);const s=parseFloat(UI.blurriness.value)/100;s>0&&(t.useProgram(state.programs.blur),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.blur1),t.bindTexture(t.TEXTURE_2D,state.textures.noise),t.uniform1i(t.getUniformLocation(state.programs.blur,"u_tex"),0),t.uniform2f(t.getUniformLocation(state.programs.blur,"u_dir"),1/r,0),t.uniform1f(t.getUniformLocation(state.programs.blur,"u_rad"),2*s),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.blur2),t.bindTexture(t.TEXTURE_2D,state.textures.blur1),t.uniform2f(t.getUniformLocation(state.programs.blur,"u_dir"),0,1/o),t.drawArrays(t.TRIANGLES,0,6));const n=s>0?state.textures.blur2:state.textures.noise;t.useProgram(state.programs.composite),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.comp),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.textures.adjust),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,n),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,state.textures.mask);const i={base:t.getUniformLocation(state.programs.composite,"u_base"),noise:t.getUniformLocation(state.programs.composite,"u_noise"),mask:t.getUniformLocation(state.programs.composite,"u_mask"),mode:t.getUniformLocation(state.programs.composite,"u_mode"),op:t.getUniformLocation(state.programs.composite,"u_opacity"),str:t.getUniformLocation(state.programs.composite,"u_str"),nType:t.getUniformLocation(state.programs.composite,"u_nType"),satStr:t.getUniformLocation(state.programs.composite,"u_satStr"),satImp:t.getUniformLocation(state.programs.composite,"u_satImp"),ignA:t.getUniformLocation(state.programs.composite,"u_ignA"),ignAstr:t.getUniformLocation(state.programs.composite,"u_ignAstr")};t.uniform1i(i.base,0),t.uniform1i(i.noise,1),t.uniform1i(i.mask,2),t.uniform1i(i.mode,parseInt(UI.blendMode.value)),t.uniform1f(i.op,parseFloat(UI.opacity.value)),t.uniform1f(i.str,parseFloat(UI.strength.value)),t.uniform1i(i.nType,parseInt(UI.noiseType.value)),t.uniform1f(i.satStr,parseFloat(UI.satStrength.value)),t.uniform1f(i.satImp,parseFloat(UI.satPerNoise.value)),t.uniform1i(i.ignA,UI.ignoreAlphaToggle.checked?1:0),t.uniform1f(i.ignAstr,parseFloat(UI.ignoreAlphaStrength.value)),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,null),t.canvas.width===r&&t.canvas.height===o||(t.canvas.width=r,t.canvas.height=o),t.viewport(0,0,r,o),t.useProgram(state.programs.chroma),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.textures.comp),t.uniform1i(t.getUniformLocation(state.programs.chroma,"u_tex"),0);const u=parseFloat(UI.aberrationAmount.value),m=parseFloat(UI.aberrationAmount.max),d=u/m,c=d*d*m;t.uniform1f(t.getUniformLocation(state.programs.chroma,"u_amt"),c);const l=parseFloat(UI.aberrationBlur.value),g=l/100*(l/100)*100;t.uniform1f(t.getUniformLocation(state.programs.chroma,"u_blur"),g),t.uniform2f(t.getUniformLocation(state.programs.chroma,"u_center"),parseFloat(UI.centerX.value),parseFloat(UI.centerY.value)),t.drawArrays(t.TRIANGLES,0,6),e||updateLayerPreviews(n)}function createShader(e,t,a){const r=document.getElementById(a).text.trim(),o=e.createShader("vs-quad"==t?e.VERTEX_SHADER:e.FRAGMENT_SHADER);return e.shaderSource(o,r),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.error(e.getShaderInfoLog(o)),null)}function createProgram(e,t,a){const r=createShader(e,"vs-quad",t),o=createShader(e,"fs-fragment",a),s=e.createProgram();return e.attachShader(s,r),e.attachShader(s,o),e.linkProgram(s),s}function createTexture(e,t,a,r){const o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),t?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a,r,0,e.RGBA,e.UNSIGNED_BYTE,null),o}async function downloadFullRes(){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const e=document.createElement("a");e.download="grain-export.png",e.href=state.canvas.toDataURL("image/png",1),e.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function openCompare(){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const e=document.getElementById("compareOriginal"),t=document.getElementById("compareProcessed"),a=state.width/state.height;e.width=600,e.height=600/a,t.width=600,t.height=600/a;const r=e.getContext("2d"),o=t.getContext("2d");r.drawImage(state.baseImage,0,0,e.width,e.height),o.drawImage(state.canvas,0,0,t.width,t.height),document.getElementById("compareModal").classList.add("show"),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function exportComparison(e){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const t=state.canvas.toDataURL(),a=new Image;a.src=t,await new Promise(e=>a.onload=e);const r=document.createElement("canvas"),o=state.width,s=state.height;if("side"===e){r.width=2*o,r.height=s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0),e.drawImage(a,o,0)}else{r.width=o,r.height=2*s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0),e.drawImage(a,0,s)}const n=document.createElement("a");n.download=`grain-compare-${e}.png`,n.href=r.toDataURL("image/png",.9),n.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}function setupLayerGridDOM(){const e=UI.layerGrid;e.innerHTML="";["Adjusted","Noise","Masks","Composite"].forEach(t=>{const a=document.createElement("div");a.className="layer-item",a.innerHTML=`<div class="layer-title">${t}</div><canvas class="layer-canvas" id="thumb-${t}" width="320" height="180"></canvas>`,e.appendChild(a)})}function updateLayerPreviews(e){const t=state.gl;if(!state.thumbnailFBO)return;const a={Adjusted:state.textures.adjust,Noise:e,Masks:state.textures.mask,Composite:state.textures.comp};t.bindFramebuffer(t.FRAMEBUFFER,state.thumbnailFBO.fbo),t.viewport(0,0,state.thumbnailFBO.w,state.thumbnailFBO.h),t.useProgram(state.programs.copy),t.uniform1f(t.getUniformLocation(state.programs.copy,"u_amt"),0);const r=new Uint8Array(state.thumbnailFBO.w*state.thumbnailFBO.h*4);Object.keys(a).forEach(e=>{const o=a[e],s=document.getElementById(`thumb-${e}`);if(!s||!o)return;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,o),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6),t.readPixels(0,0,state.thumbnailFBO.w,state.thumbnailFBO.h,t.RGBA,t.UNSIGNED_BYTE,r);const n=s.getContext("2d"),i=n.createImageData(state.thumbnailFBO.w,state.thumbnailFBO.h),u=state.thumbnailFBO.w,m=state.thumbnailFBO.h;for(let e=0;e<m;e++){const t=(m-1-e)*u*4,a=e*u*4;i.data.set(r.subarray(t,t+4*u),a)}n.putImageData(i,0,0)})}</script></body></html>