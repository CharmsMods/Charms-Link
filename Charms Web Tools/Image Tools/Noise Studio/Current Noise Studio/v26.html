<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Digital Grain Studio ‚Äî GPU Accelerated</title><style>:root{--bg:#000;--fg:#fff;--panel-max:460px;--muted:#8c8c8c;--accent:#2a9df4;--border:rgba(255, 255, 255, 0.08);--layer-h:40px;--tab-bg:#1a1a1a;--tab-active:#2a9df4}*{box-sizing:border-box}body,html{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'Courier New',monospace}body{padding:16px;display:flex;gap:16px;align-items:flex-start;min-height:100vh}.container{display:flex;gap:16px;width:100%;height:100%}.controls-panel{flex:0 0 var(--panel-max);max-width:var(--panel-max);min-width:320px;padding-right:10px;overflow-y:auto;height:100%;scrollbar-width:thin;scrollbar-color:var(--muted) var(--bg);display:flex;flex-direction:column}.controls-panel h1{font-size:18px;margin:0 0 4px 0;text-align:center;letter-spacing:-.5px}.muted{color:var(--muted);font-size:12px;margin-bottom:12px;display:block;text-align:center}.tab-toggle-container{display:flex;gap:4px;margin:10px 0;background:#111;padding:4px;border:1px solid var(--border);border-radius:4px}.tab-btn{flex:1;padding:8px;font-size:11px;background:#1a1a1a;color:var(--muted);border:none;cursor:pointer;transition:all .2s}.tab-btn.active{background:var(--accent);color:#000}.tab-content{display:none;flex-direction:column;gap:10px}.tab-content.active{display:flex}.drag-layer{background:#111;border:1px solid var(--border);padding:8px 12px;margin-bottom:6px;cursor:grab;display:flex;justify-content:space-between;align-items:center;user-select:none;font-size:13px;border-radius:4px}.drag-layer:active{cursor:grabbing;background:#222;border-color:var(--accent)}.drag-layer.dragging{opacity:.5}.drag-handle{color:var(--muted);margin-right:10px}.drag-controls{display:flex;align-items:center;gap:10px}.drag-toggle{cursor:pointer;accent-color:var(--accent)}details{border:1px solid var(--border);margin-bottom:8px;padding:6px;border-radius:4px;background:#0a0a0a}summary{cursor:pointer;font-weight:700;margin:0 0 6px 0;outline:0;user-select:none;font-size:13px}summary:hover{color:var(--accent)}.control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;min-height:28px}.control-row label{flex:0 0 120px;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px}input[type=range]{flex:1;-webkit-appearance:none;appearance:none;background:0 0;cursor:pointer;height:14px}input[type=range]::-webkit-slider-runnable-track{width:100%;height:2px;background:rgba(255,255,255,.15);border-radius:2px;border:none}input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;height:8px;width:8px;border-radius:50%;background:#fff;margin-top:-3px;border:none;box-shadow:0 1px 3px rgba(0,0,0,.5);transition:transform .1s}input[type=range]:active::-webkit-slider-thumb{transform:scale(1.2)}input[type=range]::-moz-range-track{width:100%;height:2px;background:rgba(255,255,255,.15);border-radius:2px;border:none}input[type=range]::-moz-range-thumb{height:8px;width:8px;border-radius:50%;background:#fff;border:none;box-shadow:0 1px 3px rgba(0,0,0,.5);transition:transform .1s}input[type=range]:active::-moz-range-thumb{transform:scale(1.2)}.control-value{width:60px;padding:2px 4px;text-align:right;background:#000;color:var(--fg);border:1px solid var(--border);font-family:monospace;font-size:11px}select.control-value{flex:1;min-width:120px;padding:4px}.row-buttons{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}.palette-list{display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;padding:4px;border:1px solid var(--border);min-height:32px;background:#050505}.palette-color-item{display:flex;align-items:center;background:#1a1a1a;border:1px solid var(--border);padding:2px;gap:4px}.palette-color-item input[type=color]{width:24px;height:24px;padding:0;border:none;background:0 0;cursor:pointer}.remove-color-btn{background:0 0;border:none;color:#f55;cursor:pointer;font-size:14px;padding:0 4px;line-height:1}.remove-color-btn:hover{color:red;background:rgba(255,0,0,.1)}button{background:#111;color:var(--fg);border:1px solid var(--border);padding:8px 12px;cursor:pointer;font-family:monospace;font-size:12px;transition:all .2s}button:hover:not(:disabled){background:var(--accent);color:#000;border-color:var(--accent)}button:disabled{opacity:.5;cursor:not-allowed}button.small-btn{padding:4px 8px;font-size:10px}.preview-column{flex:1 1 auto;min-width:320px;display:flex;flex-direction:column;gap:12px;height:100%;overflow:hidden}.preview-top{display:flex;align-items:center;justify-content:space-between;gap:12px}.preview-container{position:relative;border:1px solid var(--border);background:repeating-linear-gradient(45deg,#111 0,#111 10px,#0e0e0e 10px,#0e0e0e 20px);overflow:hidden;flex:1;display:flex;align-items:center;justify-content:center;min-height:300px}canvas{display:block;width:100%;height:100%;object-fit:contain;box-shadow:0 0 20px rgba(0,0,0,.5)}.overlay-original{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:10;transition:opacity .5s ease}.overlay-original canvas{width:100%;height:100%;object-fit:contain;opacity:0;transition:opacity .5s ease}.overlay-original.show canvas{opacity:1}#caPin{width:12px;height:12px;background:var(--accent);border:2px solid #fff;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);cursor:crosshair;z-index:20;box-shadow:0 0 5px #000;display:none}#caPin.active{display:block}#caPin::after{content:'';position:absolute;top:50%;left:50%;width:40px;height:40px;border:1px dashed rgba(255,255,255,.3);transform:translate(-50%,-50%);border-radius:50%;pointer-events:none}.layer-preview-window{border:1px solid var(--border);background:#050505;padding:8px;height:160px;flex:0 0 160px;overflow:hidden}.layer-grid{display:flex;gap:4px;height:100%}.layer-item{border:1px solid var(--border);flex:1;display:flex;flex-direction:column;background:#000;cursor:pointer;transition:border-color .2s;position:relative;min-width:60px}.layer-item:hover{border-color:var(--muted)}.layer-item.active{border-color:var(--accent)}.layer-title{color:var(--muted);font-size:9px;text-transform:uppercase;text-align:center;padding-top:4px;height:24px;line-height:1.2;word-wrap:break-word;padding:2px}.layer-canvas{width:100%;flex:1;background:#111;border-top:1px solid #222}.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.9);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s;z-index:3000}.modal-overlay.show{opacity:1;pointer-events:auto}.modal{background:#111;border:1px solid var(--border);padding:20px;max-width:90vw;max-height:90vh;overflow:auto;box-shadow:0 0 50px rgba(0,0,0,.8)}#loading{position:fixed;top:10px;right:10px;background:var(--accent);color:#000;padding:4px 8px;font-size:11px;font-weight:700;display:none;z-index:4000}.upscale-control{display:flex;align-items:center;gap:8px;font-size:11px;border:1px solid var(--border);padding:4px 8px;background:#0a0a0a;border-radius:4px}.upscale-input{width:40px;background:#000;border:1px solid var(--border);color:var(--fg);padding:2px;text-align:center;font-family:monospace}.lock-switch{display:flex;align-items:center;gap:6px;font-size:11px;cursor:pointer;user-select:none;margin-right:12px;border-right:1px solid var(--border);padding-right:12px}.lock-checkbox{accent-color:var(--accent);cursor:pointer}.json-btn{background:#222;border:1px solid var(--border);color:var(--accent);font-size:10px;padding:4px 8px;cursor:pointer;margin-top:4px;width:100%;text-align:center}.json-btn:hover{background:var(--accent);color:#000}.info-section{background:#111;border:1px solid var(--border);padding:10px;border-radius:4px}.info-section h3{font-size:11px;color:var(--muted);margin:0 0 10px 0;text-transform:uppercase;letter-spacing:1px}.histogram-container{background:#000;border:1px solid #222;height:100px;margin-bottom:8px;position:relative}#histogramCanvas{width:100%;height:100%;display:block}.info-row{display:flex;justify-content:space-between;font-size:11px;color:var(--muted);margin-bottom:4px}.info-row span:last-child{color:var(--accent);font-family:monospace}.vectorscope-container{background:#000;border:1px solid #222;display:flex;justify-content:center;padding:8px;margin-bottom:8px}#vectorscopeCanvas{border-radius:50%;background:radial-gradient(circle,#111 0,#000 100%)}@media (max-width:900px){body{padding:10px;flex-direction:column}.container{flex-direction:column}.controls-panel{width:100%;max-width:none;flex:none;height:auto;max-height:40vh}.preview-column{width:100%;height:50vh}}</style></head><body><div id="export-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:3999;flex-direction:column;align-items:center;justify-content:center;color:#fff;font-size:1.2em"><div id="export-status">PROCESSING 1/100...</div><button id="stopExportBtn" style="margin-top:20px;padding:10px 20px;background:#f55;color:#fff;border:1px solid #f77;font-size:.8em">CANCEL EXPORT</button></div><div id="loading">PROCESSING GPU...</div><div class="container"><div class="controls-panel"><h1>DIGITAL GRAIN [GPU]</h1><span class="muted">WebGL2 Accelerated Pipeline</span><div style="margin:10px 0;border:1px dashed var(--border);padding:10px;text-align:center"><div style="display:grid;grid-template-columns:1fr 1fr;gap:8px"><label for="imageUpload" style="cursor:pointer;display:block;background:#1a1a1a;padding:8px;border-radius:4px;border:1px solid var(--border)"><span style="font-size:24px;display:block;margin-bottom:5px">üìÇ</span> <span style="font-size:12px;color:var(--accent)">LOAD IMAGE</span></label> <label id="loadFolderBtn" style="cursor:pointer;display:block;background:#1a1a1a;padding:8px;border-radius:4px;border:1px solid var(--border)"><span style="font-size:24px;display:block;margin-bottom:5px">üóÇÔ∏è</span> <span style="font-size:12px;color:var(--accent)">LOAD FOLDER</span></label></div><input id="imageUpload" type="file" accept="image/*" style="display:none"><div id="image-navigation" style="display:none;margin-top:10px;flex-direction:column;align-items:center;justify-content:center;gap:10px"><div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center"><button id="prevImageBtn" class="small-btn">‚óÑ Prev</button> <span id="imageCounter" style="font-size:12px;color:var(--muted);min-width:80px;text-align:center">Image 1 of 1</span> <button id="nextImageBtn" class="small-btn">Next ‚ñ∫</button></div><input type="range" id="imageScrubber" style="width:80%;accent-color:var(--accent)" min="0" max="0" value="0"><div style="display:flex;align-items:center;gap:10px;margin-top:8px"><button id="playBtn" class="small-btn">PLAY ‚ñ∫</button> <input type="number" id="playFps" class="upscale-input" value="10" style="width:50px"> <span style="font-size:11px;color:var(--muted)">FPS</span> <span id="actualFps" style="font-size:11px;color:var(--accent);min-width:90px">(Actual: --)</span></div><div style="display:flex;align-items:center;gap:10px;margin-top:8px;border-top:1px solid var(--border);padding-top:8px;width:100%;justify-content:center"><label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer"><input type="checkbox" id="keepFolderStructureToggle" style="accent-color:var(--accent)"> <span>KEEP FOLDER STRUCTURE ON EXPORT</span></label></div></div><div style="background:rgba(255,255,255,.05);padding:8px;margin-top:10px;border-radius:4px;border:1px solid var(--border)"><div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px"><label style="font-size:11px;display:flex;align-items:center;gap:5px;cursor:pointer;color:var(--muted)" title="Save the original image inside the JSON file"><input type="checkbox" id="jsonIncludeImage" checked="checked" style="accent-color:var(--accent)"> <span>Include Image</span></label> <button class="json-btn" id="downloadJsonBtn" style="padding:4px 12px;font-size:11px;width:auto">SAVE .JSON</button></div><div style="display:flex;align-items:center;gap:5px"><select id="jsonImportMode" style="background:var(--bg);color:var(--text);border:1px solid var(--border);font-size:10px;padding:4px;border-radius:3px;outline:0;width:90px"><option value="both" selected="selected">Import All</option><option value="settings">Settings Only</option><option value="image">Image Only</option></select> <button class="json-btn" id="uploadJsonTrigger" style="padding:4px 12px;font-size:11px;flex-grow:1">LOAD .JSON</button></div><input id="jsonUpload" type="file" accept=".json" style="display:none"></div></div><details class="info-details" open><summary>Realtime Analysis</summary><div class="info-section" style="margin-top:6px"><h3>LUMINANCE HISTOGRAM</h3><div class="histogram-container"><canvas id="histogramCanvas" width="512" height="300" style="width:100%;height:150px"></canvas></div><div class="info-row"><span>Avg Brightness:</span> <span id="avgBrightnessVal">--</span></div><div class="info-row"><span>Render Res:</span> <span id="renderResVal">--</span></div></div><div class="info-section" style="margin-top:8px"><h3>VECTORSCOPE</h3><div class="vectorscope-container"><canvas id="vectorscopeCanvas" width="400" height="400" style="width:200px;height:200px"></canvas></div><div class="info-row"><span>Avg Saturation:</span> <span id="avgSaturationVal">--</span></div></div></details><div class="tab-toggle-container"><button class="tab-btn active" data-tab="tab-controls">Controls</button> <button class="tab-btn" data-tab="tab-layers">Render Layer Order</button></div><div id="tab-controls" class="tab-content active"><details open><summary>System & Performance</summary><div class="control-row" title="If enabled, removes the 2048px preview limit. Requires a powerful GPU for large images."><label>High Quality Preview</label> <input id="clampPreviewToggle" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Full Res</label></div><div class="control-row" style="font-size:9px;color:var(--muted);border-top:1px solid var(--border);padding-top:8px;margin-top:8px"><span>MAX GPU TEXTURE:</span> <span id="gpuMaxRes" style="margin-left:auto;font-family:monospace;color:var(--accent)">QUERYING...</span></div></details><details open><summary>Noise <input id="noiseEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Noise Strength</label> <input id="strength" type="range" min="0" max="150" step="0.1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Noise Type</label> <select id="noiseType" class="control-value"><option value="1" selected="selected">Grayscale</option><option value="0">Color</option><option value="3">Blue Noise</option><option value="4">Blue Noise (Color)</option><option value="2">Blend (Sat)</option><option value="5">Perlin (Cloudy)</option><option value="6">Worley (Cellular)</option><option value="7">Scanlines</option><option value="8">Speckle (Dust)</option><option value="9">Glitch</option><option value="10">Anisotropic (Fiber)</option><option value="11">Voronoi Mosaic</option><option value="12">Crosshatch</option></select></div><div class="control-row"><label>Sat Strength</label> <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sat Impact</label> <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div id="noiseParamsHeader" style="display:none;border-top:1px dashed var(--border);margin:8px 0;padding-top:8px;font-size:10px;color:var(--accent);opacity:.8;text-transform:uppercase;letter-spacing:1px">Advanced Settings</div><div id="noiseParamRowA" class="control-row" style="display:none"><label id="noiseLabelA">Param A</label> <input id="noiseParamA" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div id="noiseParamRowB" class="control-row" style="display:none"><label id="noiseLabelB">Param B</label> <input id="noiseParamB" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div id="noiseParamRowC" class="control-row" style="display:none"><label id="noiseLabelC">Param C</label> <input id="noiseParamC" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Scale (Size)</label> <input id="noiseSize" type="range" min="0" max="10" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Blurriness</label> <input id="blurriness" type="range" min="0" max="100" step="1" value="2"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Blend Mode</label> <select id="blendMode" class="control-value"><option value="0">Normal</option><option value="1" selected="selected">Overlay</option><option value="2">Screen</option><option value="3">Multiply</option><option value="4">Add</option><option value="5">Difference</option></select></div><div class="control-row"><label>Opacity</label> <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Luma Masking</label> <input id="noiseLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Color Exclusion</label> <input id="noiseColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="noiseExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="noiseExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="noiseColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="noiseColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="border-top:1px dashed var(--border);margin:8px 0;padding-top:8px"></div><div class="control-row"><label>Invert Mask</label> <input id="noiseInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div><div class="control-row"><label>Skin Protection</label> <input id="skinProtection" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Alpha Channel</summary><div class="control-row"><label>Ignore Alpha</label> <input id="ignoreAlphaToggle" type="checkbox" checked="checked"></div><div class="control-row"><label>Strength</label> <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Glare Rays</summary><div class="control-row"><label>Enable Rays</label> <input id="glareRaysEnable" type="checkbox"></div><div class="control-row"><label>Intensity</label> <input id="glareRaysIntensity" type="range" min="0" max="1" step="0.01" value="0.4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Ray Count</label> <input id="glareRaysRays" type="range" min="1" max="16" step="1" value="6"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Ray Length</label> <input id="glareRaysLength" type="range" min="0" max="1" step="0.01" value="0.3"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Ray Blur</label> <input id="glareRaysBlur" type="range" min="0" max="1" step="0.01" value="0.2"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Radial Hankel Blur</summary><div class="control-row"><label>Enable Blur</label> <input id="hankelBlurEnable" type="checkbox"></div><div class="control-row"><label>Intensity</label> <input id="hankelBlurIntensity" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Radius</label> <input id="hankelBlurRadius" type="range" min="1" max="50" step="0.5" value="5.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Quality</label> <input id="hankelBlurQuality" type="range" min="4" max="32" step="1" value="16"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="hankelColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="hankelExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="hankelExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="hankelColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="hankelColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="hankelLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="hankelShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="hankelShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="hankelHighlightThreshold" type="range" min="0" max="1" step="0.01" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="hankelHighlightFade" type="range" min="0" max="1" step="0.01" value="0.1"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Invert Mask</label> <input id="hankelInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div></details><details><summary>Adjustments <input id="adjustEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Brightness</label> <input id="brightness" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast</label> <input id="contrast" type="range" min="-100" max="200" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Saturation</label> <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Warmth</label> <input id="warmth" type="range" min="-500" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpening</label> <input id="sharpen" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpen Threshold</label> <input id="sharpenThreshold" type="range" min="0" max="100" step="1" value="5"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="adjColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="adjExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="adjExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="adjColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="adjColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="adjLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="adjShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="adjShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="adjHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="adjHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:5px"></div><div class="control-row"><label>Invert Mask</label> <input id="adjInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div></details><details><summary>HDR Emulation <input id="hdrEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Tolerance</label> <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Amount</label> <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Chromatic Aberration <input id="caEnable" type="checkbox" checked="checked" style="margin-left:auto"></summary><div class="control-row"><label>Amount</label> <input id="aberrationAmount" type="range" min="0" max="1500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Clear Radius</label> <input id="caRadius" type="range" min="0" max="1000" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Radius Falloff</label> <input id="caFalloff" type="range" min="0" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Blur</label> <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Zoom Blur</label> <input id="aberrationZoomBlur" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Link Falloff to Blur</label> <input id="caFalloffToBlur" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enabled</label></div><div style="text-align:right;margin-top:5px"><button id="resetCenterBtn" class="small-btn">RESET CENTER</button></div></details><details><summary>Blur</summary><div class="control-row"><label>Enable</label> <input id="blurEnable" type="checkbox" checked="checked"></div><div class="control-row"><label>Amount</label> <input id="blurAmount" type="range" min="0" max="1000" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Type</label> <select id="blurType" class="control-value"><option value="0" selected="selected">Gaussian</option><option value="1">Box</option><option value="2">Motion</option></select></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="blurColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="blurTargetColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="blurTargetColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="blurColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="blurColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="blurLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="blurShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="blurShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="blurHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="blurHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:5px"></div><div class="control-row"><label>Invert Mask</label> <input id="blurInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div></details><details><summary>Dithering</summary><div class="control-row"><label>Enable</label> <input id="ditherEnable" type="checkbox"></div><div class="control-row"><label>Bit Depth</label> <input id="ditherBitDepth" type="range" min="1" max="8" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Palette Size</label> <input id="ditherPaletteSize" type="range" min="2" max="256" step="1" value="16"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Dither Strength</label> <input id="ditherStrength" type="range" min="0" max="1000" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Scale</label> <input id="ditherScale" type="range" min="1" max="16" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Dither Type</label> <select id="ditherType" class="control-value"><option value="0" selected="selected">Bayer 8x8</option><option value="1">Bayer 4x4</option><option value="2">Bayer 2x2</option><option value="3">White Noise</option><option value="4">Interleaved Gradient</option></select></div><div class="control-row"><label>Use Studio Palette</label> <input id="ditherUsePalette" type="checkbox"></div><div class="control-row"><label>Gamma Correct</label> <input id="ditherGamma" type="checkbox"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="ditherColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div style="display:flex;align-items:center;gap:5px"><input id="ditherExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="ditherExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div><div class="control-row"><label>Color Tolerance</label> <input id="ditherColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="ditherColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="ditherLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="ditherShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="ditherShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="ditherHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="ditherHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:5px"></div><div class="control-row"><label>Invert Mask</label> <input id="ditherInvertMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Invert</label></div><div class="control-row"><label>Soft Mask Depth</label> <input id="ditherSoftMask" type="checkbox" checked="checked"> <label style="color:var(--muted);margin-left:auto">Enabled</label></div></details><details><summary>Corruption</summary><div class="control-row"><label>Enable</label> <input id="corruptionEnable" type="checkbox"></div><div class="control-row"><label>Iterations</label> <input id="corruptionIterations" type="range" min="0" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Algorithm</label> <select id="corruptionAlgorithm" class="control-value"><option value="0" selected="selected">JPEG Blocks</option><option value="1">Pixelation</option><option value="2">Color Bleed</option></select></div><div class="control-row"><label>Resolution Scale</label> <input id="corruptionResScale" type="range" min="1" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div></details><details id="analogVideoDetails"><summary>Analog Video (VHS/CRT)</summary><div class="control-row"><label>Enable</label> <input id="analogVideoEnable" type="checkbox"></div><div class="control-row"><label>Tape Wobble</label> <input id="analogWobble" type="range" min="0" max="100" step="1" value="30"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Bleed</label> <input id="analogBleed" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>CRT Curve</label> <input id="analogCurve" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Scanline Noise</label> <input id="analogNoise" type="range" min="0" max="100" step="1" value="40"> <input type="text" class="control-value" readonly="readonly"></div></details><details id="lensDistortDetails"><summary>Lens Distortion (Optics)</summary><div class="control-row"><label>Enable</label> <input id="lensDistortEnable" type="checkbox"></div><div class="control-row"><label>Distortion Amount</label> <input id="lensAmount" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row" style="font-size:.8em;color:var(--muted);text-align:center;margin-top:-5px">&lt; Barrel (Fisheye) &nbsp;&nbsp;|&nbsp;&nbsp; Pincushion &gt;</div><div class="control-row"><label>Scale Base</label> <input id="lensScale" type="range" min="50" max="150" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div></details><details id="heatwaveDetails"><summary>Heatwave & Ripples</summary><div class="control-row"><label>Enable</label> <input id="heatwaveEnable" type="checkbox"></div><div class="control-row"><label>Intensity</label> <input id="heatwaveIntensity" type="range" min="0" max="100" step="1" value="30"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Speed</label> <input id="heatwaveSpeed" type="range" min="0" max="200" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Scale</label> <input id="heatwaveScale" type="range" min="1" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Direction</label> <select id="heatwaveDirection" class="control-value"><option value="0" selected="selected">Vertical (Heat)</option><option value="1">Horizontal</option><option value="2">Radial (Ripple)</option></select></div></details><details id="lightLeaksDetails"><summary>Light Leaks</summary><div class="control-row"><label>Enable</label> <input id="lightLeaksEnable" type="checkbox"></div><div class="control-row"><label>Intensity</label> <input id="lightLeaksIntensity" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color 1</label> <input id="lightLeaksColor1" type="color" value="#ff5500" class="control-value"></div><div class="control-row"><label>Color 2</label> <input id="lightLeaksColor2" type="color" value="#0055ff" class="control-value"></div></details><details><summary>Compression</summary><div class="control-row"><label>Enable</label> <input id="compressionEnable" type="checkbox"></div><div class="control-row"><label>Method</label> <select id="compressionMethod" class="control-value"><option value="0" selected="selected">DCT Block</option><option value="1">Chroma Subsampling</option><option value="2">Wavelet</option></select></div><div class="control-row"><label>Quality</label> <input id="compressionQuality" type="range" min="1" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Block Size</label> <input id="compressionBlockSize" type="range" min="2" max="32" step="1" value="8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Blend</label> <input id="compressionBlend" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Iterations</label> <input id="compressionIterations" type="range" min="1" max="20" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Cell Shading</summary><div class="control-row"><label>Enable</label> <input id="cellEnable" type="checkbox"></div><div class="control-row"><label>Shading Levels</label> <input id="cellLevels" type="range" min="2" max="12" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast Bias</label> <input id="cellBias" type="range" min="-1" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Gamma Curve</label> <input id="cellGamma" type="range" min="0.5" max="2.2" step="0.01" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Quantize Mode</label> <select id="cellQuantMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option><option value="2">HSV Value</option></select></div><div class="control-row"><label>Band Mapping</label> <select id="cellBandMap" class="control-value"><option value="0" selected="selected">Linear</option><option value="1">Smoothstep</option><option value="2">Posterize</option></select></div><div style="height:5px"></div><div class="control-row"><label>Edges Enable</label> <input id="cellEdgeEnable" type="checkbox"></div><div class="control-row"><label>Edge Strength</label> <input id="cellEdgeStr" type="range" min="0" max="5" step="0.01" value="0.8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Thickness</label> <input id="cellEdgeThick" type="range" min="0.5" max="10" step="0.1" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Method</label> <select id="cellEdgeMethod" class="control-value"><option value="0">None</option><option value="1" selected="selected">Sobel</option><option value="2">Laplacian</option></select></div><div class="control-row"><label>Color Preserve</label> <input id="cellColorPreserve" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Quant Luma Only</label></div></details><details><summary>Halftoning</summary><div class="control-row"><label>Enable</label> <input id="halftoneEnable" type="checkbox"></div><div class="control-row"><label>Dot Size</label> <input id="halftoneSize" type="range" min="1" max="12" step="0.1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Intensity</label> <input id="halftoneIntensity" type="range" min="0" max="1" step="0.01" value="0.8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpness</label> <input id="halftoneSharpness" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Pattern Type</label> <select id="halftonePattern" class="control-value"><option value="0" selected="selected">Circular</option><option value="1">Line</option><option value="2">Cross</option><option value="3">Diamond</option></select></div><div class="control-row"><label>Color Mode</label> <select id="halftoneColorMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option><option value="2">CMY</option><option value="3">CMYK</option></select></div><div class="control-row"><label>Sampling</label> <select id="halftoneSample" class="control-value"><option value="0" selected="selected">Center</option><option value="1">Average</option><option value="2">Rotated Grid</option></select></div><div class="control-row"><label>Grayscale</label> <input id="halftoneGray" type="checkbox"></div><div class="control-row"><label>Screen Lock</label> <input id="halftoneScreenLock" type="checkbox" checked="checked"></div><div class="control-row"><label>Invert</label> <input id="halftoneInvert" type="checkbox"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="halftoneColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label><div><div style="display:flex;align-items:center;gap:5px"><input id="halftoneExcludeColor" type="color" value="#000000" style="width:40px;height:24px"> <button class="eyedropper-btn" data-target="halftoneExcludeColor" title="Pick from canvas">üñåÔ∏è</button></div></div></div><div class="control-row"><label>Color Tolerance</label> <input id="halftoneColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="halftoneColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="halftoneLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="halftoneShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="halftoneShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="halftoneHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="halftoneHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Bilateral Filter</summary><div class="control-row"><label>Enable</label> <input id="bilateralEnable" type="checkbox"></div><div class="control-row"><label>Radius</label> <input id="bilateralRadius" type="range" min="1" max="30" step="1" value="5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Sigma</label> <input id="bilateralColorSig" type="range" min="0.01" max="1.0" step="0.01" value="0.1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Spatial Sigma</label> <input id="bilateralSpatialSig" type="range" min="0.5" max="15.0" step="0.1" value="2.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Iterations</label> <input id="bilateralIter" type="range" min="1" max="20" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>High Precision</label> <input id="bilateralHighPrec" type="checkbox" checked="checked"></div><div class="control-row"><label>Kernel Type</label> <select id="bilateralKernel" class="control-value"><option value="0" selected="selected">Gaussian</option><option value="1">Box</option></select></div><div class="control-row"><label>Edge Preservation</label> <select id="bilateralEdgeMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option></select></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="bilateralColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label> <input id="bilateralExcludeColor" type="color" value="#000000" style="width:60px;height:24px"></div><div class="control-row"><label>Color Tolerance</label> <input id="bilateralColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="bilateralColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="bilateralLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="bilateralShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="bilateralShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="bilateralHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="bilateralHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Denoising</summary><div class="control-row"><label>Enable</label> <input id="denoiseEnable" type="checkbox"></div><div class="control-row"><label>Mode</label> <select id="denoiseMode" class="control-value"><option value="0" selected="selected">Non-Local Means</option><option value="1">Median</option><option value="2">Mean (Box)</option></select></div><div class="control-row"><label>Search Radius</label> <input id="denoiseSearchRadius" type="range" min="1" max="15" step="1" value="5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Patch Radius</label> <input id="denoisePatchRadius" type="range" min="1" max="5" step="1" value="2"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Filter Strength</label> <input id="denoiseH" type="range" min="0.01" max="2.0" step="0.01" value="0.50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Blend</label> <input id="denoiseBlend" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="denoiseColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label> <input id="denoiseExcludeColor" type="color" value="#000000" style="width:60px;height:24px"></div><div class="control-row"><label>Color Tolerance</label> <input id="denoiseColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="denoiseColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="denoiseLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="denoiseShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="denoiseShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="denoiseHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="denoiseHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Invert Mask</label> <input id="denoiseInvertMask" type="checkbox"></div></details><details><summary>Palette Reconstructor</summary><div class="control-row"><label>Enable</label> <input id="paletteEnable" type="checkbox"></div><div class="control-row"><label>Global Blend</label> <input id="paletteBlend" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div><div class="row-buttons" style="margin-top:5px"><button id="addPaletteColor" class="small-btn">+ ADD COLOR</button> <button id="pickPaletteColorBtn" class="small-btn eyedropper-btn" data-target="pickPaletteColor" title="Pick from canvas">üñåÔ∏è PICK FROM CANVAS</button> <button id="randomPalette" class="small-btn">RANDOMIZE</button> <button id="clearPalette" class="small-btn">CLEAR</button> <button id="extractPalette" class="small-btn">Upload Palette Image</button> <input type="file" id="paletteImageUpload" style="display:none" accept="image/*"></div><div class="control-row"><label>Smoothing Type</label> <select id="paletteSmoothingType"><option value="0">Box</option><option value="1">Gaussian</option></select></div><div class="control-row"><label>Palette Smoothing</label> <input id="paletteSmoothing" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row" style="margin-top:5px"><label>Extract Count</label> <input id="extractCount" type="range" min="2" max="200" value="8" step="1"> <input type="text" class="control-value" readonly="readonly"></div><div id="paletteList" class="palette-list"></div></details><details id="vignetteDetails"><summary>Vignette & Focus</summary><div class="control-row"><label>Enable</label> <input id="vignetteEnable" type="checkbox"></div><div class="control-row"><label>Intensity</label> <input id="vignetteIntensity" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Radius</label> <input id="vignetteRadius" type="range" min="0" max="200" step="1" value="75"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Softness</label> <input id="vignetteSoftness" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color</label> <input id="vignetteColor" type="color" value="#000000" style="width:60px;height:24px"></div></details><details id="edgeDetails"><summary>Edge Effects</summary><div class="control-row"><label>Enable</label> <input id="edgeEnable" type="checkbox"></div><div class="control-row"><label>Global Blend</label> <input id="edgeBlend" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Mode</label> <select id="edgeMode"><option value="0">Edge Overlay</option><option value="1">Saturation Mask</option></select></div><div class="control-row"><label>Edge Strength</label> <input id="edgeStrength" type="range" min="0" max="1000" step="1" value="500"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Tolerance</label> <input id="edgeTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div id="edgeSatControls" style="display:none;border-top:1px dashed #333;padding-top:10px;margin-top:10px"><div class="control-row"><label>Foreground Sat</label> <input id="edgeFgSat" type="range" min="0" max="200" step="1" value="150"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Background Sat</label> <input id="edgeBgSat" type="range" min="0" max="200" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Bloom Spread</label> <input id="edgeBloom" type="range" min="0" max="50" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Bloom Smoothness</label> <input id="edgeSmooth" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div></div></details><details><summary>Airy Disk Bloom</summary><div class="control-row"><label>Enable</label> <input id="airyBloomEnable" type="checkbox"></div><div class="control-row"><label>Intensity</label> <input id="airyBloomIntensity" type="range" min="0" max="5.0" step="0.1" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Aperture Size</label> <input id="airyBloomAperture" type="range" min="0.1" max="10.0" step="0.1" value="3.0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Threshold (Min)</label> <input id="airyBloomThreshold" type="range" min="0" max="1" step="0.01" value="0.7"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Threshold Fade</label> <input id="airyBloomThresholdFade" type="range" min="0" max="1" step="0.01" value="0.1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Cutoff (Max)</label> <input id="airyBloomCutoff" type="range" min="0" max="1" step="0.01" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Color Exclusion</label> <input id="airyBloomColorExclude" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>Exclude Color</label> <input id="airyBloomExcludeColor" type="color" value="#000000" style="width:60px;height:24px"></div><div class="control-row"><label>Color Tolerance</label> <input id="airyBloomColorTolerance" type="range" min="0" max="100" step="1" value="10"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Fade</label> <input id="airyBloomColorFade" type="range" min="0" max="100" step="1" value="20"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Luma Mask</label> <input id="airyBloomLumaMask" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="airyBloomShadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="airyBloomShadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Threshold</label> <input id="airyBloomHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="airyBloomHighlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Invert Mask</label> <input id="airyBloomInvertMask" type="checkbox"></div></details><div class="row-buttons"><button id="downloadBtn" disabled="disabled">DOWNLOAD FULL RES</button> <button id="downloadCurrentBtn" disabled="disabled">DOWNLOAD CURRENT</button> <button id="compareBtn" disabled="disabled">COMPARE / EXPORT</button></div></div><div id="tab-layers" class="tab-content"><div style="font-size:11px;color:var(--muted);margin-bottom:10px">Drag to reorder render pipeline:</div><div id="layer-drag-list"></div></div></div><div class="preview-column"><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Main Preview</h3><div style="display:flex;align-items:center"><div class="upscale-control" style="margin-right:8px" title="Zoom level when hovering over preview. Press TAB to lock."><span style="color:var(--muted);font-size:9px;margin-right:8px;border-right:1px solid var(--border);padding-right:8px">TAB TO LOCK</span> <span>HOVER ZOOM</span> <input id="hoverZoomSlider" type="range" min="1" max="8" step="0.1" value="1" style="width:60px;accent-color:var(--accent)"> <span id="hoverZoomValue" style="min-width:28px;text-align:center">1x</span></div><button id="fullscreenPreviewBtn" class="small-btn" style="margin-right:8px;padding:4px 8px;font-size:9px" title="Open detached fullscreen preview">POP-OUT</button> <button id="lensToggleBtn" class="small-btn" style="margin-right:12px;padding:4px 8px;font-size:9px" title="Toggle between Full zoom and Lens zoom">FULL</button> <label class="lock-switch" title="Lock Preview to prevent Original Image overlay"><input type="checkbox" id="previewLock" class="lock-checkbox"> <span>LOCK PREVIEW</span></label><div class="upscale-control"><span>UPSCALE (x)</span> <input id="upscaleInput" class="upscale-input" type="text" value="1" min="1" max="10"></div></div></div><div class="preview-container" id="previewContainer"><canvas id="displayCanvas"></canvas><div id="caPin"></div><div class="overlay-original" id="overlayOriginal"><canvas id="overlayCanvas"></canvas></div><div id="zoomResIndicator" style="position:absolute;bottom:8px;left:8px;background:rgba(0,0,0,.8);color:#0f0;padding:4px 8px;font-size:10px;font-family:monospace;z-index:20;display:none;border:1px solid #0f0"></div><div id="zoomLens" style="position:absolute;width:180px;height:180px;border-radius:50%;border:2px solid var(--accent);overflow:hidden;pointer-events:none;display:none;z-index:25;box-shadow:0 0 20px rgba(0,0,0,.8)"><canvas id="lensCanvas" style="position:absolute;top:0;left:0"></canvas></div></div><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Layer Breakdown</h3><div style="font-size:10px;color:var(--muted)">Click to view</div></div><div class="layer-preview-window"><div class="layer-grid" id="layerGrid"></div></div></div></div><div id="compareModal" class="modal-overlay"><div class="modal"><h2 style="margin-top:0">Comparison & Export</h2><div style="display:flex;gap:20px;margin-bottom:20px;justify-content:center;flex-wrap:wrap"><div><div class="muted">Original</div><canvas id="compareOriginal" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div><div><div class="muted">Processed</div><canvas id="compareProcessed" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div></div><div style="text-align:center;margin-bottom:15px;background:rgba(0,0,0,.3);padding:10px;border:1px solid #333"><div style="font-size:10px;color:var(--muted);text-transform:uppercase;margin-bottom:5px">Rendering Technical Data</div><div id="exportInfo" style="font-family:monospace;color:#0f0;font-size:11px">Requested: -- x -- | Actual: -- x -- (Scale: 1.0)</div></div><div style="text-align:center;display:flex;gap:10px;justify-content:center;flex-wrap:wrap"><button id="exportSideBySide">Export Side-by-Side</button> <button id="exportStacked">Export Stacked</button> <button id="closeCompare">Close</button></div></div></div> <script type="x-shader/x-vertex" id="vs-quad">
#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-adjust">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform float u_sharpThresh;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Balanced Sharpening (USM Approximation)
    if (u_sharp > 0.0) {
        vec3 blurred = (
            texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2( 0.0,      -u_step.y)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2( u_step.x, -u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2(-u_step.x,  0.0)).rgb * 0.125 +
            texture(u_tex, v_uv).rgb * 0.25 +
            texture(u_tex, v_uv + vec2( u_step.x,  0.0)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2( 0.0,       u_step.y)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2( u_step.x,  u_step.y)).rgb * 0.0625
        );
        vec3 diff = rgb - blurred;
        // u_sharpThresh 0-100. 
        // A common threshold range for USM is 0.001 to 0.1 in luma. 
        // Let's use a scale that makes the slider feel responsive.
        float th = (u_sharpThresh / 100.0) * 0.1; 
        float factor = smoothstep(th, th * 1.5 + 0.001, length(diff));
        rgb += diff * (u_sharp / 15.0) * factor;
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script> <script type="x-shader/x-fragment" id="fs-mask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; 
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.2126, 0.7152, 0.0722));
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-colorMask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;
uniform float u_tolerance;
uniform float u_fade;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float d = distance(c.rgb, u_targetColor);
    float mask = 1.0 - smoothstep(u_tolerance, u_tolerance + u_fade + 0.001, d);
    outColor = vec4(mask, mask, mask, 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-noise">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; 
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; 
uniform float u_paramA;
uniform float u_paramB;
uniform float u_paramC;

float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec2 hash22(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

// Interleaved Gradient Noise
float IGN(vec2 p) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(p, magic.xy)));
}

float getBlue(vec2 p) {
    float white = IGN(p);
    float low = (IGN(p + vec2(1.0, 0.0)) + IGN(p - vec2(1.0, 0.0)) + IGN(p + vec2(0.0, 1.0)) + IGN(p - vec2(0.0, 1.0))) * 0.25;
    return clamp(white - low + 0.5, 0.0, 1.0); 
}

// Perlin Noise (Simple Value Noise variant for better GPU stability)
float perlin(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash12(i);
    float b = hash12(i + vec2(1.0, 0.0));
    float c = hash12(i + vec2(0.0, 1.0));
    float d = hash12(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

// Worley Noise
float worley(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);
    float d = 1.0;
    for(int y = -1; y <= 1; y++) {
        for(int x = -1; x <= 1; x++) {
            vec2 g = vec2(float(x), float(y));
            vec2 o = hash22(n + g);
            vec2 r = g + o - f;
            d = min(d, dot(r, r));
        }
    }
    return sqrt(d);
}

void main() {
    vec2 pos = v_uv * u_origRes; 
    float s = max(1.0, u_scale);
    vec2 cell = floor(pos / s);
    
    vec3 n;
    if (u_type == 1) { // Grayscale White
        n = vec3(hash12(cell + u_seed));
    } else if (u_type == 0) { // Color White
        n = vec3(hash12(cell + u_seed), hash12(cell + u_seed + 1.23), hash12(cell + u_seed + 2.45));
    } else if (u_type == 3) { // Blue Noise (Gray)
        n = vec3(getBlue(cell + u_seed * 11.0));
    } else if (u_type == 4) { // Blue Noise (Color)
        n = vec3(getBlue(cell + u_seed * 11.0), getBlue(cell + u_seed * 17.0 + 1.23), getBlue(cell + u_seed * 23.0 + 2.45));
    } else if (u_type == 5) { // Perlin (Cloudy)
        float octs = floor(u_paramA * 7.0) + 1.0; // 1-8 octaves
        float persistence = 0.5 + (u_paramC - 0.5) * 0.5;
        float noiseSum = 0.0;
        float amp = 1.0;
        float freq = 1.0 / (s * 10.0 + (u_paramB * 50.0));
        for(int i = 0; i < 8; i++) {
            if(float(i) >= octs) break;
            noiseSum += perlin(pos * freq + u_seed * 1.5) * amp;
            amp *= persistence;
            freq *= 2.0;
        }
        n = vec3(noiseSum);
    } else if (u_type == 6) { // Worley (Cellular)
        float jitter = u_paramA;
        float density = 1.0 / (s * 5.0 + (u_paramB * 20.0));
        vec2 p = pos * density;
        vec2 n_cell = floor(p);
        vec2 f = fract(p);
        float d = 1.0;
        for(int y = -1; y <= 1; y++) {
            for(int x = -1; x <= 1; x++) {
                vec2 g = vec2(float(x), float(y));
                vec2 o = hash22(n_cell + g) * jitter;
                vec2 r = g + o - f;
                float dist = mix(abs(r.x) + abs(r.y), length(r), u_paramC); // Morph between Manhattan and Euclidean
                d = min(d, dist);
            }
        }
        n = vec3(d);
    } else if (u_type == 7) { // Scanlines
        float thick = mix(0.1, 0.9, u_paramA);
        float jitter = (hash12(vec2(u_seed)) - 0.5) * u_paramB * 5.0;
        float line = sin((pos.y + jitter) / s * 3.14159) * 0.5 + 0.5;
        float val = step(thick, line);
        n = vec3(mix(val, val * hash12(cell + u_seed), u_paramC));
    } else if (u_type == 8) { // Speckle (Dust)
        float density = mix(0.8, 0.999, u_paramA);
        float h = hash12(cell + u_seed);
        float speck = smoothstep(density, density + mix(0.01, 0.1, u_paramB), h);
        float sizeVar = hash12(cell * 0.5 + u_seed);
        n = vec3(speck * mix(1.0, sizeVar, u_paramC));
    } else if (u_type == 9) { // Glitch
        float blockSize = s * (5.0 + u_paramA * 50.0);
        float block = floor(pos.y / blockSize);
        float shift = (hash12(vec2(block, u_seed)) - 0.5) * u_paramB * 100.0;
        float split = u_paramC * 10.0;
        n = vec3(
            hash12(floor((pos + vec2(shift - split, 0.0)) / s) + u_seed),
            hash12(floor((pos + vec2(shift, 0.0)) / s) + u_seed),
            hash12(floor((pos + vec2(shift + split, 0.0)) / s) + u_seed)
        );
    } else if (u_type == 10) { // Anisotropic (Fiber)
        float stretch = 0.01 + u_paramA * 0.5;
        float rot = u_paramB * 6.28;
        mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
        vec2 p = (m * pos) * vec2(stretch, 1.0) / s;
        float h = hash12(floor(p) + u_seed);
        n = vec3(mix(h, h * hash12(cell + u_seed), u_paramC));
    } else if (u_type == 11) { // Voronoi Mosaic
        float scale = 1.0 / (s * 10.0 + u_paramA * 40.0);
        vec2 p = pos * scale;
        vec2 n_cell = floor(p);
        vec2 f = fract(p);
        float d = 1.0;
        vec2 m_cell;
        for(int y = -1; y <= 1; y++) {
            for(int x = -1; x <= 1; x++) {
                vec2 g = vec2(float(x), float(y));
                vec2 o = hash22(n_cell + g) * u_paramB;
                vec2 r = g + o - f;
                float dist = dot(r, r);
                if (dist < d) { d = dist; m_cell = n_cell + g; }
            }
        }
        vec3 col = vec3(hash12(m_cell + u_seed), hash12(m_cell + u_seed + 1.1), hash12(m_cell + u_seed + 2.2));
        n = mix(col, vec3(sqrt(d)), u_paramC);
    } else if (u_type == 12) { // Crosshatch
        float dens = 1.0 / (s * (1.0 + u_paramA * 5.0));
        float angle = u_paramB * 1.57;
        mat2 m1 = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        mat2 m2 = mat2(cos(-angle), -sin(-angle), sin(-angle), cos(-angle));
        float l1 = step(0.8, sin((m1 * pos).x * dens) * 0.5 + 0.5);
        float l2 = step(0.8, sin((m2 * pos).x * dens) * 0.5 + 0.5);
        float hatch = max(l1, l2);
        n = vec3(mix(hatch, hatch * hash12(cell + u_seed), u_paramC));
    } else {
        n = vec3(hash12(cell + u_seed));
    }
    
    outColor = vec4(n, 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-blur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (32 taps, directional)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = 1.0 - abs(i) / 16.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.0);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 5.0 * 5.0)); // Larger sigma for wider kernel
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s * weight;
            total += weight;
        }
    }
    outColor = color / total;
}
</script> <script type="x-shader/x-fragment" id="fs-composite">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; 
uniform int u_nType; 
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; 
uniform float u_ignAstr;
uniform float u_skinProt;

float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

float getSkinMask(vec3 rgb) {
    float r = rgb.r * 255.0;
    float g = rgb.g * 255.0;
    float b = rgb.b * 255.0;
    float cb = 128.0 + ( -0.168736 * r - 0.331264 * g + 0.5 * b );
    float cr = 128.0 + ( 0.5 * r - 0.418688 * g - 0.081312 * b );
    float dist = length(vec2(cr - 153.0, cb - 102.0)) / 30.0;
    return 1.0 - smoothstep(0.8, 1.2, dist);
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); 
    vec3 n = nc.rgb;
    vec3 res;
    vec3 base = bc.rgb;
    
    if (u_nType == 2) {
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        float lum = dot(base, vec3(0.2126, 0.7152, 0.0722));
        float effectStr = u_str/50.0;
        if (u_skinProt > 0.0) {
            float skin = getSkinMask(base);
            effectStr *= (1.0 - skin * (u_skinProt / 100.0));
        }
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * effectStr); 
        res = satColor;
    } else {
        vec3 noiseLayer = nc.rgb;
        if (u_mode == 0) { 
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { 
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { 
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { 
            res = base * noiseLayer;
        } else if (u_mode == 4) { 
            res = base + noiseLayer;
        } else if (u_mode == 5) { 
            res = abs(base - noiseLayer);
        }
        
        float maskVal = mc.r; 
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); 
        
        if (u_skinProt > 0.0) {
            float skin = getSkinMask(base);
            finalOp *= (1.0 - skin * (u_skinProt / 100.0));
        }

        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}
</script> <script type="x-shader/x-fragment" id="fs-chroma">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

uniform float u_zoomBlur;
uniform int u_falloffToBlur;

void main() {
    if (u_amt <= 0.0 && u_blur <= 0.0 && u_zoomBlur <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    
    // Calculate clear zone mask
    float clearMask = 0.0;
    if (u_radius > 0.0 || u_falloff > 0.0) {
        clearMask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    }
    
    float blurStr = u_blur;
    float zoomStr = u_zoomBlur;
    if (u_falloffToBlur == 1) {
        blurStr *= (1.0 - clearMask);
        zoomStr *= (1.0 - clearMask);
    }

    // Calculate aberration strength based on distance from center
    float str = dist * dist * (u_amt / 1000.0); 
    str *= (1.0 - clearMask); 
    
    vec4 result = vec4(0.0);
    
    // We combine edge blur (directional jitter) and zoom blur (radial jitter)
    if (blurStr > 0.0 || zoomStr > 0.0) {
        float totalWeight = 0.0;
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * blurStr * 0.002; 
            // Zoom blur: samples along the 'dir' vector
            vec2 zoomOff = dir * (i * zoomStr * 0.02);
            float w = exp(-(i*i)/2.0); 
            
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t) + zoomOff).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5) + zoomOff * 0.5).g; 
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t) + zoomOff * 1.5).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}
</script> <script type="x-shader/x-fragment" id="fs-radial">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform vec2 u_res;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

void main() {
    float dist = length(v_uv - u_center);
    float mask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    outColor = vec4(vec3(mask), 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-palette">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_palette[256];
uniform int u_paletteSize;
uniform float u_blend;
uniform float u_smoothing;
uniform int u_smoothingType;
uniform vec2 u_res;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec2 texel = 1.0 / u_res;
    
    if (u_smoothing > 0.0) {
        float sumW = 0.0;
        vec3 sumC = vec3(0.0);
        float r = u_smoothing / 10.0; // Effective radius
        
        for(float i = -1.0; i <= 1.0; i++) {
            for(float j = -1.0; j <= 1.0; j++) {
                vec2 off = vec2(i, j) * texel * r;
                float weight = 1.0;
                
                if (u_smoothingType == 1) {
                    // 3x3 Gaussian Weights
                    float distSq = i*i + j*j;
                    weight = exp(-distSq / 1.0); // Simple Gaussian
                }
                
                sumC += texture(u_tex, v_uv + off).rgb * weight;
                sumW += weight;
            }
        }
        original = sumC / sumW;
    }
    
    if (u_paletteSize == 0) {
        outColor = c;
        return;
    }
    
    float minDist = 1e10;
    vec3 bestColor = u_palette[0];
    
    for (int i = 0; i < u_paletteSize; i++) {
        float d = distance(original, u_palette[i]);
        if (d < minDist) {
            minDist = d;
            bestColor = u_palette[i];
        }
    }
    
    vec3 res = mix(original, bestColor, u_blend);
    outColor = vec4(clamp(res, 0.0, 1.0), c.a);
}
</script> <script type="x-shader/x-fragment" id="fs-edge">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;
uniform int u_mode; // 0=Overlay, 1=Saturation
uniform float u_strength;
uniform float u_tolerance;
uniform float u_bgSat;
uniform float u_fgSat;
uniform float u_bloom;
uniform float u_smooth;
uniform float u_blend;

float getLuma(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
    vec2 texel = 1.0 / u_res;
    
    // Sobel Kernels
    float x = texel.x;
    float y = texel.y;
    
    float m00 = getLuma(texture(u_tex, v_uv + vec2(-x, -y)).rgb);
    float m01 = getLuma(texture(u_tex, v_uv + vec2( 0, -y)).rgb);
    float m02 = getLuma(texture(u_tex, v_uv + vec2( x, -y)).rgb);
    float m10 = getLuma(texture(u_tex, v_uv + vec2(-x,  0)).rgb);
    float m12 = getLuma(texture(u_tex, v_uv + vec2( x,  0)).rgb);
    float m20 = getLuma(texture(u_tex, v_uv + vec2(-x,  y)).rgb);
    float m21 = getLuma(texture(u_tex, v_uv + vec2( 0,  y)).rgb);
    float m22 = getLuma(texture(u_tex, v_uv + vec2( x,  y)).rgb);
    
    float gx = (m02 + 2.0*m12 + m22) - (m00 + 2.0*m10 + m20);
    float gy = (m00 + 2.0*m01 + m02) - (m20 + 2.0*m21 + m22);
    
    float edge = sqrt(gx*gx + gy*gy);
    
    // Threshold & Strength
    edge = smoothstep(u_tolerance / 100.0, (u_tolerance + 10.0) / 100.0, edge) * (u_strength / 100.0);
    edge = clamp(edge, 0.0, 1.0);
    
    float spreadMask = edge;
    
    if (u_bloom > 0.0) {
        float accumE = 0.0;
        float radius = u_bloom;
        int taps = clamp(int(radius * 1.5), 16, 48);
        float tapLimit = float(taps);
        
        for(int i = 1; i <= 48; i++) {
            if (i > taps) break;
            float f = float(i);
            float r = sqrt(f / tapLimit) * radius;
            float theta = f * 2.39996323; // Golden angle
            vec2 off = vec2(cos(theta), sin(theta)) * r * texel;
            
            // Approximate gradient at neighbor to see if it's an edge
            float nL = getLuma(texture(u_tex, v_uv + off).rgb);
            float nLx = getLuma(texture(u_tex, v_uv + off + vec2(x, 0.0)).rgb);
            float nLy = getLuma(texture(u_tex, v_uv + off + vec2(0.0, y)).rgb);
            
            float ne = abs(nLx - nL) + abs(nLy - nL);
            // Multiply by 4.0 to roughly match Sobel intensity
            ne = smoothstep(u_tolerance / 100.0, (u_tolerance + 10.0) / 100.0, ne * 4.0) * (u_strength / 100.0);
            
            // Fade based on u_smooth slider
            float falloff = mix(1.0, 1.0 - (r / radius), clamp(u_smooth / 100.0, 0.0, 1.0));
            
            accumE += ne * max(falloff, 0.0);
        }
        
        // Normalize the bloom intensity using sqrt of taps to ensure thin edge lines bloom brightly
        float bloomE = clamp((accumE / sqrt(tapLimit)) * 1.6, 0.0, 1.0);
        
        spreadMask = max(edge, bloomE);
    }
    
    vec4 c = texture(u_tex, v_uv);
    vec3 res = c.rgb;
    
    if (u_mode == 0) {
        // Overlay Mode
        res = mix(c.rgb, vec3(1.0), spreadMask);
    } else {
        // Saturation Mask Mode
        float lum = getLuma(c.rgb);
        vec3 bw = vec3(lum);
        
        // Background: Desaturated or partially saturated
        vec3 bg = mix(bw, c.rgb, u_bgSat / 100.0);
        // Foreground: Saturated
        vec3 fg = mix(bw, c.rgb, u_fgSat / 100.0);
        
        res = mix(bg, fg, spreadMask);
    }
    
    outColor = vec4(mix(c.rgb, res, u_blend / 100.0), c.a);
}
</script> <script type="x-shader/x-fragment" id="fs-copy">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_channel; 

void main() {
    vec4 c = texture(u_tex, v_uv);
    if (u_channel == 1) outColor = vec4(c.rrr, 1.0);
    else if (u_channel == 2) outColor = vec4(c.ggg, 1.0);
    else if (u_channel == 3) outColor = vec4(c.bbb, 1.0);
    else outColor = c;
}
</script> <script type="x-shader/x-fragment" id="fs-invert">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;

void main() {
    float mask = texture(u_tex, v_uv).r;
    float inv = 1.0 - mask;
    // We output inversed mask to R channel (and everything else for safety)
    outColor = vec4(inv, inv, inv, 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-dither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_type; // 0=B8, 1=B4, 2=B2, 3=Noise, 4=IGN
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;
uniform int u_usePalette;
uniform int u_gamma;
uniform vec3 u_customPalette[256];

float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

float bayer4x4(vec2 pos) {
    int x = int(mod(pos.x, 4.0));
    int y = int(mod(pos.y, 4.0));
    int index = x + y * 4;
    int pattern[16] = int[16](
        0, 8, 2, 10,
        12, 4, 14, 6,
        3, 11, 1, 9,
        15, 7, 13, 5
    );
    return float(pattern[index]) / 16.0;
}

float bayer2x2(vec2 pos) {
    int x = int(mod(pos.x, 2.0));
    int y = int(mod(pos.y, 2.0));
    int index = x + y * 2;
    int pattern[4] = int[4](0, 2, 3, 1);
    return float(pattern[index]) / 4.0;
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float ign(vec2 p) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(p, magic.xy)));
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    vec3 color = col.rgb;
    
    if (u_gamma == 1) {
        color = pow(color, vec3(2.2));
    }
    
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    float threshold;
    if (u_type == 0) threshold = bayer8x8(scaledPos) - 0.5;
    else if (u_type == 1) threshold = bayer4x4(scaledPos) - 0.5;
    else if (u_type == 2) threshold = bayer2x2(scaledPos) - 0.5;
    else if (u_type == 3) threshold = hash12(scaledPos + u_seed) - 0.5;
    else threshold = ign(scaledPos) - 0.5;
    
    float levels = pow(2.0, u_bitDepth);
    vec3 dithered = color + threshold * (u_strength) * (1.0 / levels);
    
    vec3 result;
    if (u_usePalette == 1 && u_paletteSize > 0.5) {
        float minDist = 1e10;
        result = u_customPalette[0];
        int size = int(u_paletteSize);
        for (int i = 0; i < 256; i++) {
            if (i >= size) break;
            float d = distance(dithered, u_customPalette[i]);
            if (d < minDist) {
                minDist = d;
                result = u_customPalette[i];
            }
        }
    } else {
        result = floor(dithered * levels + 0.5) / levels;
        result = floor(result * u_paletteSize + 0.5) / u_paletteSize;
    }
    
    if (u_gamma == 1) {
        result = pow(result, vec3(1.0/2.2));
    }
    
    outColor = vec4(clamp(result, 0.0, 1.0), col.a);
}
</script> <script type="x-shader/x-fragment" id="fs-analog">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_time;     // For animation
uniform float u_wobble;   // 0-1
uniform float u_bleed;    // 0-1
uniform float u_curve;    // 0-1
uniform float u_noise;    // 0-1

// Simple PRNG
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    vec2 uv = v_uv;

    // 1. CRT Curvature
    // Shift UV to center (-0.5 to 0.5)
    vec2 cc = uv - 0.5;
    // Calculate distance and apply barrel distortion
    float r2 = cc.x*cc.x + cc.y*cc.y;
    // Curve factor scales distortion
    uv = cc * (1.0 + u_curve * r2 * 2.0) + 0.5;

    // Border masking for curvature
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        outColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }

    // 2. Tape Tracking Wobble (Horizontal displacement based on vertical position)
    // Create a composite sine wave varying over time and Y axis
    float wobbleOffset = sin(uv.y * 20.0 + u_time * 5.0) * 0.005 + 
                         sin(uv.y * 50.0 - u_time * 15.0) * 0.002;
    uv.x += wobbleOffset * u_wobble;

    // 3. Chromatic Bleed / Chromatic Aberration
    // Sample channels separately with slight horizontal offsets
    float bleedOffset = 0.005 * u_bleed;
    float r = texture(u_tex, vec2(uv.x + bleedOffset, uv.y)).r;
    float g = texture(u_tex, uv).g;
    float b = texture(u_tex, vec2(uv.x - bleedOffset, uv.y)).b;
    vec3 col = vec3(r, g, b);

    // 4. Scanline Noise
    // High-frequency horizontal lines combined with random noise
    float scanline = sin(uv.y * 800.0) * 0.04 * u_noise;
    float staticNoise = (rand(uv + mod(u_time, 10.0)) - 0.5) * 0.1 * u_noise;
    col += scanline + staticNoise;

    outColor = vec4(clamp(col, 0.0, 1.0), 1.0);
}
    </script> <script type="x-shader/x-fragment" id="fs-corruption">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_algorithm; // 0=jpeg blocks, 1=pixelation, 2=color bleed
uniform float u_resScale; // 1-100 (lower = more corruption)
uniform vec2 u_res;
uniform float u_iteration; // current iteration for variation

void main() {
    // Calculate block size based on resolution scale (inverted: lower scale = bigger blocks)
    float blockSize = max(2.0, (100.0 - u_resScale) / 5.0 + 1.0);
    
    vec4 col;
    
    if (u_algorithm == 0) {
        // JPEG-like block artifacts
        vec2 blockPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        vec2 blockCenter = blockPos + (blockSize * 0.5) / u_res;
        
        // Sample from block center with some offset for artifact feel
        vec2 offset = (v_uv - blockPos) * u_res / blockSize;
        offset = floor(offset * 2.0) / 2.0 * blockSize / u_res;
        
        col = texture(u_tex, blockPos + offset);
        
        // Add slight color shifting at block edges
        vec2 edgeDist = abs(fract(v_uv * u_res / blockSize) - 0.5);
        float edge = smoothstep(0.3, 0.5, max(edgeDist.x, edgeDist.y));
        col.rgb = mix(col.rgb, col.rgb * 0.95, edge * 0.3);
        
    } else if (u_algorithm == 1) {
        // Pixelation - simple downscale/upscale
        vec2 pixelPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        col = texture(u_tex, pixelPos + (blockSize * 0.5) / u_res);
        
    } else {
        // Color bleed - horizontal color smearing
        float bleedAmount = blockSize / u_res.x;
        vec4 left = texture(u_tex, v_uv - vec2(bleedAmount, 0.0));
        vec4 center = texture(u_tex, v_uv);
        vec4 right = texture(u_tex, v_uv + vec2(bleedAmount, 0.0));
        
        // Shift color channels
        col.r = mix(center.r, right.r, 0.3);
        col.g = center.g;
        col.b = mix(center.b, left.b, 0.3);
        col.a = center.a;
    }
    
    outColor = col;
}
</script> } <script type="x-shader/x-fragment" id="fs-lens">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amount; // -1.0 to 1.0 (negative = barrel, positive = pincushion)
uniform float u_scale;  // Scaling factor to counteract zooming

void main() {
    // Convert UV to center-relative coordinates (-1.0 to 1.0)
    vec2 p = v_uv * 2.0 - 1.0;
    
    // Calculate distance from center (radius squared)
    float r2 = p.x * p.x + p.y * p.y;
    
    // Apply distortion algorithm
    // newRadius = radius * (1 + amount * radius^2)
    float f = 1.0 + r2 * u_amount;
    
    // Calculate new position and apply scaling
    vec2 distorted = p * f * u_scale;
    
    // Convert back from center-relative to standard 0.0-1.0 UV space
    vec2 uv = (distorted + 1.0) / 2.0;
    
    // Mask out areas that fall outside the image borders
    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        // Transparent black for out-of-bounds
        outColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        outColor = texture(u_tex, uv);
    }
}
    </script> <script type="x-shader/x-fragment" id="fs-heatwave">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_time;     // For animation
uniform float u_intensity;// Overall strength
uniform float u_speed;    // Animation speed
uniform float u_scale;    // Size of the waves/ripples
uniform int u_direction;  // 0 = Vertical (Heat), 1 = Horizontal, 2 = Radial (Ripple)

void main() {
    vec2 uv = v_uv;
    vec2 offset = vec2(0.0);
    
    float t = u_time * u_speed;
    
    if (u_direction == 0) {
        // Vertical Distortion (Heat rising)
        // Offset X based on Y and time. Modulate amplitude based on Y (more heat at bottom? or uniform? let's do uniform for now with slight Y scaling)
        offset.x = sin(uv.y * u_scale + t) * u_intensity;
        // Add a secondary thinner frequency for turbulence
        offset.x += cos(uv.y * u_scale * 2.5 - t * 1.5) * (u_intensity * 0.3);
    } 
    else if (u_direction == 1) {
        // Horizontal Distortion (Flag waving)
        // Offset Y based on X and time
        offset.y = sin(uv.x * u_scale + t) * u_intensity;
        offset.y += cos(uv.x * u_scale * 2.5 - t * 1.5) * (u_intensity * 0.3);
    }
    else if (u_direction == 2) {
        // Radial Distortions (Ripples originating from center)
        vec2 center = vec2(0.5, 0.5);
        vec2 d = uv - center;
        float dist = length(d);
        
        // Offset magnitude travels outwards from center
        float wave = sin(dist * u_scale - t) * u_intensity;
        // Attenuate by distance so it doesn't get crazy at edges (or leave it uniform)
        // Let's leave it uniform for a localized drop effect, or dampen it.
        // wave *= (1.0 - clamp(dist*2.0, 0.0, 1.0)); // Optional dampening
        
        // Push pixels along the normal vector from center
        vec2 dir = normalize(d);
        // Avoid division by zero exactly at center
        if (dist > 0.0001) {
            offset = dir * wave;
        }
    }
    
    // Apply displacement
    vec2 final_uv = uv + offset;
    
    // Clamp to edges using mirorring or clamping to prevent sampling out-of-bounds transparency
    // WebGL CLAMP_TO_EDGE usually handles this, but a manual clamp prevents ugly smearing if scale is high
    final_uv = clamp(final_uv, 0.0, 1.0);

    outColor = texture(u_tex, final_uv);
}
    </script> <script type="x-shader/x-fragment" id="fs-lightleaks">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_intensity;
uniform vec3 u_color1;
uniform vec3 u_color2;
uniform float u_time;

void main() {
    vec4 col = texture(u_tex, v_uv);
    
    // Create animated gradients using UVs and time
    // Leak 1: from left side
    float leak1 = smoothstep(0.4, 0.0, v_uv.x + sin(v_uv.y * 5.0 + u_time) * 0.1);
    
    // Leak 2: from top right
    float distSq = dot(v_uv - vec2(1.0, 1.0), v_uv - vec2(1.0, 1.0));
    float leak2 = smoothstep(0.8, 0.0, distSq + cos(v_uv.x * 3.0 - u_time * 0.5) * 0.2);
    
    // Accumulate the light leaks
    vec3 resultLeak = (u_color1 * leak1) + (u_color2 * leak2);
    
    // Additive blending based on intensity
    vec3 finalColor = col.rgb + (resultLeak * u_intensity);
    
    outColor = vec4(finalColor, col.a);
}
    </script> <script type="x-shader/x-fragment" id="fs-compression">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_method;       // 0=DCT Block, 1=Chroma Subsampling, 2=Wavelet
uniform float u_quality;    // 1-100 (lower = more compression)
uniform float u_blockSize;  // 2-32
uniform float u_blend;      // 0-1

// sRGB <-> Linear helpers
vec3 toLinear(vec3 c) { return pow(c, vec3(2.2)); }
vec3 toSRGB(vec3 c) { return pow(max(c, vec3(0.0)), vec3(1.0/2.2)); }

void main() {
    vec4 original = texture(u_tex, v_uv);
    vec3 result = original.rgb;
    vec2 px = 1.0 / u_res;

    // Quality maps: low quality = heavy artifacts
    float qNorm = u_quality / 100.0;     // 0.01 - 1.0
    float qInv  = 1.0 - qNorm;           // inverse: high = more degradation

    if (u_method == 0) {
        // --- DCT Block Quantization ---
        // Simulates 8x8 block-based DCT compression (JPEG-like)
        float bs = max(2.0, u_blockSize);

        // Block-aligned UV
        vec2 blockCoord = floor(v_uv * u_res / bs);
        vec2 blockUV    = blockCoord * bs / u_res;
        vec2 blockCenter = blockUV + (bs * 0.5) * px;

        // Sample the block center color (simulates DC coefficient)
        vec3 dcColor = texture(u_tex, blockCenter).rgb;

        // Sample current pixel
        vec3 acColor = original.rgb;

        // Quantization strength: lower quality = more DC dominance
        float quantStrength = qInv * qInv;  // Quadratic curve for natural feel

        // Quantize color channels to simulate coefficient truncation
        float levels = mix(256.0, max(4.0, 8.0 * qNorm), quantStrength);
        vec3 quantized = floor(acColor * levels + 0.5) / levels;

        // Blend between quantized pixel and block average based on quality
        result = mix(quantized, dcColor, quantStrength * 0.6);

        // Block edge ringing artifact
        vec2 blockFract = fract(v_uv * u_res / bs);
        vec2 edgeDist = abs(blockFract - 0.5);
        float edgeFactor = smoothstep(0.35, 0.5, max(edgeDist.x, edgeDist.y));
        // Ringing: slight overshoot at edges
        vec3 ringing = result + (result - dcColor) * 0.15;
        result = mix(result, ringing, edgeFactor * quantStrength);

    } else if (u_method == 1) {
        // --- Chroma Subsampling (4:2:0) ---
        // Preserves luma at full res, downsamples chroma in 2x2 blocks
        float chromaBlock = max(2.0, u_blockSize);

        // Current pixel luma (Rec.709)
        float luma = dot(original.rgb, vec3(0.2126, 0.7152, 0.0722));

        // Downsample chroma: snap to block grid center
        vec2 chromaCoord = floor(v_uv * u_res / chromaBlock);
        vec2 chromaUV    = (chromaCoord + 0.5) * chromaBlock * px;
        vec3 chromaSample = texture(u_tex, chromaUV).rgb;
        float chromaLuma = dot(chromaSample, vec3(0.2126, 0.7152, 0.0722));

        // Reconstruct: keep original luma, use downsampled chroma
        vec3 chromaDiff = chromaSample - vec3(chromaLuma);
        vec3 reconstructed = vec3(luma) + chromaDiff;

        // Quality controls how much chroma is subsampled
        result = mix(original.rgb, reconstructed, qInv);

    } else {
        // --- Wavelet-Style Compression ---
        // Simulates frequency-selective coefficient zeroing
        // Low quality = aggressive low-pass filtering + banding

        // Adaptive blur radius from quality
        float blurRadius = qInv * u_blockSize * 0.5;

        // Simple box blur approximation (5 taps per axis = 25 total)
        vec3 blurred = vec3(0.0);
        float totalW = 0.0;
        for (float dx = -2.0; dx <= 2.0; dx += 1.0) {
            for (float dy = -2.0; dy <= 2.0; dy += 1.0) {
                vec2 offset = vec2(dx, dy) * px * blurRadius;
                float w = exp(-(dx*dx + dy*dy) / 8.0);
                blurred += texture(u_tex, v_uv + offset).rgb * w;
                totalW += w;
            }
        }
        blurred /= totalW;

        // Banding: quantize to fewer levels
        float bandLevels = mix(256.0, max(8.0, 32.0 * qNorm), qInv);
        vec3 banded = floor(blurred * bandLevels + 0.5) / bandLevels;

        // Blend between sharp and banded-blurred
        result = mix(original.rgb, banded, qInv * 0.8);
    }

    // Final blend with original
    result = mix(original.rgb, result, u_blend);
    outColor = vec4(clamp(result, 0.0, 1.0), original.a);
}
</script> <script type="x-shader/x-fragment" id="fs-cell">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_levels;         // 2-12
uniform float u_bias;         // -1.0 to 1.0 (contrast bias)
uniform float u_gamma;        // 0.5 to 2.2
uniform int u_quantMode;      // 0=Luma, 1=RGB, 2=HSV
uniform int u_bandMap;        // 0=Linear, 1=Smooth, 2=Poster
uniform int u_edgeMethod;     // 0=None, 1=Sobel, 2=Laplc
uniform float u_edgeStr;      // 0-1
uniform float u_edgeThick;    // 0.5-3.0
uniform int u_colorPreserve;  // 0/1 bool
uniform int u_edgeEnable;     // 0/1 bool

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float getLuma(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

float quantize(float val, int levels, float bias, float gamma) {
    // Apply bias
    val = clamp(val + bias, 0.0, 1.0);
    
    // Apply gamma
    val = pow(val, gamma);
    
    // Quantize
    float fLevels = float(levels);
    float q = floor(val * fLevels) / (fLevels - 1.0);
    
    // Map output based on band mode
    if (u_bandMap == 1) { // Smooth
        q = smoothstep(0.0, 1.0, q);
    } else if (u_bandMap == 2) { // Posterize hard
        q = floor(val * fLevels) / fLevels; 
    }
    
    return q;
}

float sobel(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l00 = getLuma(texture(u_tex, uv + vec2(-px.x, -px.y)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l20 = getLuma(texture(u_tex, uv + vec2(px.x, -px.y)).rgb);
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l02 = getLuma(texture(u_tex, uv + vec2(-px.x, px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l22 = getLuma(texture(u_tex, uv + vec2(px.x, px.y)).rgb);
    
    float gx = l00 + 2.0*l01 + l02 - (l20 + 2.0*l21 + l22);
    float gy = l00 + 2.0*l10 + l20 - (l02 + 2.0*l12 + l22);
    
    return sqrt(gx*gx + gy*gy);
}

float laplacian(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l11 = getLuma(texture(u_tex, uv).rgb); // Center
    
    return abs(l01 + l21 + l10 + l12 - 4.0 * l11) * 2.0;
}

void main() {
    vec4 base = texture(u_tex, v_uv);
    vec3 col = base.rgb;
    
    // Apply Quantization
    vec3 res = col;
    if (u_quantMode == 0) { // Luma
        float l = getLuma(col);
        float q = quantize(l, u_levels, u_bias, u_gamma);
        if (u_colorPreserve == 1) {
            // Preserve color, only quantize lightness
            vec3 hsv = rgb2hsv(col);
            hsv.z = q;
            res = hsv2rgb(hsv);
        } else {
            res = vec3(q);
        }
    } else if (u_quantMode == 1) { // RGB
        res.r = quantize(col.r, u_levels, u_bias, u_gamma);
        res.g = quantize(col.g, u_levels, u_bias, u_gamma);
        res.b = quantize(col.b, u_levels, u_bias, u_gamma);
    } else { // HSV Value
        vec3 hsv = rgb2hsv(col);
        hsv.z = quantize(hsv.z, u_levels, u_bias, u_gamma);
        res = hsv2rgb(hsv);
    }
    
    // Apply Edges
    if (u_edgeEnable == 1 && u_edgeMethod > 0) {
        float edge = 0.0;
        if (u_edgeMethod == 1) edge = sobel(v_uv);
        else if (u_edgeMethod == 2) edge = laplacian(v_uv);
        
        edge = smoothstep(0.1, 1.0, edge * 2.0); // Boost edge visibility
        res = mix(res, vec3(0.0), edge * u_edgeStr);
    }
    
    outColor = vec4(res, base.a);
}
</script> <script type="x-shader/x-fragment" id="fs-halftone">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform float u_size;           // 1-12
uniform float u_intensity;      // 0-1
uniform float u_sharpness;      // 0-1
uniform int u_pattern;          // 0=Circ, 1=Line, 2=Cross, 3=Diamond
uniform int u_colorMode;        // 0=Luma, 1=RGB, 2=CMY, 3=CMYK
uniform int u_sample;           // 0=Center, 1=Avg
uniform int u_gray;             // Bool
uniform int u_lock;             // Bool
uniform int u_invert;           // Bool

float getPattern(vec2 uv, float angle) {
    float s = sin(angle), c = cos(angle);
    vec2 p = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y) * u_res / u_size; // Map to pattern space
    vec2 grid = fract(p) - 0.5;
    
    float d = 0.0;
    if (u_pattern == 0) { // Circle
        d = length(grid) * 2.0; // 0-1 range center to corner
    } else if (u_pattern == 1) { // Line
        d = abs(grid.y) * 2.0;
    } else if (u_pattern == 2) { // Cross
        d = min(abs(grid.x), abs(grid.y)) * 2.0;
    } else { // Diamond
        d = (abs(grid.x) + abs(grid.y));
    }
    
    return d; // 0 at center/peak, 1 at edge
}

void main() {
    float angle = 0.0; // Default angle
    if (u_sample == 2) angle = 0.785; // 45 deg for rotated
    
    vec2 sampleUV = v_uv;
    if (u_lock == 0) {
        // Pattern follows image (UV space), scale by res ratio to keep square dots
        // Actually simpler: just rely on u_size scaling against u_res
    }
    
    vec4 col = texture(u_tex, v_uv);
    
    // Halftone Logic
    vec3 outRGB = vec3(0.0);
    
    if (u_colorMode == 0) { // Luminance
        float l = dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));
        float pat = getPattern(v_uv, 0.785); // 45 degree default for mono
        
        // Threshold
        // Pattern goes 0(black) to 1(white). Luma 0(black) to 1(white).
        // Standard HT: if luma > pattern -> white. 
        // With intensity: mix pattern with luma.
        
        // Soft edge based on sharpness
        float thresh = 1.0 - l * u_intensity; // Invert luma for pattern comparison
        float softness = 1.0 - u_sharpness;
        float val = smoothstep(thresh - softness, thresh + softness, pat);
        
        if (u_invert == 1) val = 1.0 - val;
        outRGB = vec3(val);
        
    } else if (u_colorMode == 1) { // RGB
        // Separate angles for R, G, B
        float pR = getPattern(v_uv, 0.26); // ~15 deg
        float pG = getPattern(v_uv, 1.30); // ~75 deg
        float pB = getPattern(v_uv, 0.0);  // 0 deg
        
        float soft = 1.0 - u_sharpness;
        
        float r = smoothstep((1.0 - col.r) - soft, (1.0 - col.r) + soft, pR);
        float g = smoothstep((1.0 - col.g) - soft, (1.0 - col.g) + soft, pG);
        float b = smoothstep((1.0 - col.b) - soft, (1.0 - col.b) + soft, pB);
        
        outRGB = vec3(r, g, b);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
        
    } else { // CMY / CMYK
        // Simple RGB -> CMY
        vec3 cmy = 1.0 - col.rgb;
        float k = 0.0;
        if (u_colorMode == 3) { // CMYK
            k = min(min(cmy.x, cmy.y), cmy.z);
            cmy = (cmy - k) / (1.0 - k);
        }
        
        // Angles: C=15, M=75, Y=0, K=45
        float pC = getPattern(v_uv, 0.26);
        float pM = getPattern(v_uv, 1.30);
        float pY = getPattern(v_uv, 0.0);
        float pK = getPattern(v_uv, 0.785);
        
        float soft = 1.0 - u_sharpness;
        
        // Halftone each channel (0=white, 1=ink). 
        // If pattern < ink_amount -> ink. 
        // Pattern 0(center) to 1(edge). Ink 0(none) to 1(full).
        // If pattern < cmy.r => ink.
        // Invert comparison for white checks?
        // Let's use: if pattern > (1.0 - ink) -> ink ?? No.
        
        // Standard: dot grows from center (0). so if pattern < ink -> ink.
        float hC = 1.0 - smoothstep(cmy.x - soft, cmy.x + soft, pC);
        float hM = 1.0 - smoothstep(cmy.y - soft, cmy.y + soft, pM);
        float hY = 1.0 - smoothstep(cmy.z - soft, cmy.z + soft, pY);
        float hK = 1.0 - smoothstep(k - soft, k + soft, pK);
        
        // Combine CMYK -> RGB
        // white - ink
        vec3 resCMY = vec3(hC, hM, hY);
        if (u_colorMode == 3) resCMY += vec3(hK);
        
        outRGB = 1.0 - clamp(resCMY, 0.0, 1.0);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
    }
    
    if (u_gray == 1) {
        float l = dot(outRGB, vec3(0.2126, 0.7152, 0.0722));
        outRGB = vec3(l);
    }
    
    outColor = vec4(outRGB, col.a);
}
</script> <script type="x-shader/x-fragment" id="fs-bilateral">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_radius;        // 1-30
uniform float u_sigmaCol;    // 0.01 - 1.0
uniform float u_sigmaSpace;  // 0.5 - 15.0
uniform int u_kernel;        // 0=Gauss, 1=Box
uniform int u_edgeMode;      // 0=Luma, 1=RGB

float getDist(vec3 c1, vec3 c2) {
    if (u_edgeMode == 0) {
        float l1 = dot(c1, vec3(0.2126, 0.7152, 0.0722));
        float l2 = dot(c2, vec3(0.2126, 0.7152, 0.0722));
        return abs(l1 - l2);
    } else {
        return length(c1 - c2);
    }
}

void main() {
    vec4 centerCol = texture(u_tex, v_uv);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;
    
    // Separable optimization not easy for true bilateral without ping-pong
    // We will do a full kernel loop but skip somewhat to save perf if radius is high?
    // No, standard loop.
    
    int r = u_radius;
    float fs = u_sigmaSpace;
    float fc = u_sigmaCol;
    
    // Optimization: Stride sampling for large radii to maintain interactivity
    int step = (r > 15) ? 3 : ((r > 8) ? 2 : 1);
    
    for (int x = -r; x <= r; x += step) {
        for (int y = -r; y <= r; y += step) {
            vec2 offset = vec2(float(x), float(y));
            vec2 uv = v_uv + offset / u_res;
            
            vec3 samp = texture(u_tex, uv).rgb;
            
            float spaceDistSq = dot(offset, offset);
            float colorDist = getDist(centerCol.rgb, samp);
            
            float wSpace = 1.0;
            if (u_kernel == 0) wSpace = exp(-spaceDistSq / (2.0 * fs * fs));
            
            float wColor = exp(-(colorDist * colorDist) / (2.0 * fc * fc));
            
            float w = wSpace * wColor;
            
            sum += samp * w;
            weightSum += w;
        }
    }
    
    outColor = vec4(sum / weightSum, centerCol.a);
}
</script> <script type="x-shader/x-fragment" id="fs-denoise">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_useMask;
uniform vec2 u_res;

// Controls
uniform int u_mode;          // 0=NLM, 1=Median, 2=Mean
uniform int u_searchRadius;  // 1-15
uniform int u_patchRadius;   // 1-5 (NLM only)
uniform float u_h;           // filter strength 0.01-2.0
uniform float u_strength;    // blend with original 0-1

// NLM: Compare patches to compute similarity weights
float patchDistance(vec2 p1, vec2 p2, int pRad) {
    float dist = 0.0;
    float count = 0.0;
    vec2 px = 1.0 / u_res;
    // Optimization: stride patch comparison if patch is large
    int step = (pRad >= 3) ? 2 : 1;
    for (int dx = -pRad; dx <= pRad; dx += step) {
        for (int dy = -pRad; dy <= pRad; dy += step) {
            vec2 off = vec2(float(dx), float(dy));
            vec3 c1 = texture(u_tex, p1 + off * px).rgb;
            vec3 c2 = texture(u_tex, p2 + off * px).rgb;
            vec3 d = c1 - c2;
            dist += dot(d, d);
            count += 1.0;
        }
    }
    return dist / count;
}

void main() {
    vec4 original = texture(u_tex, v_uv);
    vec2 px = 1.0 / u_res;
    vec3 result = vec3(0.0);

    if (u_mode == 0) {
        // --- Non-Local Means ---
        float totalWeight = 0.0;
        float h2 = u_h * u_h;
        
        // Optimization: search window striding
        int step = (u_searchRadius >= 10) ? 3 : ((u_searchRadius >= 5) ? 2 : 1);

        for (int sx = -u_searchRadius; sx <= u_searchRadius; sx += step) {
            for (int sy = -u_searchRadius; sy <= u_searchRadius; sy += step) {
                vec2 offset = vec2(float(sx), float(sy));
                vec2 neighborUV = v_uv + offset * px;

                float d = patchDistance(v_uv, neighborUV, u_patchRadius);
                float w = exp(-d / h2);

                result += texture(u_tex, neighborUV).rgb * w;
                totalWeight += w;
            }
        }
        result /= totalWeight;
    }
    else if (u_mode == 1) {
        // --- High-Quality 3x3 Median Filter ---
        // Real median sort for 9 samples to ensure edge preservation.
        vec3 v[9];
        v[0] = texture(u_tex, v_uv + vec2(-px.x, -px.y)).rgb;
        v[1] = texture(u_tex, v_uv + vec2( 0.0,  -px.y)).rgb;
        v[2] = texture(u_tex, v_uv + vec2( px.x, -px.y)).rgb;
        v[3] = texture(u_tex, v_uv + vec2(-px.x,  0.0)).rgb;
        v[4] = texture(u_tex, v_uv + vec2( 0.0,   0.0)).rgb;
        v[5] = texture(u_tex, v_uv + vec2( px.x,  0.0)).rgb;
        v[6] = texture(u_tex, v_uv + vec2(-px.x,  px.y)).rgb;
        v[7] = texture(u_tex, v_uv + vec2( 0.0,   px.y)).rgb;
        v[8] = texture(u_tex, v_uv + vec2( px.x,  px.y)).rgb;

        float l[9];
        for(int i=0; i<9; i++) l[i] = dot(v[i], vec3(0.2126, 0.7152, 0.0722));
        
        // Partial sort (optimized bubble sort for 5 elements)
        for(int i=0; i<5; i++) {
            for(int j=i+1; j<9; j++) {
                if(l[i] > l[j]) {
                    float tempL = l[i]; l[i] = l[j]; l[j] = tempL;
                    vec3 tempV = v[i]; v[i] = v[j]; v[j] = tempV;
                }
            }
        }
        result = v[4];
    }
    else {
        // --- Mean (Box) Filter ---
        float count = 0.0;
        for (int dx = -u_searchRadius; dx <= u_searchRadius; dx++) {
            for (int dy = -u_searchRadius; dy <= u_searchRadius; dy++) {
                vec2 uv = v_uv + vec2(float(dx), float(dy)) * px;
                result += texture(u_tex, uv).rgb;
                count += 1.0;
            }
        }
        result /= count;
    }

    // Blend with original based on strength
    result = mix(original.rgb, result, u_strength);

    // Apply mask if present
    if (u_useMask == 1) {
        float m = texture(u_mask, v_uv).r;
        result = mix(original.rgb, result, m);
    }

    outColor = vec4(result, original.a);
}
</script> <script type="x-shader/x-fragment" id="fs-colorMask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;  // RGB 0-1
uniform float u_tolerance;   // 0-1
uniform float u_fade;        // 0-1

void main() {
    vec4 c = texture(u_tex, v_uv);
    float dist = length(c.rgb - u_targetColor);
    float low = u_tolerance - u_fade * 0.5;
    float high = u_tolerance + u_fade * 0.5;
    float mask = smoothstep(low, high, dist);
    // mask = 0 when color matches (to exclude), 1 elsewhere
    outColor = vec4(mask, mask, mask, 1.0);
}
</script> <script type="x-shader/x-fragment" id="fs-maskedBlur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    float maskVal = texture(u_mask, v_uv).r;
    vec4 original = texture(u_tex, v_uv);
    
    if (maskVal < 0.01) {
        outColor = original;
        return;
    }
    
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (32 taps, directional)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = 1.0 - abs(i) / 16.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.0);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 5.0 * 5.0)); 
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s * weight;
            total += weight;
        }
    }
    
    vec4 blurred = color / total;
    outColor = mix(original, blurred, maskVal);
}
</script> <script type="x-shader/x-fragment" id="fs-maskedDither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_type; // 0=B8, 1=B4, 2=B2, 3=Noise, 4=IGN
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;
uniform int u_usePalette;
uniform int u_gamma;
uniform vec3 u_customPalette[256];

float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

float bayer4x4(vec2 pos) {
    int x = int(mod(pos.x, 4.0));
    int y = int(mod(pos.y, 4.0));
    int index = x + y * 4;
    int pattern[16] = int[16](
        0, 8, 2, 10,
        12, 4, 14, 6,
        3, 11, 1, 9,
        15, 7, 13, 5
    );
    return float(pattern[index]) / 16.0;
}

float bayer2x2(vec2 pos) {
    int x = int(mod(pos.x, 2.0));
    int y = int(mod(pos.y, 2.0));
    int index = x + y * 2;
    int pattern[4] = int[4](0, 2, 3, 1);
    return float(pattern[index]) / 4.0;
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float ign(vec2 p) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(p, magic.xy)));
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    float maskVal = texture(u_mask, v_uv).r;
    
    if (maskVal < 0.001) {
        outColor = col;
        return;
    }
    
    vec3 color = col.rgb;
    if (u_gamma == 1) {
        color = pow(color, vec3(2.2));
    }
    
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    float threshold;
    if (u_type == 0) threshold = bayer8x8(scaledPos) - 0.5;
    else if (u_type == 1) threshold = bayer4x4(scaledPos) - 0.5;
    else if (u_type == 2) threshold = bayer2x2(scaledPos) - 0.5;
    else if (u_type == 3) threshold = hash12(scaledPos + u_seed) - 0.5;
    else threshold = ign(scaledPos) - 0.5;
    
    float levels = pow(2.0, u_bitDepth);
    vec3 dithered = color + threshold * (u_strength) * (1.0 / levels);
    
    vec3 quantized;
    if (u_usePalette == 1 && u_paletteSize > 0.5) {
        float minDist = 1e10;
        quantized = u_customPalette[0];
        int size = int(u_paletteSize);
        for (int i = 0; i < 256; i++) {
            if (i >= size) break;
            float d = distance(dithered, u_customPalette[i]);
            if (d < minDist) {
                minDist = d;
                quantized = u_customPalette[i];
            }
        }
    } else {
        quantized = floor(dithered * levels + 0.5) / levels;
        quantized = floor(quantized * u_paletteSize + 0.5) / u_paletteSize;
    }
    
    if (u_gamma == 1) {
        quantized = pow(quantized, vec3(1.0/2.2));
    }
    
    vec3 result = mix(col.rgb, quantized, maskVal);
    outColor = vec4(clamp(result, 0.0, 1.0), col.a);
}
</script> <script type="x-shader/x-fragment" id="fs-adjustMasked">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_useMask;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform float u_sharpThresh;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Sharpening
    if (u_sharp > 0.0) {
        vec4 sum = vec4(0.0);
        sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x,  u_step.y));
        vec4 edge = c - (sum * 0.25);
        rgb += edge.rgb * (u_sharp / 10.0); 
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    // Apply mask if enabled
    if (u_useMask == 1) {
        float maskVal = texture(u_mask, v_uv).r;
        rgb = mix(original, rgb, maskVal);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script> <script>const APP_VERSION="22.1",state={gl:null,canvas:null,programs:{},textures:{},fbos:{},pingPong:[null,null],thumbnailFBO:null,baseImage:null,imageFiles:[],currentImageIndex:0,isMultiImageMode:!1,isExporting:!1,playInterval:null,isPlaying:!1,lastFrameTime:0,realtimeFps:0,frameRenderCount:0,width:1,height:1,renderWidth:1,renderHeight:1,fboWidth:0,fboHeight:0,busy:!1,upscaleFactor:1,renderOrder:["noise","adjust","hdr","ca","blur","airyBloom","glareRays","hankelBlur","vignette","cell","halftone","bilateral","denoise","dither","palette","edge","corruption","analogVideo","lensDistort","heatwave","lightLeaks","compression"],activeLayerPreview:null,activeSection:"adjust",caCenter:{x:.5,y:.5},isDraggingPin:!1,layerTextures:{},layerVisibility:{noise:!0,adjust:!0,hdr:!0,ca:!0,blur:!0,airyBloom:!0,glareRays:!0,hankelBlur:!0,vignette:!0,cell:!0,halftone:!0,bilateral:!0,denoise:!0,dither:!0,palette:!0,edge:!0,corruption:!0,analogVideo:!0,lensDistort:!0,heatwave:!0,lightLeaks:!0,compression:!0},palette:[],lastExtractionImage:null,pinIdleTimer:null,isPreviewLocked:!1,clampPreview:!0,isZoomLocked:!1,lastMousePos:{x:0,y:0},isZooming:!1,isLensMode:!1,keepFolderStructure:!1,allFiles:[]},UI={},LAYERS={noise:{name:"Noise Group",color:"#fff"},adjust:{name:"Adjustments",color:"#fff"},hdr:{name:"HDR Emulation",color:"#fff"},ca:{name:"Chromatic Aberration",color:"#fff"},blur:{name:"Blur",color:"#fff"},cell:{name:"Cell Shading",color:"#fff"},halftone:{name:"Halftoning",color:"#fff"},bilateral:{name:"Bilateral Filter",color:"#fff"},denoise:{name:"Denoising",color:"#fff"},dither:{name:"Dithering",color:"#fff"},palette:{name:"Palette Reconstructor",color:"#fff"},edge:{name:"Edge Effects",color:"#fff"},corruption:{name:"Corruption",color:"#fff"},compression:{name:"Compression",color:"#fff"},airyBloom:{name:"Airy Disk Bloom",color:"#fff"},glareRays:{name:"Glare Rays",color:"#fff"},hankelBlur:{name:"Radial Hankel Blur",color:"#fff"},vignette:{name:"Vignette & Focus",color:"#fff"},analogVideo:{name:"Analog Video (VHS/CRT)",color:"#fff"},lensDistort:{name:"Lens Distortion (Optics)",color:"#fff"},heatwave:{name:"Heatwave & Ripples",color:"#fff"},lightLeaks:{name:"Light Leaks",color:"#fff"},shadows:{name:"Shadows Mask",color:"#fff"},highlights:{name:"Highlights Mask",color:"#fff"}};function downloadPreset(){const e={metadata:{version:"22.1",timestamp:(new Date).toISOString(),source:"Noise Studio"},values:{},checks:{},selects:{},renderOrder:state.renderOrder,layerVisibility:state.layerVisibility,upscaleFactor:state.upscaleFactor,caCenter:state.caCenter,palette:state.palette,imageData:null};document.querySelectorAll("input[type=range]").forEach((t=>e.values[t.id]=t.value)),document.querySelectorAll("input[type=checkbox]").forEach((t=>{t.id.startsWith("drag-")||"jsonIncludeImage"===t.id||"previewLock"===t.id||(e.checks[t.id]=t.checked)})),document.querySelectorAll("select").forEach((t=>{"jsonImportMode"!==t.id&&(e.selects[t.id]=t.value)}));const t=UI.jsonIncludeImage?.checked;if(state.baseImage&&t)try{const t=document.createElement("canvas");t.width=state.baseImage.width,t.height=state.baseImage.height,t.getContext("2d").drawImage(state.baseImage,0,0),e.imageData=t.toDataURL("image/png")}catch(e){}let a="grain-settings.json";state.isMultiImageMode&&state.imageFiles[state.currentImageIndex]?a=`${state.imageFiles[state.currentImageIndex].name.replace(/\.[^/.]+$/,"")}-preset.json`:state.baseImage&&state.imageFiles[0]&&(a=`${state.imageFiles[0].name.replace(/\.[^/.]+$/,"")}-preset.json`);const r=new Blob([JSON.stringify(e,null,2)],{type:"application/json"}),o=URL.createObjectURL(r),s=document.createElement("a");s.href=o,s.download=a,s.click(),URL.revokeObjectURL(o)}function uploadPreset(e){const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=t=>{try{const e=JSON.parse(t.target.result);if(!e||"object"!=typeof e)throw new Error("Invalid JSON format.");const a=document.getElementById("jsonImportMode").value,r=("both"===a||"image"===a)&&e.imageData,o="both"===a||"settings"===a;if(r){const t=new Image;t.onload=()=>{loadNewImage(t),o&&restoreSettings(e)},t.onerror=()=>alert("Error loading image data from JSON."),t.src=e.imageData}else o&&restoreSettings(e)}catch(e){alert("Error loading JSON: "+e.message)}e.target.value=""},a.readAsText(t)}function restoreSettings(e){e.metadata&&e.metadata.version,e.values&&Object.keys(e.values).forEach((t=>{const a=document.getElementById(t);a&&(a.value=e.values[t],a.nextElementSibling&&a.nextElementSibling.classList.contains("control-value")&&(a.nextElementSibling.value=e.values[t]),a.dispatchEvent(new Event("input")),a.dispatchEvent(new Event("change")))})),e.checks&&Object.keys(e.checks).forEach((t=>{const a=document.getElementById(t);a&&(a.checked=e.checks[t],a.dispatchEvent(new Event("change")))})),e.selects&&Object.keys(e.selects).forEach((t=>{const a=document.getElementById(t);a&&(a.value=e.selects[t],a.dispatchEvent(new Event("change")))})),e.renderOrder&&(state.renderOrder=e.renderOrder,setupDragLayerList()),e.layerVisibility&&(state.layerVisibility=e.layerVisibility,setupDragLayerList()),e.upscaleFactor&&(state.upscaleFactor=e.upscaleFactor,UI.upscaleInput&&(UI.upscaleInput.value=e.upscaleFactor)),e.caCenter&&(state.caCenter=e.caCenter,updatePinPosition()),e.palette&&(state.palette=e.palette,updatePaletteUI()),requestRender()}async function loadFolder(){try{const e=await window.showDirectoryPicker(),t=[],a=[];UI.loading.textContent="SCANNING FOLDER...",UI.loading.style.display="block",await async function e(r,o=""){for await(const s of r.values())if("file"===s.kind){const e=await s.getFile();e.relativePath=o,a.push(e),e.type.startsWith("image/")&&t.push(e)}else"directory"===s.kind&&await e(s,o+s.name+"/")}(e),UI.loading.style.display="none",t.length>0?(state.imageFiles=t.sort(((e,t)=>e.name.localeCompare(t.name,void 0,{numeric:!0}))),state.allFiles=a,state.isMultiImageMode=!0,state.currentImageIndex=0,await loadImageFromFile(state.imageFiles[0]),updateUIMode()):alert("No images found in the selected folder.")}catch(e){UI.loading.style.display="none","AbortError"!==e.name&&alert("Could not load folder. Please ensure your browser supports the File System Access API and you have granted permission.")}}async function changeImage(e){if(!state.isMultiImageMode||0===state.imageFiles.length)return;let t=state.currentImageIndex+e;t<0||t>=state.imageFiles.length||(state.currentImageIndex=t,await loadImageFromFile(state.imageFiles[state.currentImageIndex]),updateUIMode())}async function loadImageFromFile(e){return new Promise(((t,a)=>{const r=new Image,o=URL.createObjectURL(e);r.src=o,r.onload=()=>{loadNewImage(r),URL.revokeObjectURL(o),t()},r.onerror=e=>{URL.revokeObjectURL(o),a(e)}}))}function updateUIMode(){const e=document.getElementById("image-navigation"),t=UI.imageScrubber;state.isMultiImageMode&&state.imageFiles.length>1?(e.style.display="flex",UI.imageCounter.textContent=`Image ${state.currentImageIndex+1} of ${state.imageFiles.length}`,UI.downloadBtn.textContent=`DOWNLOAD ALL (${state.imageFiles.length})`,t.max=state.imageFiles.length-1,t.value=state.currentImageIndex,UI.downloadCurrentBtn&&(UI.downloadCurrentBtn.style.display="block")):(e.style.display="none",UI.downloadBtn.textContent="DOWNLOAD FULL RES",UI.downloadCurrentBtn&&(UI.downloadCurrentBtn.style.display="none")),state.imageFiles.length>1&&(UI.prevImageBtn.disabled=0===state.currentImageIndex,UI.nextImageBtn.disabled=state.currentImageIndex===state.imageFiles.length-1)}async function downloadSingleImage(){UI.loading.textContent="PROCESSING GPU...",UI.loading.style.display="block",await new Promise((e=>setTimeout(e,50))),reallocateBuffers(!0),renderFrame(!0);const e=document.createElement("a"),t=state.isMultiImageMode?state.imageFiles[state.currentImageIndex].name.split(".")[0]:"grain-export";e.download=`${t}-processed.png`,e.href=state.canvas.toDataURL("image/png",1),e.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function downloadAllImages(){let e;try{e=await window.showDirectoryPicker()}catch(e){if("AbortError"===e.name)return;return void alert("Could not open directory. Permission denied.")}state.isExporting=!0;const t=UI["export-overlay"];t.style.display="flex";const a=()=>{state.isExporting=!1};UI.stopExportBtn.addEventListener("click",a);const r=state.currentImageIndex,o=state.keepFolderStructure?state.allFiles:state.imageFiles;try{for(let t=0;t<o.length;t++){if(!state.isExporting){alert("Export cancelled.");break}const a=o[t];UI["export-status"].textContent=`EXPORTING ${t+1}/${o.length}...`;try{let r=e;if(state.keepFolderStructure&&a.relativePath){const e=a.relativePath.split("/").filter((e=>""!==e));for(const t of e)r=await r.getDirectoryHandle(t,{create:!0})}if(state.imageFiles.includes(a)){await loadImageFromFile(a),reallocateBuffers(!0),renderFrame(!0);const e=await new Promise((e=>state.canvas.toBlob(e,"image/png"))),o=state.keepFolderStructure?a.name:`${t+1}.png`,s=await r.getFileHandle(o,{create:!0}),n=await s.createWritable();await n.write(e),await n.close()}else if(state.keepFolderStructure){const e=await r.getFileHandle(a.name,{create:!0}),t=await e.createWritable();await t.write(a),await t.close()}}catch(e){}await new Promise((e=>setTimeout(e,10)))}state.isExporting&&alert(`Export Complete. Processed ${state.imageFiles.length} images and copied ${state.allFiles.length-state.imageFiles.length} other files.`)}finally{state.isExporting=!1,t.style.display="none",UI.stopExportBtn.removeEventListener("click",a),await loadImageFromFile(state.imageFiles[r]),state.currentImageIndex=r,updateUIMode(),reallocateBuffers(!1),requestRender()}}function setupDragLayerList(){const e=document.getElementById("layer-drag-list");e.innerHTML="";const t=Object.keys(LAYERS).filter((e=>"shadows"!==e&&"highlights"!==e));t.forEach((e=>{state.renderOrder.includes(e)||(state.renderOrder.push(e),void 0===state.layerVisibility[e]&&(state.layerVisibility[e]=!0))})),state.renderOrder=state.renderOrder.filter((e=>t.includes(e))),state.renderOrder.forEach(((t,a)=>{const r=document.createElement("div");r.className="drag-layer",r.draggable=!0,r.dataset.key=t;const o=state.layerVisibility[t]?"checked":"";r.innerHTML=`\n            <div style="display:flex; align-items:center;">\n                <span class="drag-handle">‚ò∞</span> \n                <input type="checkbox" class="drag-toggle" data-key="${t}" ${o}>\n            </div>\n            <span>${LAYERS[t].name}</span>\n        `,r.querySelector("input").addEventListener("change",(e=>{state.layerVisibility[t]=e.target.checked,requestRender()})),r.addEventListener("dragstart",(e=>{e.dataTransfer.setData("text/plain",a),r.classList.add("dragging")})),r.addEventListener("dragend",(()=>r.classList.remove("dragging"))),r.addEventListener("dragover",(e=>e.preventDefault())),r.addEventListener("drop",(e=>{e.preventDefault();const t=parseInt(e.dataTransfer.getData("text/plain")),r=a;if(t===r)return;const o=state.renderOrder.splice(t,1)[0];state.renderOrder.splice(r,0,o),setupDragLayerList(),setupLayerGridDOM(),requestRender()})),e.appendChild(r)}))}window.addEventListener("DOMContentLoaded",(async()=>{document.querySelectorAll("input, select, button, canvas").forEach((e=>{e.id&&(UI[e.id]=e)})),UI.layerGrid=document.getElementById("layerGrid"),UI.previewContainer=document.getElementById("previewContainer"),UI.overlayOriginal=document.getElementById("overlayOriginal"),UI.loading=document.getElementById("loading"),UI.hoverZoomValue=document.getElementById("hoverZoomValue"),UI.hoverZoomSlider=document.getElementById("hoverZoomSlider"),UI.zoomResIndicator=document.getElementById("zoomResIndicator"),UI.loadFolderBtn=document.getElementById("loadFolderBtn"),UI.prevImageBtn=document.getElementById("prevImageBtn"),UI.nextImageBtn=document.getElementById("nextImageBtn"),UI.imageCounter=document.getElementById("imageCounter"),UI.imageScrubber=document.getElementById("imageScrubber"),UI.playBtn=document.getElementById("playBtn"),UI.playFps=document.getElementById("playFps"),UI.actualFps=document.getElementById("actualFps"),UI["export-overlay"]=document.getElementById("export-overlay"),UI["export-status"]=document.getElementById("export-status"),UI.stopExportBtn=document.getElementById("stopExportBtn"),UI.caPin=document.getElementById("caPin"),UI.previewLock=document.getElementById("previewLock"),UI.resetCenterBtn=document.getElementById("resetCenterBtn"),UI.upscaleInput=document.getElementById("upscaleInput"),UI.clampPreviewToggle=document.getElementById("clampPreviewToggle"),UI.gpuMaxRes=document.getElementById("gpuMaxRes"),UI.exportInfo=document.getElementById("exportInfo"),UI.zoomLens=document.getElementById("zoomLens"),UI.lensToggleBtn=document.getElementById("lensToggleBtn"),UI.lensCanvas=document.getElementById("lensCanvas"),UI.histogramCanvas=document.getElementById("histogramCanvas"),UI.avgBrightnessVal=document.getElementById("avgBrightnessVal"),UI.renderResVal=document.getElementById("renderResVal"),UI.vectorscopeCanvas=document.getElementById("vectorscopeCanvas"),UI.avgSaturationVal=document.getElementById("avgSaturationVal"),["blurEnable","blurAmount","blurType","blurColorExclude","blurTargetColor","blurColorTolerance","blurColorFade","blurLumaMask","blurShadowThreshold","blurShadowFade","blurHighlightThreshold","blurHighlightFade","ditherEnable","ditherBitDepth","ditherPaletteSize","ditherStrength","ditherScale","ditherType","ditherUsePalette","ditherGamma","ditherColorExclude","ditherExcludeColor","ditherColorTolerance","ditherColorFade","ditherLumaMask","ditherShadowThreshold","ditherShadowFade","ditherHighlightThreshold","ditherHighlightFade","paletteEnable","paletteBlend","paletteSmoothing","paletteSmoothingType","paletteList","extractCount","edgeEnable","edgeBlend","edgeMode","edgeStrength","edgeTolerance","edgeFgSat","edgeBgSat","edgeBloom","edgeSmooth","edgeSatControls","denoiseEnable","denoiseMode","denoiseSearchRadius","denoisePatchRadius","denoiseH","denoiseBlend","denoiseColorExclude","denoiseExcludeColor","denoiseColorTolerance","denoiseColorFade","denoiseLumaMask","denoiseShadowThreshold","denoiseShadowFade","denoiseHighlightThreshold","denoiseHighlightFade","denoiseInvertMask","airyBloomEnable","airyBloomIntensity","airyBloomAperture","airyBloomThreshold","airyBloomThresholdFade","airyBloomCutoff","airyBloomColorExclude","airyBloomExcludeColor","airyBloomColorTolerance","airyBloomColorFade","airyBloomLumaMask","airyBloomShadowThreshold","airyBloomShadowFade","airyBloomHighlightThreshold","airyBloomHighlightFade","airyBloomInvertMask","hankelBlurEnable","hankelBlurIntensity","hankelBlurRadius","hankelBlurQuality","hankelColorExclude","hankelExcludeColor","hankelColorTolerance","hankelColorFade","hankelLumaMask","hankelShadowThreshold","hankelShadowFade","hankelHighlightThreshold","hankelHighlightFade","hankelInvertMask","compressionEnable","compressionMethod","compressionQuality","compressionBlockSize","compressionBlend","compressionIterations"].forEach((e=>{const t=document.getElementById(e);t&&(UI[e]=t)})),document.querySelectorAll(".tab-btn").forEach((e=>{e.addEventListener("click",(e=>{document.querySelectorAll(".tab-btn").forEach((e=>e.classList.remove("active"))),document.querySelectorAll(".tab-content").forEach((e=>e.classList.remove("active"))),e.target.classList.add("active"),document.getElementById(e.target.dataset.tab).classList.add("active")}))})),document.querySelectorAll("#tab-controls details").forEach((e=>{e.addEventListener("toggle",(t=>{if(e.open){const t=e.querySelector("input, select");if(t){const e=getSectionFromId(t.id);e&&(state.activeSection=e,requestRender())}}}))})),setupDragLayerList(),document.querySelectorAll("input[type=range]").forEach((e=>{const t=e.nextElementSibling;if(t&&t.classList.contains("control-value")){const a=()=>t.value=e.value;e.addEventListener("input",(()=>{a(),requestRender()})),a()}})),UI.hoverZoomValue&&UI.hoverZoomValue.addEventListener("input",(e=>{const t=parseFloat(e.target.value);isNaN(t)||(state.zoomLevel=t),requestRender()})),document.querySelectorAll("select, input[type=checkbox], input[type=color]").forEach((e=>{e.addEventListener("change",(()=>{"clampPreviewToggle"===e.id&&(state.clampPreview=!e.checked,reallocateBuffers(state.isZooming)),requestRender()})),e.addEventListener("input",requestRender)})),UI.edgeMode.addEventListener("change",(()=>{UI.edgeSatControls.style.display="1"===UI.edgeMode.value?"block":"none"})),UI.edgeMode.dispatchEvent(new Event("change"));const e=()=>"#"+Math.floor(16777215*Math.random()).toString(16).padStart(6,"0");UI.addPaletteColor.addEventListener("click",(()=>{state.palette.push(e()),updatePaletteUI(),requestRender()}));const t=document.createElement("input");let a;t.id="pickPaletteColor",t.type="color",t.style.display="none",document.body.appendChild(t),UI.pickPaletteColorInput=t,t.addEventListener("change",(e=>{state.palette.push(e.target.value),updatePaletteUI(),requestRender()})),UI.clearPalette.addEventListener("click",(()=>{state.palette=[],updatePaletteUI(),requestRender()})),UI.randomPalette.addEventListener("click",(()=>{const t=state.palette.length;if(0===t){const t=Math.floor(5*Math.random())+3,a=new Set;for(;a.size<t;)a.add(e());state.palette=Array.from(a)}else for(let a=0;a<t;a++)state.palette[a]=e();updatePaletteUI(),requestRender()})),UI.extractPalette.addEventListener("click",(()=>UI.paletteImageUpload.click())),UI.paletteImageUpload.addEventListener("change",(e=>{const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=e=>{const t=new Image;t.onload=()=>{state.lastExtractionImage=t;const e=parseInt(UI.extractCount?.value||8);extractPaletteFromImage(t,e)},t.src=e.target.result},a.readAsDataURL(t)})),UI.extractCount.addEventListener("input",(()=>{if(state.lastExtractionImage){const e=parseInt(UI.extractCount.value);extractPaletteFromImage(state.lastExtractionImage,e)}})),UI.previewLock.addEventListener("change",(e=>{state.isPreviewLocked=e.target.checked,state.isPreviewLocked&&UI.overlayOriginal.classList.remove("show")})),UI.upscaleInput.addEventListener("change",(e=>{let t=parseInt(e.target.value);(isNaN(t)||t<1)&&(t=1),t>10&&(t=10),e.target.value=t,state.upscaleFactor=t,state.baseImage&&(reallocateBuffers(!1),requestRender())})),UI.resetCenterBtn.addEventListener("click",(()=>{state.caCenter={x:.5,y:.5},updatePinPosition(),requestRender()})),UI.caPin.addEventListener("mousedown",(e=>{state.isDraggingPin=!0,state.isPreviewLocked||UI.overlayOriginal.classList.remove("show"),clearTimeout(state.pinIdleTimer),e.preventDefault()})),window.addEventListener("mouseup",(()=>{state.isDraggingPin&&(state.isDraggingPin=!1,state.isPreviewLocked||(state.pinIdleTimer=setTimeout((()=>{UI.overlayOriginal.classList.add("show")}),4e3)))})),window.addEventListener("mousemove",(e=>{if(!state.isDraggingPin)return;const t=UI.previewContainer.getBoundingClientRect();let a=(e.clientX-t.left)/t.width,r=1-(e.clientY-t.top)/t.height;a=Math.max(0,Math.min(1,a)),r=Math.max(0,Math.min(1,r)),state.caCenter={x:a,y:r},updatePinPosition(),requestRender()}));const r=UI.previewContainer,o=UI.displayCanvas;UI.lensToggleBtn.addEventListener("click",(()=>{state.isLensMode=!state.isLensMode,UI.lensToggleBtn.textContent=state.isLensMode?"LENS":"FULL",UI.lensToggleBtn.style.background=state.isLensMode?"var(--accent)":"",UI.lensToggleBtn.style.color=state.isLensMode?"#000":"",i()}));const s=180;UI.lensCanvas.width=s,UI.lensCanvas.height=s;const n=UI.lensCanvas.getContext("2d"),i=(e=!1)=>{state.isZoomLocked&&!e||(o.style.transform="",o.style.transformOrigin="",o.style.zIndex="",UI.zoomResIndicator.style.display="none",UI.zoomLens&&(UI.zoomLens.style.display="none"),state.isZooming&&(state.isZooming=!1,state.clampPreview&&(reallocateBuffers(!1),requestRender())))},l=e=>{const t=(e=>{let t=parseFloat(e);return isNaN(t)?1:t})(UI.hoverZoomSlider.value);if(t<=1)return void i();UI.overlayOriginal.classList.remove("show"),state.isZooming||(state.isZooming=!0,reallocateBuffers(!0),requestRender());const a=r.getBoundingClientRect();!state.isZoomLocked&&e&&(state.lastMousePos={x:e.clientX,y:e.clientY});const l=state.lastMousePos.x-a.left,u=state.lastMousePos.y-a.top;if(a.width,a.height,state.isLensMode){o.style.transform="",o.style.transformOrigin="",o.style.zIndex="",UI.zoomLens&&(UI.zoomLens.style.display="block",UI.zoomLens.style.left=l-90+"px",UI.zoomLens.style.top=u-90+"px");const e=o.width/o.height;let r,i,m,c;e>a.width/a.height?(r=a.width,i=a.width/e,m=0,c=(a.height-i)/2):(i=a.height,r=a.height*e,m=(a.width-r)/2,c=0);const d=(l-m)/r*o.width,g=(u-c)/i*o.height,f=s/t,p=d-f/2,h=g-f/2;n&&(n.clearRect(0,0,s,s),n.drawImage(o,Math.max(0,Math.min(p,o.width-f)),Math.max(0,Math.min(h,o.height-f)),f,f,0,0,s,s))}else{UI.zoomLens&&(UI.zoomLens.style.display="none"),o.style.zIndex="15";const e=o.width/o.height,r=a.width/a.height;let s=0,n=0,i=a.width,m=a.height;e>r?(m=a.width/e,n=(a.height-m)/2):(i=a.height*e,s=(a.width-i)/2);const c=(l-s)/i,d=(u-n)/m;o.style.transformOrigin=`${100*c}% ${100*d}%`,o.style.transform=`scale(${t})`}const m=state.width*state.upscaleFactor,c=state.height*state.upscaleFactor,d=o.width,g=o.height,f=d>=m&&g>=c?"‚úì FULL RES":"‚ö† SCALED",p=state.isLensMode?"LENS":"FULL";UI.zoomResIndicator.innerHTML=`Mode: ${p}<br>Source: ${m}√ó${c}<br>Canvas: ${d}√ó${g}<br>${f}`,UI.zoomResIndicator.style.display="block",UI.zoomResIndicator.style.color=d>=m&&g>=c?"#0f0":"#f80",UI.zoomResIndicator.style.borderColor=d>=m&&g>=c?"#0f0":"#f80"};r.addEventListener("mouseenter",(e=>{parseFloat(UI.hoverZoomSlider.value)<=1&&!state.isPreviewLocked&&!state.activeLayerPreview&&UI.overlayOriginal.classList.add("show"),clearTimeout(a),l(e)})),r.addEventListener("mouseleave",(e=>{UI.overlayOriginal.classList.remove("show"),clearTimeout(a),state.isZoomLocked||i()})),r.addEventListener("wheel",(e=>{if(e.ctrlKey||e.metaKey){e.preventDefault();const t=UI.blendMode,a=t.options.length;let r=t.selectedIndex;r=(r+Math.sign(e.deltaY)+a)%a,t.selectedIndex=r,requestRender()}else{e.preventDefault();let t=parseFloat(UI.hoverZoomSlider.value);t+=.5*-Math.sign(e.deltaY),t=Math.max(1,Math.min(8,t)),UI.hoverZoomSlider.value=t,UI.hoverZoomSlider.dispatchEvent(new Event("input")),l(e)}}),{passive:!1}),r.addEventListener("mousemove",(e=>{clearTimeout(a);const t=parseFloat(UI.hoverZoomSlider.value);!state.isPreviewLocked&&!state.activeLayerPreview&&t<=1&&UI.overlayOriginal.classList.add("show"),l(e)})),window.addEventListener("keydown",(e=>{if("Tab"===e.key){const t=UI.previewContainer.matches(":hover");(t||state.isZoomLocked)&&(e.preventDefault(),state.isZoomLocked=!state.isZoomLocked,state.isZoomLocked||t?state.isZoomLocked&&l():i(!0))}})),UI.downloadJsonBtn.addEventListener("click",downloadPreset),UI.uploadJsonTrigger.addEventListener("click",(()=>UI.jsonUpload.click())),UI.jsonUpload.addEventListener("change",uploadPreset),initWebGL(),UI.imageUpload.addEventListener("change",(e=>{const t=e.target.files[0];t&&(state.isMultiImageMode=!1,state.imageFiles=[t],state.currentImageIndex=0,loadImageFromFile(t).then(updateUIMode))})),UI.loadFolderBtn.addEventListener("click",loadFolder),UI.prevImageBtn.addEventListener("click",(()=>changeImage(-1))),UI.nextImageBtn.addEventListener("click",(()=>changeImage(1))),UI.imageScrubber.addEventListener("input",(e=>{const t=parseInt(e.target.value,10);t!==state.currentImageIndex&&(state.currentImageIndex=t,requestAnimationFrame((()=>{loadImageFromFile(state.imageFiles[state.currentImageIndex]).then(updateUIMode)})))})),UI.playBtn.addEventListener("click",(()=>{state.isPlaying?(state.playInterval&&(clearInterval(state.playInterval),state.playInterval=null),state.isPlaying=!1,UI.playBtn.textContent="PLAY ‚ñ∫"):(()=>{state.playInterval&&clearInterval(state.playInterval),state.isPlaying=!0,UI.playBtn.textContent="STOP ‚ñ†";const e=parseInt(UI.playFps.value,10)||10;state.playInterval=setInterval((()=>{let e=(state.currentImageIndex+1)%state.imageFiles.length;state.currentImageIndex=e,loadImageFromFile(state.imageFiles[state.currentImageIndex]),updateUIMode()}),1e3/e)})()})),UI.keepFolderStructureToggle.addEventListener("change",(e=>{state.keepFolderStructure=e.target.checked})),UI.downloadBtn.addEventListener("click",(()=>{state.isMultiImageMode&&state.imageFiles.length>1?downloadAllImages():downloadSingleImage()})),UI.downloadCurrentBtn=document.getElementById("downloadCurrentBtn"),UI.compareBtn.addEventListener("click",openCompare),UI.downloadCurrentBtn.addEventListener("click",downloadSingleImage),UI.closeCompare.addEventListener("click",(()=>document.getElementById("compareModal").classList.remove("show"))),UI.exportSideBySide.addEventListener("click",(()=>exportComparison("side"))),UI.exportStacked.addEventListener("click",(()=>exportComparison("stack"))),UI.noiseType.addEventListener("change",syncNoiseUI),syncNoiseUI();const u=document.createElement("style");u.textContent="\n                .eyedropper-btn { background: none; border: none; cursor: pointer; font-size: 1.2em; padding: 0 5px; opacity: 0.7; transition: opacity 0.2s; }\n                .eyedropper-btn:hover { opacity: 1; }\n                .eyedropper-active { cursor: crosshair !important; }\n            ",document.head.appendChild(u);let m=null;document.querySelectorAll(".eyedropper-btn").forEach((e=>{e.addEventListener("click",(e=>{const t=e.target.dataset.target;m===t?(m=null,UI.displayCanvas.classList.remove("eyedropper-active")):(m=t,UI.displayCanvas.classList.add("eyedropper-active")),e.stopPropagation()}))})),UI.displayCanvas.addEventListener("click",(e=>{if(!m)return;const t=UI.displayCanvas.getBoundingClientRect(),a=e.clientX-t.left,r=e.clientY-t.top,o=state.gl,s=UI.displayCanvas,n=(s.width,s.height,state.width/state.height);let i,l,u,c;if(n>t.width/t.height?(i=t.width,l=t.width/n,u=0,c=(t.height-l)/2):(l=t.height,i=t.height*n,u=(t.width-i)/2,c=0),a<u||a>u+i||r<c||r>c+l)return;const d=(a-u)/i,g=(r-c)/l,f=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,f),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,state.textures.base,0);const p=Math.floor(d*state.width),h=Math.floor((1-g)*state.height),U=new Uint8Array(4);o.readPixels(p,h,1,1,o.RGBA,o.UNSIGNED_BYTE,U),o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(f);const E="#"+((1<<24)+(U[0]<<16)+(U[1]<<8)+U[2]).toString(16).slice(1),T=document.getElementById(m);T&&(T.value=E,T.dispatchEvent(new Event("input")),T.dispatchEvent(new Event("change"))),m=null,UI.displayCanvas.classList.remove("eyedropper-active")})),window.addEventListener("keydown",(e=>{"Escape"===e.key&&m&&(m=null,UI.displayCanvas.classList.remove("eyedropper-active"))}))}));let renderRequested=!1;function requestRender(){!renderRequested&&state.baseImage&&(renderRequested=!0,requestAnimationFrame((()=>{renderFrame(),renderRequested=!1})))}function updateHistogram(){if(!state.gl||!state.baseImage||!UI.histogramCanvas)return;const e=state.gl,t=state.analysisFBO.w,a=state.analysisFBO.h,r=t*a,o=Math.max(1,Math.floor(r/1e4));e.bindFramebuffer(e.FRAMEBUFFER,state.analysisFBO.fbo);const s=new Uint8Array(t*a*4);e.readPixels(0,0,t,a,e.RGBA,e.UNSIGNED_BYTE,s);const n=new Uint32Array(256);let i=0,l=0;const u=4*o;for(let e=0;e<s.length;e+=u){const t=Math.round(.2126*s[e]+.7152*s[e+1]+.0722*s[e+2]);n[t]++,i+=t,l++}const m=l>0?i/l:0;UI.avgBrightnessVal&&(UI.avgBrightnessVal.textContent=(m/2.55).toFixed(1)+"%"),UI.renderResVal&&(UI.renderResVal.textContent=`${state.renderWidth}x${state.renderHeight}`);const c=UI.histogramCanvas.getContext("2d"),d=UI.histogramCanvas.width,g=UI.histogramCanvas.height;c.clearRect(0,0,d,g);let f=0;for(let e=0;e<256;e++)n[e]>f&&(f=n[e]);c.fillStyle="#2a9df4",c.beginPath(),c.moveTo(0,g);for(let e=0;e<256;e++){const t=e/255*d,a=n[e]/f*g;c.lineTo(t,g-a)}c.lineTo(d,g),c.fill(),c.strokeStyle="rgba(255,255,255,0.1)",c.beginPath(),c.moveTo(d/2,0),c.lineTo(d/2,g),c.stroke()}function updateVectorscope(){if(!state.gl||!state.baseImage||!UI.vectorscopeCanvas)return;const e=state.gl,t=state.analysisFBO.w,a=state.analysisFBO.h,r=t*a,o=4*Math.max(1,Math.floor(r/1e4));e.bindFramebuffer(e.FRAMEBUFFER,state.analysisFBO.fbo);const s=new Uint8Array(t*a*4);e.readPixels(0,0,t,a,e.RGBA,e.UNSIGNED_BYTE,s);const n=UI.vectorscopeCanvas.getContext("2d"),i=UI.vectorscopeCanvas.width,l=i/2,u=i/2,m=i/2-5;n.clearRect(0,0,i,i);let c=0,d=0;for(let e=0;e<s.length;e+=o){const t=s[e]/255,a=s[e+1]/255,r=s[e+2]/255,o=Math.max(t,a,r),i=o-Math.min(t,a,r);let g=0,f=0;if(o>0&&(f=i/o),i>0)switch(o){case t:g=((a-r)/i+(a<r?6:0))/6;break;case a:g=((r-t)/i+2)/6;break;case r:g=((t-a)/i+4)/6}if(c+=f,d++,f<.02)continue;const p=g*Math.PI*2-Math.PI/2,h=f*m,U=l+Math.cos(p)*h,E=u+Math.sin(p)*h;n.fillStyle=`rgba(${Math.round(255*t)}, ${Math.round(255*a)}, ${Math.round(255*r)}, 0.4)`,n.fillRect(U-1,E-1,2,2)}n.strokeStyle="rgba(255,255,255,0.2)",n.lineWidth=1,n.beginPath(),n.arc(l,u,m,0,2*Math.PI),n.stroke(),n.beginPath(),n.arc(l,u,.5*m,0,2*Math.PI),n.stroke(),n.beginPath(),n.arc(l,u,.25*m,0,2*Math.PI),n.stroke(),n.beginPath(),n.moveTo(l,0),n.lineTo(l,i),n.moveTo(0,u),n.lineTo(i,u),n.stroke();const g=d>0?c/d*100:0;UI.avgSaturationVal&&(UI.avgSaturationVal.textContent=g.toFixed(1)+"%")}function initWebGL(){state.canvas=UI.displayCanvas;const e=state.canvas.getContext("webgl2",{antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!0});if(!e)return void alert("WebGL2 not supported.");state.canvas.addEventListener("webglcontextlost",(e=>{e.preventDefault(),document.getElementById("loading").textContent="ERROR: GPU CRASHED. Reload page.",document.getElementById("loading").style.display="block",document.getElementById("loading").style.backgroundColor="red",state.isPlaying=!1,state.playInterval&&clearInterval(state.playInterval)}),!1),state.canvas.addEventListener("webglcontextrestored",(()=>{initWebGL(),state.baseImage&&(reallocateBuffers(!1),requestRender()),document.getElementById("loading").style.display="none",document.getElementById("loading").style.backgroundColor="var(--accent)",document.getElementById("loading").textContent="PROCESSING GPU..."}),!1),e.getExtension("EXT_color_buffer_float"),e.getExtension("OES_texture_float_linear"),state.gl=e,e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),state.programs={adjust:createProgram(e,"vs-quad","fs-adjust"),adjustMasked:createProgram(e,"vs-quad","fs-adjustMasked"),mask:createProgram(e,"vs-quad","fs-mask"),colorMask:createProgram(e,"vs-quad","fs-colorMask"),noise:createProgram(e,"vs-quad","fs-noise"),blur:createProgram(e,"vs-quad","fs-blur"),maskedBlur:createProgram(e,"vs-quad","fs-maskedBlur"),composite:createProgram(e,"vs-quad","fs-composite"),chroma:createProgram(e,"vs-quad","fs-chroma"),copy:createProgram(e,"vs-quad","fs-copy"),dither:createProgram(e,"vs-quad","fs-dither"),maskedDither:createProgram(e,"vs-quad","fs-maskedDither"),corruption:createProgram(e,"vs-quad","fs-corruption"),compression:createProgram(e,"vs-quad","fs-compression"),cell:createProgram(e,"vs-quad","fs-cell"),halftone:createProgram(e,"vs-quad","fs-halftone"),bilateral:createProgram(e,"vs-quad","fs-bilateral"),denoise:createProgram(e,"vs-quad","fs-denoise"),palette:createProgram(e,"vs-quad","fs-palette"),edge:createProgram(e,"vs-quad","fs-edge"),airyBloom:createProgram(e,"vs-quad","fs-airyBloom"),glareRays:createProgram(e,"vs-quad","fs-glareRays"),hankelBlur:createProgram(e,"vs-quad","fs-hankelBlur"),vignette:createProgram(e,"vs-quad","fs-vignette"),analogVideo:createProgram(e,"vs-quad","fs-analog"),lensDistort:createProgram(e,"vs-quad","fs-lens"),heatwave:createProgram(e,"vs-quad","fs-heatwave"),lightLeaks:createProgram(e,"vs-quad","fs-lightleaks"),invert:createProgram(e,"vs-quad","fs-invert"),radial:createProgram(e,"vs-quad","fs-radial"),final:createProgram(e,"vs-quad","fs-final")};const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,-1,1,0,1,1,-1,1,0,1,1,1,1]),e.STATIC_DRAW),Object.values(state.programs).forEach((t=>{e.useProgram(t);const a=e.getAttribLocation(t,"a_pos"),r=e.getAttribLocation(t,"a_uv");e.enableVertexAttribArray(a),e.enableVertexAttribArray(r),e.vertexAttribPointer(a,2,e.FLOAT,!1,16,0),e.vertexAttribPointer(r,2,e.FLOAT,!1,16,8)}));const a=createTexture(e,null,320,180),r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0),state.thumbnailFBO={fbo:r,tex:a,w:320,h:180};const o=createTexture(e,null,256,256),s=e.createFramebuffer();if(e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0),state.analysisFBO={fbo:s,tex:o,w:256,h:256},state.thumbTempCanvas=document.createElement("canvas"),state.thumbTempCanvas.width=320,state.thumbTempCanvas.height=180,state.thumbTempCtx=state.thumbTempCanvas.getContext("2d"),state.thumbPixelBuffer=new Uint8Array(230400),state.thumbClampedBuffer=new Uint8ClampedArray(230400),UI.gpuMaxRes){const t=e.getParameter(e.MAX_TEXTURE_SIZE);UI.gpuMaxRes.textContent=`${t}px`}state.textures.white=createTexture(e,new Uint8Array([255,255,255,255]),1,1),state.textures.black=createTexture(e,new Uint8Array([0,0,0,255]),1,1)}function loadNewImage(e){state.baseImage=e,state.width=e.width,state.height=e.height;const t=state.gl;state.textures.base&&(t.deleteTexture(state.textures.base),state.textures.base=null),state.textures.base=createTexture(t,e),state.fboWidth=0,state.fboHeight=0,reallocateBuffers(!1),UI.downloadBtn.disabled=!1,UI.downloadCurrentBtn.disabled=!1,UI.compareBtn.disabled=!1,UI.overlayCanvas.width=e.width,UI.overlayCanvas.height=e.height,UI.overlayCanvas.getContext("2d").drawImage(e,0,0),UI.caPin.classList.add("active"),setupLayerGridDOM(),requestRender()}function reallocateBuffers(e=!1){const t=state.gl,a=t.getParameter(t.MAX_TEXTURE_SIZE);let r,o;if(e){let e=state.width*state.upscaleFactor,t=state.height*state.upscaleFactor,s=1;(e>a||t>a)&&(s=Math.min(a/e,a/t)),r=Math.round(state.width*state.upscaleFactor*s),o=Math.round(state.height*state.upscaleFactor*s),state._exportScale=s}else{const e=state.clampPreview?2048:a;let t=state.width*state.upscaleFactor,s=state.height*state.upscaleFactor,n=1;if((t>e||s>e)&&(n=Math.min(e/t,e/s)),r=Math.round(t*n),o=Math.round(s*n),r>a||o>a){const e=Math.min(a/r,a/o);r=Math.floor(r*e),o=Math.floor(o*e)}state._exportScale=n}if(state.renderWidth=r,state.renderHeight=o,state.fboWidth===r&&state.fboHeight===o)return{w:r,h:o};state.fboWidth=r,state.fboHeight=o;const s=(e=!0)=>{const a=createTexture(t,null,r,o,e),s=t.createFramebuffer();return t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,a,0),{tex:a,fbo:s}};state.pingPong[0]?.tex&&(t.deleteTexture(state.pingPong[0].tex),t.deleteFramebuffer(state.pingPong[0].fbo)),state.pingPong[1]?.tex&&(t.deleteTexture(state.pingPong[1].tex),t.deleteFramebuffer(state.pingPong[1].fbo)),state.pingPong[0]=s(),state.pingPong[1]=s(),["tempNoise","blur1","blur2","preview"].forEach((e=>{state.textures[e]&&t.deleteTexture(state.textures[e]),state.fbos[e]&&t.deleteFramebuffer(state.fbos[e])}));const n=s();state.textures.tempNoise=n.tex,state.fbos.tempNoise=n.fbo;const i=s();state.textures.blur1=i.tex,state.fbos.blur1=i.fbo;const l=s();state.textures.blur2=l.tex,state.fbos.blur2=l.fbo;const u=s();state.textures.preview=u.tex,state.fbos.preview=u.fbo;const m=s();return state.textures.chainCapture=m.tex,state.fbos.chainCapture=m.fbo,{w:r,h:o}}function renderSingleLayer(e,t,a,r,o,s=!1){const n=state.renderWidth,i=state.renderHeight;if(e.viewport(0,0,n,i),"adjust"===t){if(!UI.adjustEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;let t=null;const n=UI.adjLumaMask?.checked,i=UI.adjColorExclude?.checked;if(n||i){if(e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.clearColor(1,1,1,1),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.DST_COLOR,e.ZERO),n&&(e.useProgram(state.programs.mask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useS"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.adjShadowThreshold?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.adjShadowFade?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useH"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.adjHighlightThreshold?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.adjHighlightFade?.value||0)),e.drawArrays(e.TRIANGLES,0,6)),i){const t=UI.adjExcludeColor?.value||"#000000",r=parseInt(t.slice(1,3),16)/255,o=parseInt(t.slice(3,5),16)/255,s=parseInt(t.slice(5,7),16)/255;e.useProgram(state.programs.colorMask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.colorMask,"u_tex"),0),e.uniform3f(e.getUniformLocation(state.programs.colorMask,"u_targetColor"),r,o,s),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI.adjColorTolerance?.value||10)/100),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI.adjColorFade?.value||0)/100),e.drawArrays(e.TRIANGLES,0,6)}e.disable(e.BLEND),t=state.textures.blur1,t&&UI.adjInvertMask?.checked&&(e.useProgram(state.programs.invert),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.invert,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),t=state.textures.blur2)}e.bindFramebuffer(e.FRAMEBUFFER,r);const l=state.programs.adjustMasked||state.programs.adjust;return e.useProgram(l),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(l,"u_tex"),0),e.uniform1f(e.getUniformLocation(l,"u_bright"),o.u_bright),e.uniform1f(e.getUniformLocation(l,"u_cont"),o.u_cont),e.uniform1f(e.getUniformLocation(l,"u_sat"),o.u_sat),e.uniform1f(e.getUniformLocation(l,"u_hdrTol"),0),e.uniform1f(e.getUniformLocation(l,"u_hdrAmt"),0),e.uniform1f(e.getUniformLocation(l,"u_warmth"),o.u_warmth),e.uniform1f(e.getUniformLocation(l,"u_sharp"),o.u_sharp),e.uniform1f(e.getUniformLocation(l,"u_sharpThresh"),o.u_sharpThresh),e.uniform2f(e.getUniformLocation(l,"u_step"),o.u_step[0],o.u_step[1]),t&&l?(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(l,"u_mask"),1),e.uniform1i(e.getUniformLocation(l,"u_useMask"),1)):l&&e.uniform1i(e.getUniformLocation(l,"u_useMask"),0),e.drawArrays(e.TRIANGLES,0,6),r}if("hdr"===t)return UI.hdrEnable?.checked||s?(e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.adjust),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.adjust,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_bright"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_cont"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_sat"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_warmth"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_sharp"),0),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_hdrTol"),o.u_hdrTol),e.uniform1f(e.getUniformLocation(state.programs.adjust,"u_hdrAmt"),o.u_hdrAmt),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1):(e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1);if("noise"===t){if(!UI.noiseEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.useProgram(state.programs.noise),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.tempNoise),e.uniform1i(e.getUniformLocation(state.programs.noise,"u_type"),parseInt(UI.noiseType.value)),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_seed"),100*Math.random()),e.uniform2f(e.getUniformLocation(state.programs.noise,"u_res"),n,i),e.uniform2f(e.getUniformLocation(state.programs.noise,"u_origRes"),state.width*state.upscaleFactor,state.height*state.upscaleFactor),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_scale"),parseFloat(UI.noiseSize.value)),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_paramA"),parseFloat(document.getElementById("noiseParamA").value)/100),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_paramB"),parseFloat(document.getElementById("noiseParamB").value)/100),e.uniform1f(e.getUniformLocation(state.programs.noise,"u_paramC"),parseFloat(document.getElementById("noiseParamC").value)/100),e.drawArrays(e.TRIANGLES,0,6);const t=parseFloat(UI.blurriness.value)/100;let o=state.textures.tempNoise;t>0&&(e.useProgram(state.programs.blur),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.bindTexture(e.TEXTURE_2D,state.textures.tempNoise),e.uniform1i(e.getUniformLocation(state.programs.blur,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.blur,"u_dir"),1/n,0),e.uniform1f(e.getUniformLocation(state.programs.blur,"u_rad"),2*t),e.drawArrays(e.TRIANGLES,0,6),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.bindTexture(e.TEXTURE_2D,state.textures.blur1),e.uniform2f(e.getUniformLocation(state.programs.blur,"u_dir"),0,1/i),e.drawArrays(e.TRIANGLES,0,6),o=state.textures.blur2);const l=renderMaskForLayer(e,a,"noise");e.useProgram(state.programs.composite),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,o),e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,l||state.textures.white),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_base"),0),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_noise"),1),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_mask"),2),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_mode"),parseInt(UI.blendMode.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_opacity"),parseFloat(UI.opacity.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_str"),parseFloat(UI.strength.value)),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_nType"),parseInt(UI.noiseType.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_satStr"),parseFloat(UI.satStrength.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_satImp"),parseFloat(UI.satPerNoise.value)),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_skinProt"),parseFloat(UI.skinProtection.value)),e.uniform1i(e.getUniformLocation(state.programs.composite,"u_ignA"),UI.ignoreAlphaToggle.checked?1:0),e.uniform1f(e.getUniformLocation(state.programs.composite,"u_ignAstr"),parseFloat(UI.ignoreAlphaStrength.value)),e.drawArrays(e.TRIANGLES,0,6)}else if("ca"===t){if(!UI.caEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.chroma),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.chroma,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_amt"),o.u_ca_amt),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_blur"),o.u_ca_blur),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_zoomBlur"),parseFloat(UI.aberrationZoomBlur.value)/50),e.uniform2f(e.getUniformLocation(state.programs.chroma,"u_center"),o.u_ca_center[0],o.u_ca_center[1]),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_radius"),o.u_ca_rad),e.uniform1f(e.getUniformLocation(state.programs.chroma,"u_falloff"),o.u_ca_fall),e.uniform1i(e.getUniformLocation(state.programs.chroma,"u_falloffToBlur"),UI.caFalloffToBlur.checked?1:0),e.drawArrays(e.TRIANGLES,0,6)}else if("blur"===t){if(!UI.blurEnable?.checked)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;const t=renderMaskForLayer(e,a,"blur"),o=parseFloat(UI.blurAmount?.value||0)/100;if(o>0){const s=t?state.programs.maskedBlur:state.programs.blur;e.useProgram(s),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur2),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(s,"u_tex"),0),e.uniform2f(e.getUniformLocation(s,"u_dir"),1/n,0),e.uniform1f(e.getUniformLocation(s,"u_rad"),2*o),e.uniform1i(e.getUniformLocation(s,"u_blurType"),parseInt(UI.blurType?.value||0)),t&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(s,"u_mask"),1)),e.drawArrays(e.TRIANGLES,0,6),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,state.textures.blur2),e.uniform1i(e.getUniformLocation(s,"u_tex"),0),e.uniform2f(e.getUniformLocation(s,"u_dir"),0,1/i),e.uniform1f(e.getUniformLocation(s,"u_rad"),2*o),e.uniform1i(e.getUniformLocation(s,"u_blurType"),parseInt(UI.blurType?.value||0)),t&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(s,"u_mask"),1)),e.drawArrays(e.TRIANGLES,0,6)}else e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6)}else if("cell"===t){if(!UI.cellEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.cell),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.cell,"u_res"),n,i),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_levels"),parseInt(UI.cellLevels?.value||4)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_bias"),parseFloat(UI.cellBias?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_gamma"),parseFloat(UI.cellGamma?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_quantMode"),parseInt(UI.cellQuantMode?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_bandMap"),parseInt(UI.cellBandMap?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_edgeMethod"),parseInt(UI.cellEdgeMethod?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_edgeStr"),parseFloat(UI.cellEdgeStr?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.cell,"u_edgeThick"),parseFloat(UI.cellEdgeThick?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_colorPreserve"),UI.cellColorPreserve?.checked?1:0),e.uniform1i(e.getUniformLocation(state.programs.cell,"u_edgeEnable"),UI.cellEdgeEnable?.checked?1:0),e.drawArrays(e.TRIANGLES,0,6)}else if("halftone"===t){if(!UI.halftoneEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.halftone),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.halftone,"u_res"),n,i),e.uniform1f(e.getUniformLocation(state.programs.halftone,"u_size"),parseFloat(UI.halftoneSize?.value||4)),e.uniform1f(e.getUniformLocation(state.programs.halftone,"u_intensity"),parseFloat(UI.halftoneIntensity?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.halftone,"u_sharpness"),parseFloat(UI.halftoneSharpness?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_pattern"),parseInt(UI.halftonePattern?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_colorMode"),parseInt(UI.halftoneColorMode?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_sample"),parseInt(UI.halftoneSample?.value||1)),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_gray"),UI.halftoneGray?.checked?1:0),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_lock"),UI.halftoneScreenLock?.checked?1:0),e.uniform1i(e.getUniformLocation(state.programs.halftone,"u_invert"),UI.halftoneInvert?.checked?1:0),e.drawArrays(e.TRIANGLES,0,6)}else if("bilateral"===t){if(!UI.bilateralEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;Math.max(1,parseInt(UI.bilateralIter?.value||1)),e.useProgram(state.programs.bilateral),e.uniform2f(e.getUniformLocation(state.programs.bilateral,"u_res"),n,i),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_radius"),parseInt(UI.bilateralRadius?.value||2)),e.uniform1f(e.getUniformLocation(state.programs.bilateral,"u_sigmaCol"),parseFloat(UI.bilateralColorSig?.value||.1)),e.uniform1f(e.getUniformLocation(state.programs.bilateral,"u_sigmaSpace"),parseFloat(UI.bilateralSpatialSig?.value||2)),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_kernel"),parseInt(UI.bilateralKernel?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_edgeMode"),parseInt(UI.bilateralEdgeMode?.value||0)),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.bilateral,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6)}else if("denoise"===t){if(!UI.denoiseEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;const t=renderMaskForLayer(e,a,"denoise"),o=state.programs.denoise;e.useProgram(o),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(o,"u_tex"),0),e.uniform2f(e.getUniformLocation(o,"u_res"),n,i),e.uniform1i(e.getUniformLocation(o,"u_mode"),parseInt(UI.denoiseMode?.value||0)),e.uniform1i(e.getUniformLocation(o,"u_searchRadius"),parseInt(UI.denoiseSearchRadius?.value||5)),e.uniform1i(e.getUniformLocation(o,"u_patchRadius"),parseInt(UI.denoisePatchRadius?.value||2)),e.uniform1f(e.getUniformLocation(o,"u_h"),parseFloat(UI.denoiseH?.value||.5)),e.uniform1f(e.getUniformLocation(o,"u_strength"),parseFloat(UI.denoiseBlend?.value||100)/100),t?(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(o,"u_mask"),1),e.uniform1i(e.getUniformLocation(o,"u_useMask"),1)):e.uniform1i(e.getUniformLocation(o,"u_useMask"),0),e.drawArrays(e.TRIANGLES,0,6)}else if("dither"===t){if(!UI.ditherEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;const t=renderMaskForLayer(e,a,"dither"),o=t?state.programs.maskedDither:state.programs.dither;e.useProgram(o),e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(o,"u_tex"),0),e.uniform1i(e.getUniformLocation(o,"u_type"),parseInt(UI.ditherType?.value||0)),e.uniform1f(e.getUniformLocation(o,"u_bitDepth"),parseFloat(UI.ditherBitDepth.value)),e.uniform1f(e.getUniformLocation(o,"u_strength"),parseFloat(UI.ditherStrength.value)/100),e.uniform1f(e.getUniformLocation(o,"u_scale"),parseFloat(UI.ditherScale.value)),e.uniform2f(e.getUniformLocation(o,"u_res"),n,i),e.uniform1f(e.getUniformLocation(o,"u_seed"),100*Math.random()),e.uniform1i(e.getUniformLocation(o,"u_gamma"),UI.ditherGamma?.checked?1:0);const l=UI.ditherUsePalette?.checked?1:0;if(e.uniform1i(e.getUniformLocation(o,"u_usePalette"),l),l){const t=state.palette.map(hexToRgb),a=new Float32Array(768);t.forEach(((e,t)=>{a[3*t]=e[0]/255,a[3*t+1]=e[1]/255,a[3*t+2]=e[2]/255})),e.uniform3fv(e.getUniformLocation(o,"u_customPalette"),a),e.uniform1f(e.getUniformLocation(o,"u_paletteSize"),t.length)}else e.uniform1f(e.getUniformLocation(o,"u_paletteSize"),parseFloat(UI.ditherPaletteSize.value));t&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(o,"u_mask"),1)),e.drawArrays(e.TRIANGLES,0,6)}else if("corruption"===t){if(!UI.corruptionEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.corruption),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.corruption,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.corruption,"u_algorithm"),parseInt(UI.corruptionAlgorithm?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.corruption,"u_resScale"),parseFloat(UI.corruptionResScale?.value||1)),e.uniform2f(e.getUniformLocation(state.programs.corruption,"u_res"),n,i),e.drawArrays(e.TRIANGLES,0,6)}else if("analogVideo"===t){if(!UI.analogVideoEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.analogVideo),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.analogVideo,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.analogVideo,"u_time"),o.u_time),e.uniform1f(e.getUniformLocation(state.programs.analogVideo,"u_wobble"),o.u_analog_wobble),e.uniform1f(e.getUniformLocation(state.programs.analogVideo,"u_bleed"),o.u_analog_bleed),e.uniform1f(e.getUniformLocation(state.programs.analogVideo,"u_curve"),o.u_analog_curve),e.uniform1f(e.getUniformLocation(state.programs.analogVideo,"u_noise"),o.u_analog_noise),e.drawArrays(e.TRIANGLES,0,6),(o.u_analog_wobble>0||o.u_analog_noise>0)&&requestRender()}else if("lensDistort"===t){if(!UI.lensDistortEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.lensDistort),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.lensDistort,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.lensDistort,"u_amount"),o.u_lens_amount),e.uniform1f(e.getUniformLocation(state.programs.lensDistort,"u_scale"),o.u_lens_scale),e.drawArrays(e.TRIANGLES,0,6)}else if("lightLeaks"===t){if(!UI.lightLeaksEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.lightLeaks),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.lightLeaks,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.lightLeaks,"u_intensity"),o.u_lightleaks_intensity),e.uniform3f(e.getUniformLocation(state.programs.lightLeaks,"u_color1"),o.u_lightleaks_color1.r,o.u_lightleaks_color1.g,o.u_lightleaks_color1.b),e.uniform3f(e.getUniformLocation(state.programs.lightLeaks,"u_color2"),o.u_lightleaks_color2.r,o.u_lightleaks_color2.g,o.u_lightleaks_color2.b),e.uniform1f(e.getUniformLocation(state.programs.lightLeaks,"u_time"),o.u_time),e.drawArrays(e.TRIANGLES,0,6),o.u_lightleaks_intensity>0&&requestRender()}else if("heatwave"===t){if(!UI.heatwaveEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.heatwave),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.heatwave,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.heatwave,"u_time"),o.u_time),e.uniform1f(e.getUniformLocation(state.programs.heatwave,"u_intensity"),o.u_heatwave_intensity),e.uniform1f(e.getUniformLocation(state.programs.heatwave,"u_speed"),o.u_heatwave_speed),e.uniform1f(e.getUniformLocation(state.programs.heatwave,"u_scale"),o.u_heatwave_scale),e.uniform1i(e.getUniformLocation(state.programs.heatwave,"u_direction"),o.u_heatwave_direction),e.drawArrays(e.TRIANGLES,0,6),o.u_heatwave_intensity>0&&requestRender()}else if("compression"===t){if(!UI.compressionEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;const t=Math.max(1,parseInt(UI.compressionIterations?.value||1)),o=state.programs.compression;if(e.useProgram(o),e.uniform1i(e.getUniformLocation(o,"u_method"),parseInt(UI.compressionMethod?.value||0)),e.uniform1f(e.getUniformLocation(o,"u_quality"),parseFloat(UI.compressionQuality?.value||50)),e.uniform1f(e.getUniformLocation(o,"u_blockSize"),parseFloat(UI.compressionBlockSize?.value||8)),e.uniform1f(e.getUniformLocation(o,"u_blend"),parseFloat(UI.compressionBlend?.value||100)/100),e.uniform2f(e.getUniformLocation(o,"u_res"),n,i),t<=1)e.bindFramebuffer(e.FRAMEBUFFER,r),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(o,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6);else{let s=a;for(let a=0;a<t;a++){const n=a===t-1,i=n?r:a%2==0?state.fbos.blur1:state.fbos.blur2;e.bindFramebuffer(e.FRAMEBUFFER,i),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,s),e.uniform1i(e.getUniformLocation(o,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),n||(s=a%2==0?state.textures.blur1:state.textures.blur2)}}}else if("palette"===t){if(!UI.paletteEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.palette),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.palette,"u_tex"),0),e.uniform1f(e.getUniformLocation(state.programs.palette,"u_blend"),parseFloat(UI.paletteBlend?.value||100)/100),e.uniform1f(e.getUniformLocation(state.programs.palette,"u_smoothing"),parseFloat(UI.paletteSmoothing?.value||0)),e.uniform1i(e.getUniformLocation(state.programs.palette,"u_smoothingType"),parseInt(UI.paletteSmoothingType?.value||0)),e.uniform2f(e.getUniformLocation(state.programs.palette,"u_res"),n,i);const t=Math.min(state.palette.length,256);e.uniform1i(e.getUniformLocation(state.programs.palette,"u_paletteSize"),t);const o=new Float32Array(768);for(let e=0;e<t;e++){const t=state.palette[e];o[3*e+0]=parseInt(t.slice(1,3),16)/255,o[3*e+1]=parseInt(t.slice(3,5),16)/255,o[3*e+2]=parseInt(t.slice(5,7),16)/255}e.uniform3fv(e.getUniformLocation(state.programs.palette,"u_palette"),o),e.drawArrays(e.TRIANGLES,0,6)}else if("edge"===t){if(!UI.edgeEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.edge),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.edge,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.edge,"u_res"),n,i),e.uniform1i(e.getUniformLocation(state.programs.edge,"u_mode"),parseInt(UI.edgeMode?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_strength"),parseFloat(UI.edgeStrength?.value||500)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_tolerance"),parseFloat(UI.edgeTolerance?.value||10)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_bgSat"),parseFloat(UI.edgeBgSat?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_fgSat"),parseFloat(UI.edgeFgSat?.value||150)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_bloom"),parseFloat(UI.edgeBloom?.value||10)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_smooth"),parseFloat(UI.edgeSmooth?.value||50)),e.uniform1f(e.getUniformLocation(state.programs.edge,"u_blend"),parseFloat(UI.edgeBlend?.value||100)),e.drawArrays(e.TRIANGLES,0,6)}else if("airyBloom"===t){if(!UI.airyBloomEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;const t=renderMaskForLayer(e,a,"airyBloom");e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.airyBloom),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.airyBloom,"u_tex"),0),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.airyBloom,"u_mask"),1),e.uniform1i(e.getUniformLocation(state.programs.airyBloom,"u_useMask"),t?1:0),e.uniform2f(e.getUniformLocation(state.programs.airyBloom,"u_res"),n,i),e.uniform1f(e.getUniformLocation(state.programs.airyBloom,"u_intensity"),parseFloat(UI.airyBloomIntensity?.value||.5)),e.uniform1f(e.getUniformLocation(state.programs.airyBloom,"u_aperture"),parseFloat(UI.airyBloomAperture?.value||3)),e.uniform1f(e.getUniformLocation(state.programs.airyBloom,"u_threshold"),parseFloat(UI.airyBloomThreshold?.value||.7)),e.uniform1f(e.getUniformLocation(state.programs.airyBloom,"u_thresholdFade"),parseFloat(UI.airyBloomThresholdFade?.value||.1)),e.uniform1f(e.getUniformLocation(state.programs.airyBloom,"u_cutoff"),parseFloat(UI.airyBloomCutoff?.value||1)),e.drawArrays(e.TRIANGLES,0,6)}else if("vignette"===t){if(!UI.vignetteEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.vignette),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.vignette,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.vignette,"u_res"),n,i),e.uniform1f(e.getUniformLocation(state.programs.vignette,"u_intensity"),o.u_vignette_intensity),e.uniform1f(e.getUniformLocation(state.programs.vignette,"u_radius"),o.u_vignette_radius),e.uniform1f(e.getUniformLocation(state.programs.vignette,"u_softness"),o.u_vignette_softness),e.uniform3f(e.getUniformLocation(state.programs.vignette,"u_color"),o.u_vignette_color.r,o.u_vignette_color.g,o.u_vignette_color.b),e.drawArrays(e.TRIANGLES,0,6)}else if("glareRays"===t){if(!UI.glareRaysEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.glareRays),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.glareRays,"u_tex"),0),e.uniform2f(e.getUniformLocation(state.programs.glareRays,"u_res"),n,i),e.uniform1f(e.getUniformLocation(state.programs.glareRays,"u_intensity"),o.u_glare_intensity),e.uniform1f(e.getUniformLocation(state.programs.glareRays,"u_rays"),o.u_glare_rays),e.uniform1f(e.getUniformLocation(state.programs.glareRays,"u_length"),o.u_glare_length),e.uniform1f(e.getUniformLocation(state.programs.glareRays,"u_blur"),o.u_glare_blur),e.drawArrays(e.TRIANGLES,0,6)}else if("hankelBlur"===t){if(!UI.hankelBlurEnable?.checked&&!s)return e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.copy),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),r===state.fbos.temp2?state.textures.temp2:state.textures.temp1;const t=renderMaskForLayer(e,a,"hankel");e.bindFramebuffer(e.FRAMEBUFFER,r),e.useProgram(state.programs.hankelBlur),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,a),e.uniform1i(e.getUniformLocation(state.programs.hankelBlur,"u_tex"),0),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.hankelBlur,"u_mask"),1),e.uniform1i(e.getUniformLocation(state.programs.hankelBlur,"u_useMask"),t?1:0),e.uniform2f(e.getUniformLocation(state.programs.hankelBlur,"u_res"),n,i),e.uniform1f(e.getUniformLocation(state.programs.hankelBlur,"u_intensity"),o.u_hankel_intensity),e.uniform1f(e.getUniformLocation(state.programs.hankelBlur,"u_radius"),o.u_hankel_radius),e.uniform1f(e.getUniformLocation(state.programs.hankelBlur,"u_quality"),o.u_hankel_quality),e.drawArrays(e.TRIANGLES,0,6)}return r===state.fbos.temp2?state.textures.temp2:state.textures.temp1}function renderMaskForLayer(e,t,a){const r=UI[a+"LumaMask"]?.checked||UI.noiseLumaMask?.checked,o=UI[a+"ColorExclude"]?.checked||UI.noiseColorExclude?.checked;if(!r&&!o)return null;if(state.fbos.maskTotal||(state.textures.maskTotal=createTexture(e,null,state.renderWidth,state.renderHeight),state.fbos.maskTotal=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.maskTotal),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,state.textures.maskTotal,0)),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.maskTotal),e.clearColor(1,1,1,1),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.DST_COLOR,e.ZERO),r&&(e.useProgram(state.programs.mask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useS"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI[a+"ShadowThreshold"]?.value||UI.shadowThreshold?.value||0)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI[a+"ShadowFade"]?.value||UI.shadowFade?.value||.1)),e.uniform1i(e.getUniformLocation(state.programs.mask,"u_useH"),1),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI[a+"HighlightThreshold"]?.value||UI.highlightThreshold?.value||1)),e.uniform1f(e.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI[a+"HighlightFade"]?.value||UI.highlightFade?.value||.1)),e.drawArrays(e.TRIANGLES,0,6)),o){const r=hexToRgb(UI[a+"ExcludeColor"]?.value||UI[a+"TargetColor"]?.value||UI.noiseExcludeColor?.value||"#000000");e.useProgram(state.programs.colorMask),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(state.programs.colorMask,"u_tex"),0),e.uniform3f(e.getUniformLocation(state.programs.colorMask,"u_targetColor"),r.r,r.g,r.b),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI[a+"ColorTolerance"]?.value||UI.noiseColorTolerance?.value||10)/100),e.uniform1f(e.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI[a+"ColorFade"]?.value||UI.noiseColorFade?.value||20)/100),e.drawArrays(e.TRIANGLES,0,6)}return e.disable(e.BLEND),(UI[a+"InvertMask"]?.checked||UI.noiseInvertMask?.checked)&&(e.useProgram(state.programs.invert),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.blur1),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,state.textures.maskTotal),e.uniform1i(e.getUniformLocation(state.programs.invert,"u_tex"),0),e.drawArrays(e.TRIANGLES,0,6),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.maskTotal),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,state.textures.blur1),e.useProgram(state.programs.copy),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_channel"),0),e.drawArrays(e.TRIANGLES,0,6)),state.textures.maskTotal}function renderFrame(e=!1){if(!state.baseImage)return;if(!e){const e=performance.now();if(state.lastFrameTime>0){const t=e-state.lastFrameTime;state.realtimeFps=1e3/t}state.lastFrameTime=e,state.frameRenderCount++,state.frameRenderCount%15==0&&(UI.actualFps.textContent=`(Actual: ${Math.round(state.realtimeFps)} FPS)`)}const t=state.gl,a=reallocateBuffers(e),r=a.w,o=a.h;t.viewport(0,0,r,o);let s=0,n=1,i=state.textures.base;if(e&&(r!==state.width||o!==state.height)){const e=document.createElement("canvas");e.width=r,e.height=o,e.getContext("2d").drawImage(state.baseImage,0,0,state.width,state.height,0,0,r,o),i=t.createTexture(),t.bindTexture(t.TEXTURE_2D,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texImage2D(t.TEXTURE_2D,0,t.SRGB8_ALPHA8,t.RGBA,t.UNSIGNED_BYTE,e)}t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[0].fbo),t.useProgram(state.programs.copy),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,i),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6),e&&i!==state.textures.base&&t.deleteTexture(i);const l={u_bright:parseFloat(UI.brightness.value),u_cont:parseFloat(UI.contrast.value),u_sat:parseFloat(UI.saturationAdj.value)/100,u_warmth:parseFloat(UI.warmth.value),u_sharp:parseFloat(UI.sharpen.value),u_sharpThresh:parseFloat(UI.sharpenThreshold.value),u_step:[1/r,1/o],u_hdrTol:parseFloat(UI.hdrTolerance.value),u_hdrAmt:parseFloat(UI.hdrAmount.value),u_ca_amt:calcCurve(parseFloat(UI.aberrationAmount.value),300,300),u_ca_blur:calcCurve(parseFloat(UI.aberrationBlur.value),100,100),u_ca_center:[state.caCenter.x,state.caCenter.y],u_ca_rad:parseFloat(UI.caRadius.value)/1e3,u_ca_fall:parseFloat(UI.caFalloff.value)/1e3,u_airy_intensity:parseFloat(UI.airyBloomIntensity?.value??.5),u_airy_aperture:parseFloat(UI.airyBloomAperture?.value??3),u_airy_threshold:parseFloat(UI.airyBloomThreshold?.value??.7),u_glare_intensity:parseFloat(UI.glareRaysIntensity?.value??.4),u_glare_rays:parseFloat(UI.glareRaysRays?.value??6),u_glare_length:parseFloat(UI.glareRaysLength?.value??.3),u_glare_blur:parseFloat(UI.glareRaysBlur?.value??.2),u_hankel_intensity:parseFloat(UI.hankelBlurIntensity?.value??.5),u_hankel_radius:parseFloat(UI.hankelBlurRadius?.value??5),u_hankel_quality:parseFloat(UI.hankelBlurQuality?.value??16),u_vignette_intensity:parseFloat(UI.vignetteIntensity?.value??50)/100,u_vignette_radius:parseFloat(UI.vignetteRadius?.value??75)/100,u_vignette_softness:parseFloat(UI.vignetteSoftness?.value??50)/100,u_vignette_color:hexToRgb(UI.vignetteColor?.value??"#000000"),u_analog_wobble:parseFloat(UI.analogWobble?.value??30)/100,u_analog_bleed:parseFloat(UI.analogBleed?.value??50)/100,u_analog_curve:parseFloat(UI.analogCurve?.value??20)/100,u_analog_noise:parseFloat(UI.analogNoise?.value??40)/100,u_lens_amount:parseFloat(UI.lensAmount?.value??0)/100,u_lens_scale:parseFloat(UI.lensScale?.value??100)/100,u_heatwave_intensity:parseFloat(UI.heatwaveIntensity?.value??30)/100,u_heatwave_speed:parseFloat(UI.heatwaveSpeed?.value??50)/100,u_heatwave_scale:parseFloat(UI.heatwaveScale?.value??20),u_heatwave_direction:parseInt(UI.heatwaveDirection?.value??0),u_lightleaks_intensity:parseFloat(UI.lightLeaksIntensity?.value??50)/100,u_lightleaks_color1:hexToRgb(UI.lightLeaksColor1?.value??"#ff5500"),u_lightleaks_color2:hexToRgb(UI.lightLeaksColor2?.value??"#0055ff"),u_time:performance.now()%1e5/1e3};state.renderOrder.forEach((e=>{const a=("adjust"===e?"adj":e)+"Enable";if(state.layerVisibility[e]&&(!UI[a]||UI[a].checked))try{renderSingleLayer(t,e,state.pingPong[s].tex,state.pingPong[n].fbo,l),state.layerTextures[e]=state.pingPong[n].tex,state.activeSection&&e===state.activeSection&&state.fbos.chainCapture&&(t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.chainCapture),t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[n].tex),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),0),t.drawArrays(t.TRIANGLES,0,6));let a=s;s=n,n=a}catch(e){}})),t.bindFramebuffer(t.FRAMEBUFFER,null),t.canvas.width===r&&t.canvas.height===o||(t.canvas.width=r,t.canvas.height=o),t.viewport(0,0,r,o);const u=state.activeLayerPreview&&state.layerTextures[state.activeLayerPreview]?state.layerTextures[state.activeLayerPreview]:state.pingPong[s].tex;let m=0;"shadows"===state.activeLayerPreview&&(m=2),"highlights"===state.activeLayerPreview&&(m=3),0===m?(t.useProgram(state.programs.final),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,u),t.uniform1i(t.getUniformLocation(state.programs.final,"u_tex"),0),t.uniform2f(t.getUniformLocation(state.programs.final,"u_res"),r,o)):(t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,u),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),m)),t.drawArrays(t.TRIANGLES,0,6);const c=document.querySelector(".info-details");if(c&&c.open&&(t.bindFramebuffer(t.FRAMEBUFFER,state.analysisFBO.fbo),t.viewport(0,0,state.analysisFBO.w,state.analysisFBO.h),t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,u),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),0),t.drawArrays(t.TRIANGLES,0,6)),e)t.finish();else{UI.layerGrid&&UI.layerGrid.offsetHeight>0&&updateLayerPreviews();const a=document.querySelector(".info-details");if(a&&a.open&&(updateHistogram(),updateVectorscope()),state.previewWindow&&!state.previewWindow.closed)try{const e=state.previewWindow.document.getElementById("fs-canvas");e?(e.width===r&&e.height===o||(e.width=r,e.height=o),e.getContext("2d").drawImage(t.canvas,0,0)):state.previewWindow=null}catch(e){state.previewWindow=null}}}function calcCurve(e,t,a=1){const r=e/t;return r*r*a}function updatePinPosition(){const e=100*state.caCenter.x,t=100*(1-state.caCenter.y);UI.caPin.style.left=e+"%",UI.caPin.style.top=t+"%"}function updatePaletteUI(){UI.paletteList.innerHTML="",state.palette.forEach(((e,t)=>{const a=document.createElement("div");a.className="palette-color-item",a.innerHTML=`\n                    <input type="color" value="${e}">\n                    <button class="remove-color-btn" title="Remove">&times;</button>\n                `,a.querySelector("input").addEventListener("input",(e=>{state.palette[t]=e.target.value,requestRender()})),a.querySelector(".remove-color-btn").addEventListener("click",(()=>{state.palette.splice(t,1),updatePaletteUI(),requestRender()})),UI.paletteList.appendChild(a)}))}function syncNoiseUI(){const e=parseInt(UI.noiseType.value),t=document.getElementById("noiseParamsHeader"),a=document.getElementById("noiseParamRowA"),r=document.getElementById("noiseParamRowB"),o=document.getElementById("noiseParamRowC"),s=document.getElementById("noiseLabelA"),n=document.getElementById("noiseLabelB"),i=document.getElementById("noiseLabelC");[t,a,r,o].forEach((e=>e.style.display="none"));const l=(e,l,u)=>{t.style.display="block",e&&(a.style.display="flex",s.textContent=e),l&&(r.style.display="flex",n.textContent=l),u&&(o.style.display="flex",i.textContent=u)};switch(e){case 5:l("Complexity","Organic Flow","Octave Mix"),UI.noiseParamA.min=1,UI.noiseParamA.max=8,UI.noiseParamA.step=1,UI.noiseParamA.value>8&&(UI.noiseParamA.value=4);break;case 6:l("Cell Jitter","Density","Sphericity"),UI.noiseParamA.min=0,UI.noiseParamA.max=100,UI.noiseParamA.step=1;break;case 7:l("Line Thickness","Vertical Jitter","Sync Grain");break;case 8:l("Density","Sharpness","Variable Size");break;case 9:l("Block Size","Horiz Shift","RGB Split");break;case 10:l("Stretch","Rotation","Fiber Link");break;case 11:l("Cell Detail","Randomness","Smoothness");break;case 12:l("Line Density","Diagonal Angle","Pressure")}}async function extractPaletteFromImage(e,t){const a=document.createElement("canvas"),r=a.getContext("2d"),o=128;a.width=o,a.height=o,r.drawImage(e,0,0,o,o);const s=r.getImageData(0,0,o,o).data,n={};for(let e=0;e<s.length;e+=4){if(s[e+3]<128)continue;const t="#"+((1<<24)+(s[e]<<16)+(s[e+1]<<8)+s[e+2]).toString(16).slice(1).toUpperCase();n[t]=(n[t]||0)+1}const i=Object.entries(n).map((([e,t])=>({hex:e,freq:t,r:parseInt(e.slice(1,3),16),g:parseInt(e.slice(3,5),16),b:parseInt(e.slice(5,7),16)})));if(0===i.length)return;const l=[];i.sort(((e,t)=>t.freq-e.freq)),l.push(i[0]);const u=new Float32Array(i.length).fill(1e10),m=e=>{for(let t=0;t<i.length;t++){const a=i[t],r=Math.sqrt(Math.pow(a.r-e.r,2)+Math.pow(a.g-e.g,2)+Math.pow(a.b-e.b,2));r<u[t]&&(u[t]=r)}};m(l[0]);const c=Math.min(t,i.length);for(;l.length<c;){let e=-1,t=-1;for(let a=0;a<i.length;a++)u[a]>t&&(t=u[a],e=a);if(-1===e)break;const a=i[e];l.push(a),m(a)}state.palette=l.map((e=>e.hex)),updatePaletteUI(),requestRender()}function createShader(e,t,a){const r=document.getElementById(a).text.trim(),o=e.createShader("vs-quad"==t?e.VERTEX_SHADER:e.FRAGMENT_SHADER);return e.shaderSource(o,r),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:null}function createProgram(e,t,a){const r=createShader(e,"vs-quad",t),o=createShader(e,"fs-fragment",a),s=e.createProgram();return e.attachShader(s,r),e.attachShader(s,o),e.linkProgram(s),s}function createTexture(e,t,a,r,o=!1){const s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR);const n=o?e.RGBA16F:e.SRGB8_ALPHA8,i=e.RGBA,l=o?e.HALF_FLOAT:e.UNSIGNED_BYTE;return t&&(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageBitmap)?e.texImage2D(e.TEXTURE_2D,0,n,i,l,t):e.texImage2D(e.TEXTURE_2D,0,n,a,r,0,i,l,t||null),s}function hexToRgb(e){return{r:parseInt(e.slice(1,3),16)/255,g:parseInt(e.slice(3,5),16)/255,b:parseInt(e.slice(5,7),16)/255}}async function downloadFullRes(){UI.loading.style.display="block",await new Promise((e=>setTimeout(e,50))),reallocateBuffers(!0),renderFrame(!0);const e=document.createElement("a");e.download="grain-export.png",e.href=state.canvas.toDataURL("image/png",1),e.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function openCompare(){UI.loading.style.display="block",await new Promise((e=>setTimeout(e,50))),renderFrame(!0);const e=document.getElementById("compareOriginal"),t=document.getElementById("compareProcessed"),a=state.width/state.height;e.width=600,e.height=600/a,t.width=600,t.height=600/a;const r=e.getContext("2d"),o=t.getContext("2d");if(r.drawImage(state.baseImage,0,0,e.width,e.height),o.drawImage(state.canvas,0,0,t.width,t.height),UI.exportInfo){const e=Math.round(state.width*state.upscaleFactor),t=Math.round(state.height*state.upscaleFactor),a=state.renderWidth,r=state.renderHeight,o=state._exportScale||1;UI.exportInfo.innerHTML=`Requested: ${e}x${t} | Actual: ${a}x${r} (Safe Scale: ${o.toFixed(2)})`,UI.exportInfo.style.color=o<1?"#ffaa00":"#0f0"}document.getElementById("compareModal").classList.add("show"),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function exportComparison(e){UI.loading.style.display="block",await new Promise((e=>setTimeout(e,50))),renderFrame(!0);const t=state.canvas.toDataURL(),a=new Image;a.src=t,await new Promise((e=>a.onload=e));const r=document.createElement("canvas"),o=state.canvas.width,s=state.canvas.height;if("side"===e){r.width=2*o,r.height=s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0,o,s),e.drawImage(a,o,0)}else{r.width=o,r.height=2*s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0,o,s),e.drawImage(a,0,s)}const n=document.createElement("a");n.download=`grain-compare-${e}.png`,n.href=r.toDataURL("image/png",.9),n.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}function openFullscreenPreview(){if(state.previewWindow&&!state.previewWindow.closed)return void state.previewWindow.focus();const e=window.open("","NoiseStudioPreview","width=800,height=600");if(!e)return void alert("Pop-up blocked. Please allow pop-ups for this site.");const t=e.document;t.open(),t.write(""),t.close(),t.title="Noise Studio Preview",t.body.style.margin="0",t.body.style.background="#111",t.body.style.height="100vh",t.body.style.display="flex",t.body.style.alignItems="center",t.body.style.justifyContent="center",t.body.style.overflow="hidden";const a=t.createElement("canvas");a.id="fs-canvas",a.style.maxWidth="100%",a.style.maxHeight="100%",a.style.objectFit="contain",a.style.boxShadow="0 0 20px rgba(0,0,0,0.5)",t.body.appendChild(a),state.previewWindow=e,setTimeout((()=>requestRender()),100)}function getSectionFromId(e){return e?e.startsWith("adj")||"brightness"===e||"contrast"===e||"saturationAdj"===e||"warmth"===e||"sharpen"===e?"adjust":e.startsWith("hdr")?"hdr":e.startsWith("noise")||"opacity"===e||"strength"===e||"blendMode"===e||e.startsWith("sat")||e.startsWith("ignore")?"noise":e.startsWith("blur")?"blur":e.startsWith("dither")?"dither":e.startsWith("cell")?"cell":e.startsWith("halftone")?"halftone":e.startsWith("bilateral")?"bilateral":e.startsWith("aberration")||e.startsWith("ca")?"ca":e.startsWith("corruption")?"corruption":e.startsWith("palette")?"palette":e.startsWith("edge")?"edge":e.startsWith("airyBloom")?"airyBloom":e.startsWith("glareRays")?"glareRays":"adjust":null}function setupLayerGridDOM(e){const t=UI.layerGrid;t.innerHTML="";const a=[{id:"chain",label:"Chain"},{id:"isolated",label:"Isolated"}];!{blur:!0,dither:!0,halftone:!0,bilateral:!0,adjust:!0,noise:!0}[e]?"ca"===e&&a.push({id:"falloff",label:"Falloff Map"}):(a.push({id:"mask_luma",label:"Luma Mask"}),a.push({id:"mask_color",label:"Color Mask"}),a.push({id:"mask_total",label:"Total Mask"}));const r=110*(state.width/state.height);a.forEach((a=>{const o=document.createElement("div");o.className="layer-item",o.style.minWidth=`${Math.max(80,r)}px`,o.style.flex="0 0 auto";const s=e+"_"+a.id;state.activeLayerPreview===s&&o.classList.add("active"),o.onclick=()=>{const t=e+"_"+a.id;state.activeLayerPreview===t?(state.activeLayerPreview=null,o.classList.remove("active")):(state.activeLayerPreview=t,document.querySelectorAll(".layer-item").forEach((e=>e.classList.remove("active"))),o.classList.add("active"),UI.overlayOriginal.classList.remove("show")),requestRender()},o.innerHTML=`\n                    <div class="layer-title">${a.label}</div>\n                    <canvas class="layer-canvas" id="thumb-${a.id}" width="${Math.round(r)}" height="110"></canvas>\n                `,t.appendChild(o)}))}function updateLayerPreviews(){const e=state.gl;if(!state.baseImage)return;const t=state.activeSection||"adjust";if(state.lastActiveSectionDOM!==t&&(setupLayerGridDOM(t),state.lastActiveSectionDOM=t),!state.thumbnailFBO)return;drawToThumbnail(state.textures.chainCapture?state.textures.chainCapture:state.layerTextures[t],"thumb-chain");const a=state.renderOrder.indexOf(t),r=a>0?state.layerTextures[state.renderOrder[a-1]]:state.textures.base,o={u_bright:parseFloat(UI.brightness.value),u_cont:parseFloat(UI.contrast.value),u_sat:parseFloat(UI.saturationAdj.value)/100,u_warmth:parseFloat(UI.warmth.value),u_sharp:parseFloat(UI.sharpen.value),u_sharpThresh:parseFloat(UI.sharpenThreshold.value),u_step:[1/state.renderWidth,1/state.renderHeight],u_hdrTol:parseFloat(UI.hdrTolerance.value),u_hdrAmt:parseFloat(UI.hdrAmount.value),u_ca_amt:calcCurve(parseFloat(UI.aberrationAmount.value),300,300),u_ca_blur:calcCurve(parseFloat(UI.aberrationBlur.value),100,100),u_ca_center:[state.caCenter.x,state.caCenter.y],u_ca_rad:parseFloat(UI.caRadius.value)/1e3,u_ca_fall:parseFloat(UI.caFalloff.value)/1e3,u_airy_intensity:parseFloat(UI.airyBloomIntensity?.value??.5),u_airy_aperture:parseFloat(UI.airyBloomAperture?.value??3),u_airy_threshold:parseFloat(UI.airyBloomThreshold?.value??.7),u_glare_intensity:parseFloat(UI.glareRaysIntensity?.value??.4),u_glare_rays:parseFloat(UI.glareRaysRays?.value??6),u_glare_length:parseFloat(UI.glareRaysLength?.value??.3),u_glare_blur:parseFloat(UI.glareRaysBlur?.value??.2)};renderSingleLayer(e,t,r,state.fbos.preview,o,!0),drawToThumbnail(state.textures.preview,"thumb-isolated"),state.activeLayerPreview===t+"_isolated"&&(state.layerTextures[state.activeLayerPreview]=state.textures.preview);const s=document.getElementById("thumb-mask_luma"),n=document.getElementById("thumb-mask_color"),i=document.getElementById("thumb-mask_total");(s||n||i)&&(renderMaskForSection(t,r),s&&(drawToThumbnail(state.textures.maskLuma,"thumb-mask_luma",1),state.activeLayerPreview===t+"_mask_luma"&&(state.layerTextures[state.activeLayerPreview]=state.textures.maskLuma)),n&&(drawToThumbnail(state.textures.maskColor,"thumb-mask_color",0),state.activeLayerPreview===t+"_mask_color"&&(state.layerTextures[state.activeLayerPreview]=state.textures.maskColor)),i&&(drawToThumbnail(state.textures.maskTotal,"thumb-mask_total",0),state.activeLayerPreview===t+"_mask_total"&&(state.layerTextures[state.activeLayerPreview]=state.textures.maskTotal))),document.getElementById("thumb-falloff")&&(renderCAFalloff(),drawToThumbnail(state.textures.preview,"thumb-falloff"),state.activeLayerPreview===t+"_falloff"&&(state.layerTextures[state.activeLayerPreview]=state.textures.preview))}function renderMaskForSection(e,t){const a=state.gl,r=state.renderWidth,o=state.renderHeight;a.viewport(0,0,r,o),state.textures.maskLuma||(state.textures.maskLuma=createTexture(a,null,r,o),state.fbos.maskLuma=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskLuma),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,state.textures.maskLuma,0),state.textures.maskColor=createTexture(a,null,r,o),state.fbos.maskColor=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskColor),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,state.textures.maskColor,0),state.textures.maskTotal=createTexture(a,null,r,o),state.fbos.maskTotal=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskTotal),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,state.textures.maskTotal,0));let s="adjust"===e?"adj":e;a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskLuma),a.useProgram(state.programs.mask),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,t),a.uniform1i(a.getUniformLocation(state.programs.mask,"u_tex"),0),a.uniform1i(a.getUniformLocation(state.programs.mask,"u_useS"),1),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI[s+"ShadowThreshold"]?.value||UI.shadowThreshold?.value||0)),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI[s+"ShadowFade"]?.value||UI.shadowFade?.value||0)),a.uniform1i(a.getUniformLocation(state.programs.mask,"u_useH"),1),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI[s+"HighlightThreshold"]?.value||UI.highlightThreshold?.value||1)),a.uniform1f(a.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI[s+"HighlightFade"]?.value||UI.highlightFade?.value||0)),a.drawArrays(a.TRIANGLES,0,6),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskColor);const n=hexToRgb(UI[s+"ExcludeColor"]?.value||UI.noiseExcludeColor?.value||"#000000");a.useProgram(state.programs.colorMask),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,t),a.uniform1i(a.getUniformLocation(state.programs.colorMask,"u_tex"),0),a.uniform3f(a.getUniformLocation(state.programs.colorMask,"u_targetColor"),n.r,n.g,n.b),a.uniform1f(a.getUniformLocation(state.programs.colorMask,"u_tolerance"),parseFloat(UI[s+"ColorTolerance"]?.value||UI.noiseColorTolerance?.value||.1)/100),a.uniform1f(a.getUniformLocation(state.programs.colorMask,"u_fade"),parseFloat(UI[s+"ColorFade"]?.value||UI.noiseColorFade?.value||0)/100),a.drawArrays(a.TRIANGLES,0,6),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskTotal),a.clearColor(1,1,1,1),a.clear(a.COLOR_BUFFER_BIT),a.enable(a.BLEND),a.blendFunc(a.DST_COLOR,a.ZERO),(UI[s+"LumaMask"]?.checked||UI.noiseLumaMask?.checked)&&(a.useProgram(state.programs.copy),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.maskLuma),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_tex"),0),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_channel"),1),a.drawArrays(a.TRIANGLES,0,6)),(UI[s+"ColorExclude"]?.checked||UI.noiseColorExclude?.checked)&&(a.useProgram(state.programs.copy),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.maskColor),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_tex"),0),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_channel"),0),a.drawArrays(a.TRIANGLES,0,6)),a.disable(a.BLEND),(UI[s+"InvertMask"]?.checked||UI.noiseInvertMask?.checked)&&(a.useProgram(state.programs.invert),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.preview),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.maskTotal),a.uniform1i(a.getUniformLocation(state.programs.invert,"u_tex"),0),a.drawArrays(a.TRIANGLES,0,6),a.bindFramebuffer(a.FRAMEBUFFER,state.fbos.maskTotal),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,state.textures.preview),a.useProgram(state.programs.copy),a.uniform1i(a.getUniformLocation(state.programs.copy,"u_tex"),0),a.drawArrays(a.TRIANGLES,0,6))}function renderCAFalloff(){const e=state.gl,t=state.renderWidth,a=state.renderHeight;e.viewport(0,0,t,a),e.bindFramebuffer(e.FRAMEBUFFER,state.fbos.preview),e.useProgram(state.programs.radial),e.uniform2f(e.getUniformLocation(state.programs.radial,"u_res"),t,a),e.uniform2f(e.getUniformLocation(state.programs.radial,"u_center"),state.caCenter.x,state.caCenter.y),e.uniform1f(e.getUniformLocation(state.programs.radial,"u_radius"),parseFloat(UI.caRadius.value)/1e3),e.uniform1f(e.getUniformLocation(state.programs.radial,"u_falloff"),parseFloat(UI.caFalloff.value)/1e3),e.drawArrays(e.TRIANGLES,0,6)}function drawToThumbnail(e,t,a=0){const r=document.getElementById(t);if(!r||!e)return;const o=state.gl,s=r.width,n=r.height,i=state.thumbnailFBO.w,l=state.thumbnailFBO.h;o.bindFramebuffer(o.FRAMEBUFFER,state.thumbnailFBO.fbo),o.viewport(0,0,i,l),o.useProgram(state.programs.copy),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,e),o.uniform1i(o.getUniformLocation(state.programs.copy,"u_tex"),0),o.uniform1i(o.getUniformLocation(state.programs.copy,"u_channel"),a),o.drawArrays(o.TRIANGLES,0,6);const u=state.thumbPixelBuffer;o.readPixels(0,0,i,l,o.RGBA,o.UNSIGNED_BYTE,u);const m=state.thumbClampedBuffer;for(let e=0;e<l;e++){const t=(l-1-e)*i*4,a=e*i*4;m.set(u.subarray(t,t+4*i),a)}const c=new ImageData(m,i,l);state.thumbTempCtx.putImageData(c,0,0),r.getContext("2d",{alpha:!1}).drawImage(state.thumbTempCanvas,0,0,i,l,0,0,s,n)}document.getElementById("fullscreenPreviewBtn").addEventListener("click",openFullscreenPreview)</script> <script type="x-shader/x-fragment" id="fs-hankelBlur">
#version 300 es
    precision highp float;
    uniform sampler2D u_tex;
    uniform sampler2D u_mask;
    uniform vec2 u_res;
    uniform float u_radius;
    uniform float u_quality;
    uniform float u_intensity;
    uniform int u_useMask;
    in vec2 v_uv;
    out vec4 outColor;
    
    // J0 Bessel function approximation
    float besselJ0(float x) {
        float ax = abs(x);
        if (ax < 8.0) {
            float y = x * x;
            float ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7
                + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
            float ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718
                + y * (59272.64853 + y * (267.8532712 + y * 1.0))));
            return ans1 / ans2;
        } else {
            float z = 8.0 / ax;
            float y = z * z;
            float xx = ax - 0.785398164;
            float ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4
                + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));
            float ans2 = -0.1562499995e-1 + y * (0.1430488765e-3
                + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));
            return sqrt(0.636619772 / ax) * (cos(xx) * ans1 - z * sin(xx) * ans2);
        }
    }
    
    void main() {
        vec2 texelSize = 1.0 / u_res;
        vec4 color = vec4(0.0);
        float totalWeight = 0.0;
        int samples = int(u_quality);
        
        // Circular convolution using quality for step counts
        // Nested loop: Radial distance then Angular orientation
        for (int i = 0; i < 32; i++) {
            if (i >= samples) break;
            for (int j = 0; j < 32; j++) {
                if (j >= samples) break;
                
                float r = (float(i) / float(samples)) * u_radius;
                float theta = (float(j) / float(samples)) * 6.283185307;
                
                vec2 offset = vec2(cos(theta), sin(theta)) * r * texelSize;
                float weight = besselJ0(r * 2.0); // Adjust frequency for desired look
                weight = abs(weight) + 0.01;      // Ensure non-zero weight for stability
                
                color += texture(u_tex, v_uv + offset) * weight;
                totalWeight += weight;
            }
        }
        
        vec4 blurred = color / max(0.001, totalWeight);
        vec4 original = texture(u_tex, v_uv);
        
        // Apply unified mask and global intensity
        float mask = 1.0;
        if (u_useMask == 1) {
            mask = texture(u_mask, v_uv).r;
        }
        outColor = mix(original, blurred, mask * u_intensity);
    }
    </script> <script type="x-shader/x-fragment" id="fs-airyBloom">
#version 300 es
    precision highp float;
    uniform sampler2D u_tex;
    uniform vec2 u_res;
    uniform float u_time;
    uniform float u_intensity;
    uniform float u_aperture;
    uniform float u_threshold;
    uniform float u_thresholdFade;
    uniform float u_cutoff;
    uniform sampler2D u_mask;
    uniform int u_useMask;
    in vec2 v_uv;
    out vec4 outColor;
    
    // J0 Bessel function approximation is handled in hankelBlur, 
    // but here we need J1 for Airy Disk.
    float besselJ1(float x) {
        float ax = abs(x);
        if (ax < 8.0) {
            float y = x * x;
            float ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1
                + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
            float ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74
                + y * (99447.43394 + y * (376.9991397 + y * 1.0))));
            return ans1 / ans2;
        } else {
            float z = 8.0 / ax;
            float y = z * z;
            float xx = ax - 2.356194491;
            float ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4
                + y * (0.2457520174e-5 + y * (-0.240337019e-6))));
            float ans2 = 0.04687499995 + y * (-0.2002690873e-3
                + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));
            float ans = sqrt(0.636619772 / ax) * (cos(xx) * ans1 - z * sin(xx) * ans2);
            return (x > 0.0 ? ans : -ans);
        }
    }

    float airyPSF(float r, float aperture) {
        if (r < 0.001) return 1.0;
        float x = r * aperture * 3.14159265;
        float res = 2.0 * besselJ1(x) / x;
        return res * res;
    }
    
    void main() {
        vec2 texelSize = 1.0 / u_res;
        vec4 color = vec4(0.0);
        float totalWeight = 0.0;
        
        const float renderRadius = 15.0; // Fixed sampling radius for performance
        
        for (float x = -renderRadius; x <= renderRadius; x += 1.0) {
            for (float y = -renderRadius; y <= renderRadius; y += 1.0) {
                vec2 offset = vec2(x, y) * texelSize;
                float dist = length(vec2(x, y));
                if (dist > renderRadius) continue;
                
                float weight = airyPSF(dist / renderRadius, u_aperture);
                color += texture(u_tex, v_uv + offset) * weight;
                totalWeight += weight;
            }
        }
        
        color /= max(0.001, totalWeight);
        
        vec4 original = texture(u_tex, v_uv);
        float luminance = dot(original.rgb, vec3(0.2126, 0.7152, 0.0722));
        
        // Bandpass Filter based on brightness range
        float low = smoothstep(u_threshold, u_threshold + u_thresholdFade + 0.001, luminance);
        float high = 1.0 - smoothstep(u_cutoff - 0.1, u_cutoff, luminance);
        float contribution = low * high;

        // Apply masking
        if (u_useMask == 1) {
            float maskVal = texture(u_mask, v_uv).r;
            contribution *= maskVal;
        }

        outColor = mix(original, original + color * u_intensity, contribution);
    }
    </script> <script type="x-shader/x-fragment" id="fs-vignette">
#version 300 es
    precision highp float;
    out vec4 outColor;
    in vec2 v_uv;
    uniform sampler2D u_tex;
    uniform vec2 u_res;
    uniform float u_intensity;
    uniform float u_radius;
    uniform float u_softness;
    uniform vec3 u_color;

    void main() {
        vec4 col = texture(u_tex, v_uv);

        // Calculate distance from center (0.5, 0.5)
        // Adjust for aspect ratio so the vignette is circular
        vec2 center = vec2(0.5, 0.5);
        vec2 aspect = vec2(1.0, u_res.y / u_res.x);
        float dist = distance((v_uv - center) / aspect, vec2(0.0));

        // Smoothstep for gradual transition
        // u_radius is the inner bounds. outer bounds is u_radius + u_softness
        float v = smoothstep(u_radius, u_radius + u_softness, dist);

        // Blend the vignette color with the original pixel
        // v = 0 at center (keep original), v = 1 at edge (blend vignette color)
        vec3 finalColor = mix(col.rgb, u_color, v * u_intensity);

        outColor = vec4(finalColor, col.a);
    }
    </script> <script type="x-shader/x-fragment" id="fs-glareRays">
#version 300 es
    precision highp float;
    uniform sampler2D u_tex;
    uniform vec2 u_res;
    uniform float u_intensity;
    uniform float u_rays;
    uniform float u_length;
    uniform float u_blur;
    in vec2 v_uv;
    out vec4 outColor;
    
    void main() {
        vec2 center = vec2(0.5);
        vec2 dir = v_uv - center;
        float r = length(dir);
        float theta = atan(dir.y, dir.x);
        
        // Angular streak pattern
        float angularPattern = 0.0;
        // Refined sharpness range: 40.0 (sharp) to 0.5 (very soft)
        // Using a more linear-ish feel for the slider
        float sharpness = mix(40.0, 0.5, pow(clamp(u_blur, 0.0, 1.0), 0.7));
        
        for (float i = 0.0; i < 16.0; i++) {
            if (i >= u_rays) break;
            float angle = i * 3.14159265 * 2.0 / u_rays;
            float diff = abs(mod(theta - angle + 3.14159265, 3.14159265 * 2.0) - 3.14159265);
            // Using a softer falloff profile for better blurring
            angularPattern += exp(-diff * sharpness);
        }
        
        // Proper normalization based on ray count to prevent saturation
        // But keep it bright enough to be visible
        angularPattern *= (2.0 / max(1.0, u_rays * 0.5));
        
        // Radial falloff: using a slightly softer falloff for long rays
        float radialFalloff = exp(-r * 4.0 / max(0.01, u_length));
        
        // Sample along streaks
        vec4 color = vec4(0.0);
        float totalWeight = 0.0;
        int samples = 24;
        
        for (int i = -samples; i <= samples; i++) {
            float t = float(i) / float(samples);
            vec2 sampleCoord = v_uv + dir * t * u_length;
            float weight = (1.0 - abs(t)) * angularPattern * radialFalloff;
            color += texture(u_tex, sampleCoord) * weight;
            totalWeight += weight;
        }
        
        if (totalWeight > 0.0) color /= totalWeight;
        
        vec4 original = texture(u_tex, v_uv);
        outColor = original + color * u_intensity * 0.5;
    }
    </script> <script type="x-shader/x-fragment" id="fs-final">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    vec4 c = texture(u_tex, v_uv);
    // Perceptually-weighted triangular dither to prevent banding on 8-bit output
    // Triangular distribution is better than uniform for minimizing visible noise
    float r1 = hash(v_uv * u_res);
    float r2 = hash(v_uv * u_res + 1.234);
    float dither = (r1 + r2 - 1.0) / 255.0;
    
    // Manual sRGB Gamma Correction (2.2)
    vec3 linear = c.rgb + dither;
    vec3 srgb = pow(clamp(linear, 0.0, 1.0), vec3(1.0/2.2));
    
    outColor = vec4(srgb, c.a);
}
</script> </body></html>