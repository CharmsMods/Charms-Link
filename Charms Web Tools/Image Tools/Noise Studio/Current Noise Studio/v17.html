<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Digital Grain Studio â€” GPU Accelerated</title><style>:root{--bg:#000;--fg:#fff;--panel-max:460px;--muted:#8c8c8c;--accent:#2a9df4;--border:rgba(255, 255, 255, 0.08);--layer-h:40px;--tab-bg:#1a1a1a;--tab-active:#2a9df4}*{box-sizing:border-box}body,html{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'Courier New',monospace}body{padding:16px;display:flex;gap:16px;align-items:flex-start;min-height:100vh}.container{display:flex;gap:16px;width:100%;height:100%}.controls-panel{flex:0 0 var(--panel-max);max-width:var(--panel-max);min-width:320px;padding-right:10px;overflow-y:auto;height:100%;scrollbar-width:thin;scrollbar-color:var(--muted) var(--bg);display:flex;flex-direction:column}.controls-panel h1{font-size:18px;margin:0 0 4px 0;text-align:center;letter-spacing:-.5px}.muted{color:var(--muted);font-size:12px;margin-bottom:12px;display:block;text-align:center}.tab-toggle-container{display:flex;gap:4px;margin:10px 0;background:#111;padding:4px;border:1px solid var(--border);border-radius:4px}.tab-btn{flex:1;background:0 0;color:var(--muted);border:none;padding:8px;cursor:pointer;font-size:11px;text-transform:uppercase;font-family:inherit;transition:.2s}.tab-btn.active{background:var(--tab-active);color:#000;font-weight:700}.tab-content{display:none;flex-direction:column;gap:10px}.tab-content.active{display:flex}.drag-layer{background:#111;border:1px solid var(--border);padding:8px 12px;margin-bottom:6px;cursor:grab;display:flex;justify-content:space-between;align-items:center;user-select:none;font-size:13px;border-radius:4px}.drag-layer:active{cursor:grabbing;background:#222;border-color:var(--accent)}.drag-layer.dragging{opacity:.5}.drag-handle{color:var(--muted);margin-right:10px}.drag-controls{display:flex;align-items:center;gap:10px}.drag-toggle{cursor:pointer;accent-color:var(--accent)}details{border:1px solid var(--border);margin-bottom:8px;padding:6px;border-radius:4px;background:#0a0a0a}summary{cursor:pointer;font-weight:700;margin:0 0 6px 0;outline:0;user-select:none;font-size:13px}summary:hover{color:var(--accent)}.control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;min-height:28px}.control-row label{flex:0 0 120px;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px}input[type=range]{flex:1;accent-color:var(--accent);cursor:pointer}.control-value{width:60px;padding:2px 4px;text-align:right;background:#000;color:var(--fg);border:1px solid var(--border);font-family:monospace;font-size:11px}select.control-value{flex:1;min-width:120px;padding:4px}.row-buttons{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}button{background:#111;color:var(--fg);border:1px solid var(--border);padding:8px 12px;cursor:pointer;font-family:monospace;font-size:12px;transition:all .2s}button:hover:not(:disabled){background:var(--accent);color:#000;border-color:var(--accent)}button:disabled{opacity:.5;cursor:not-allowed}button.small-btn{padding:4px 8px;font-size:10px}.preview-column{flex:1 1 auto;min-width:320px;display:flex;flex-direction:column;gap:12px;height:100%;overflow:hidden}.preview-top{display:flex;align-items:center;justify-content:space-between;gap:12px}.preview-container{position:relative;border:1px solid var(--border);background:repeating-linear-gradient(45deg,#111 0,#111 10px,#0e0e0e 10px,#0e0e0e 20px);overflow:hidden;flex:1;display:flex;align-items:center;justify-content:center;min-height:300px}canvas{display:block;width:100%;height:100%;object-fit:contain;box-shadow:0 0 20px rgba(0,0,0,.5)}.overlay-original{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:10;transition:opacity .2s ease}.overlay-original canvas{width:100%;height:100%;object-fit:contain;opacity:0}.overlay-original.show canvas{opacity:1}#caPin{width:12px;height:12px;background:var(--accent);border:2px solid #fff;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);cursor:crosshair;z-index:20;box-shadow:0 0 5px #000;display:none}#caPin.active{display:block}#caPin::after{content:'';position:absolute;top:50%;left:50%;width:40px;height:40px;border:1px dashed rgba(255,255,255,.3);transform:translate(-50%,-50%);border-radius:50%;pointer-events:none}.layer-preview-window{border:1px solid var(--border);background:#050505;padding:8px;height:160px;flex:0 0 160px;overflow:hidden}.layer-grid{display:flex;gap:4px;height:100%}.layer-item{border:1px solid var(--border);flex:1;display:flex;flex-direction:column;background:#000;cursor:pointer;transition:border-color .2s;position:relative;min-width:60px}.layer-item:hover{border-color:var(--muted)}.layer-item.active{border-color:var(--accent)}.layer-title{color:var(--muted);font-size:9px;text-transform:uppercase;text-align:center;padding-top:4px;height:24px;line-height:1.2;word-wrap:break-word;padding:2px}.layer-canvas{width:100%;flex:1;background:#111;border-top:1px solid #222}.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.9);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s;z-index:3000}.modal-overlay.show{opacity:1;pointer-events:auto}.modal{background:#111;border:1px solid var(--border);padding:20px;max-width:90vw;max-height:90vh;overflow:auto;box-shadow:0 0 50px rgba(0,0,0,.8)}#loading{position:fixed;top:10px;right:10px;background:var(--accent);color:#000;padding:4px 8px;font-size:11px;font-weight:700;display:none;z-index:4000}.upscale-control{display:flex;align-items:center;gap:8px;font-size:11px;border:1px solid var(--border);padding:4px 8px;background:#0a0a0a;border-radius:4px}.upscale-input{width:40px;background:#000;border:1px solid var(--border);color:var(--fg);padding:2px;text-align:center;font-family:monospace}.lock-switch{display:flex;align-items:center;gap:6px;font-size:11px;cursor:pointer;user-select:none;margin-right:12px;border-right:1px solid var(--border);padding-right:12px}.lock-checkbox{accent-color:var(--accent);cursor:pointer}.json-btn{background:#222;border:1px solid var(--border);color:var(--accent);font-size:10px;padding:4px 8px;cursor:pointer;margin-top:4px;width:100%;text-align:center}.json-btn:hover{background:var(--accent);color:#000}@media (max-width:900px){body{padding:10px;flex-direction:column}.container{flex-direction:column}.controls-panel{width:100%;max-width:none;flex:none;height:auto;max-height:40vh}.preview-column{width:100%;height:50vh}}</style></head><body><div id="loading">PROCESSING GPU...</div><div class="container"><div class="controls-panel"><h1>DIGITAL GRAIN [GPU]</h1><span class="muted">WebGL2 Accelerated Pipeline</span><div style="margin:10px 0;border:1px dashed var(--border);padding:10px;text-align:center"><label for="imageUpload" style="cursor:pointer;display:block"><span style="font-size:24px;display:block;margin-bottom:5px">ðŸ“‚</span> <span style="font-size:12px;color:var(--accent)">CLICK TO LOAD IMAGE</span></label> <input id="imageUpload" type="file" accept="image/*" style="display:none"><div style="display:grid;grid-template-columns:1fr 1fr;gap:5px;margin-top:5px"><button class="json-btn" id="downloadJsonBtn">DOWNLOAD .JSON</button> <button class="json-btn" id="uploadJsonTrigger">UPLOAD .JSON</button> <input id="jsonUpload" type="file" accept=".json" style="display:none"></div></div><div class="tab-toggle-container"><button class="tab-btn active" data-tab="tab-controls">Controls</button> <button class="tab-btn" data-tab="tab-layers">Render Layer Order</button></div><div id="tab-controls" class="tab-content active"><details open><summary>Noise Basics</summary><div class="control-row"><label>Noise Strength</label> <input id="strength" type="range" min="0" max="150" step="0.1" value="40"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Noise Type</label> <select id="noiseType" class="control-value"><option value="1" selected="selected">Grayscale</option><option value="0">Color</option><option value="2">Blend (Sat)</option></select></div><div class="control-row"><label>Sat Strength</label> <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sat Impact</label> <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details open><summary>Shape & Blur</summary><div class="control-row"><label>Scale (Size)</label> <input id="noiseSize" type="range" min="0" max="10" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Blurriness</label> <input id="blurriness" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div></details><details open><summary>Blend & Opacity</summary><div class="control-row"><label>Blend Mode</label> <select id="blendMode" class="control-value"><option value="0">Normal</option><option value="1" selected="selected">Overlay</option><option value="2">Screen</option><option value="3">Multiply</option><option value="4">Add</option><option value="5">Difference</option></select></div><div class="control-row"><label>Opacity</label> <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div></details><details open><summary>Luminance Masking</summary><div class="control-row"><label>Shadows</label> <input id="enableShadows" type="checkbox" checked="checked"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>S. Threshold</label> <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>S. Fade</label> <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="height:10px"></div><div class="control-row"><label>Highlights</label> <input id="enableHighlights" type="checkbox" checked="checked"> <label style="color:var(--muted);margin-left:auto">Enable</label></div><div class="control-row"><label>H. Threshold</label> <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>H. Fade</label> <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Alpha Channel</summary><div class="control-row"><label>Ignore Alpha</label> <input id="ignoreAlphaToggle" type="checkbox" checked="checked"></div><div class="control-row"><label>Strength</label> <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Adjustments</summary><div class="control-row"><label>Brightness</label> <input id="brightness" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast</label> <input id="contrast" type="range" min="-100" max="200" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Saturation</label> <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Warmth</label> <input id="warmth" type="range" min="-500" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpening</label> <input id="sharpen" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>HDR Emulation</summary><div class="control-row"><label>Tolerance</label> <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Amount</label> <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Chromatic Aberration</summary><div class="control-row"><label>Amount</label> <input id="aberrationAmount" type="range" min="0" max="1500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Clear Radius</label> <input id="caRadius" type="range" min="0" max="1000" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Radius Falloff</label> <input id="caFalloff" type="range" min="0" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Blur</label> <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div style="text-align:right;margin-top:5px"><button id="resetCenterBtn" class="small-btn">RESET CENTER</button></div></details><details><summary>Dithering</summary><div class="control-row"><label>Enable</label> <input id="ditherEnable" type="checkbox"></div><div class="control-row"><label>Bit Depth</label> <input id="ditherBitDepth" type="range" min="1" max="8" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Palette Size</label> <input id="ditherPaletteSize" type="range" min="2" max="256" step="1" value="16"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Dither Strength</label> <input id="ditherStrength" type="range" min="0" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Scale</label> <input id="ditherScale" type="range" min="1" max="16" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Dither Type</label> <select id="ditherType" class="control-value"><option value="0" selected="selected">Bayer (Ordered)</option><option value="1">Noise (Random)</option></select></div></details><details><summary>Corruption</summary><div class="control-row"><label>Enable</label> <input id="corruptionEnable" type="checkbox"></div><div class="control-row"><label>Iterations</label> <input id="corruptionIterations" type="range" min="0" max="500" step="1" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Algorithm</label> <select id="corruptionAlgorithm" class="control-value"><option value="0" selected="selected">JPEG Blocks</option><option value="1">Pixelation</option><option value="2">Color Bleed</option></select></div><div class="control-row"><label>Resolution Scale</label> <input id="corruptionResScale" type="range" min="1" max="100" step="1" value="50"> <input type="text" class="control-value" readonly="readonly"></div></details><details><summary>Cell Shading</summary><div class="control-row"><label>Enable</label> <input id="cellEnable" type="checkbox"></div><div class="control-row"><label>Shading Levels</label> <input id="cellLevels" type="range" min="2" max="12" step="1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Contrast Bias</label> <input id="cellBias" type="range" min="-1" max="1" step="0.01" value="0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Gamma Curve</label> <input id="cellGamma" type="range" min="0.5" max="2.2" step="0.01" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Quantize Mode</label> <select id="cellQuantMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option><option value="2">HSV Value</option></select></div><div class="control-row"><label>Band Mapping</label> <select id="cellBandMap" class="control-value"><option value="0" selected="selected">Linear</option><option value="1">Smoothstep</option><option value="2">Posterize</option></select></div><div style="height:5px"></div><div class="control-row"><label>Edges Enable</label> <input id="cellEdgeEnable" type="checkbox"></div><div class="control-row"><label>Edge Strength</label> <input id="cellEdgeStr" type="range" min="0" max="1" step="0.01" value="0.8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Thickness</label> <input id="cellEdgeThick" type="range" min="0.5" max="3" step="0.1" value="1.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Edge Method</label> <select id="cellEdgeMethod" class="control-value"><option value="0">None</option><option value="1" selected="selected">Sobel</option><option value="2">Laplacian</option></select></div><div class="control-row"><label>Color Preserve</label> <input id="cellColorPreserve" type="checkbox"> <label style="color:var(--muted);margin-left:auto">Quant Luma Only</label></div></details><details><summary>Halftoning</summary><div class="control-row"><label>Enable</label> <input id="halftoneEnable" type="checkbox"></div><div class="control-row"><label>Dot Size</label> <input id="halftoneSize" type="range" min="1" max="12" step="0.1" value="4"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Intensity</label> <input id="halftoneIntensity" type="range" min="0" max="1" step="0.01" value="0.8"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Sharpness</label> <input id="halftoneSharpness" type="range" min="0" max="1" step="0.01" value="0.5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Pattern Type</label> <select id="halftonePattern" class="control-value"><option value="0" selected="selected">Circular</option><option value="1">Line</option><option value="2">Cross</option><option value="3">Diamond</option></select></div><div class="control-row"><label>Color Mode</label> <select id="halftoneColorMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option><option value="2">CMY</option><option value="3">CMYK</option></select></div><div class="control-row"><label>Sampling</label> <select id="halftoneSample" class="control-value"><option value="0" selected="selected">Center</option><option value="1">Average</option><option value="2">Rotated Grid</option></select></div><div class="control-row"><label>Grayscale</label> <input id="halftoneGray" type="checkbox"></div><div class="control-row"><label>Screen Lock</label> <input id="halftoneScreenLock" type="checkbox" checked="checked"></div><div class="control-row"><label>Invert</label> <input id="halftoneInvert" type="checkbox"></div></details><details><summary>Bilateral Filter</summary><div class="control-row"><label>Enable</label> <input id="bilateralEnable" type="checkbox"></div><div class="control-row"><label>Radius</label> <input id="bilateralRadius" type="range" min="1" max="30" step="1" value="5"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Color Sigma</label> <input id="bilateralColorSig" type="range" min="0.01" max="1.0" step="0.01" value="0.1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Spatial Sigma</label> <input id="bilateralSpatialSig" type="range" min="0.5" max="15.0" step="0.1" value="2.0"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>Iterations</label> <input id="bilateralIter" type="range" min="1" max="20" step="1" value="1"> <input type="text" class="control-value" readonly="readonly"></div><div class="control-row"><label>High Precision</label> <input id="bilateralHighPrec" type="checkbox" checked="checked"></div><div class="control-row"><label>Kernel Type</label> <select id="bilateralKernel" class="control-value"><option value="0" selected="selected">Gaussian</option><option value="1">Box</option></select></div><div class="control-row"><label>Edge Preservation</label> <select id="bilateralEdgeMode" class="control-value"><option value="0" selected="selected">Luminance</option><option value="1">RGB</option></select></div></details><div class="row-buttons"><button id="downloadBtn" disabled="disabled">DOWNLOAD FULL RES</button> <button id="compareBtn" disabled="disabled">COMPARE / EXPORT</button></div></div><div id="tab-layers" class="tab-content"><div style="font-size:11px;color:var(--muted);margin-bottom:10px">Drag to reorder render pipeline:</div><div id="layer-drag-list"></div></div></div><div class="preview-column"><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Main Preview</h3><div style="display:flex;align-items:center"><div class="upscale-control" style="margin-right:8px" title="Zoom level when hovering over preview"><span>HOVER ZOOM</span> <input id="hoverZoomSlider" type="range" min="1" max="8" step="0.1" value="1" style="width:60px;accent-color:var(--accent)"> <span id="hoverZoomValue" style="min-width:28px;text-align:center">1x</span></div><button id="lensToggleBtn" class="small-btn" style="margin-right:12px;padding:4px 8px;font-size:9px" title="Toggle between Full zoom and Lens zoom">FULL</button> <label class="lock-switch" title="Lock Preview to prevent Original Image overlay"><input type="checkbox" id="previewLock" class="lock-checkbox"> <span>LOCK PREVIEW</span></label><div class="upscale-control"><span>UPSCALE (x)</span> <input id="upscaleInput" class="upscale-input" type="text" value="1" min="1" max="10"></div></div></div><div class="preview-container" id="previewContainer"><canvas id="displayCanvas"></canvas><div id="caPin"></div><div class="overlay-original" id="overlayOriginal"><canvas id="overlayCanvas"></canvas></div><div id="zoomResIndicator" style="position:absolute;bottom:8px;left:8px;background:rgba(0,0,0,.8);color:#0f0;padding:4px 8px;font-size:10px;font-family:monospace;z-index:20;display:none;border:1px solid #0f0"></div><div id="zoomLens" style="position:absolute;width:180px;height:180px;border-radius:50%;border:2px solid var(--accent);overflow:hidden;pointer-events:none;display:none;z-index:25;box-shadow:0 0 20px rgba(0,0,0,.8)"><canvas id="lensCanvas" style="position:absolute;top:0;left:0"></canvas></div></div><div class="preview-top"><h3 style="margin:0;font-size:14px;text-transform:uppercase;letter-spacing:1px">Layer Breakdown</h3><div style="font-size:10px;color:var(--muted)">Click to view</div></div><div class="layer-preview-window"><div class="layer-grid" id="layerGrid"></div></div></div></div><div id="compareModal" class="modal-overlay"><div class="modal"><h2 style="margin-top:0">Comparison & Export</h2><div style="display:flex;gap:20px;margin-bottom:20px;justify-content:center;flex-wrap:wrap"><div><div class="muted">Original</div><canvas id="compareOriginal" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div><div><div class="muted">Processed</div><canvas id="compareProcessed" style="max-height:40vh;max-width:40vw;border:1px solid #333"></canvas></div></div><div style="text-align:center;display:flex;gap:10px;justify-content:center;flex-wrap:wrap"><button id="exportSideBySide">Export Side-by-Side</button> <button id="exportStacked">Export Stacked</button> <button id="closeCompare">Close</button></div></div></div><script type="x-shader/x-vertex" id="vs-quad">#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-adjust">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Sharpening
    if (u_sharp > 0.0) {
        vec4 sum = vec4(0.0);
        sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x,  u_step.y));
        vec4 edge = c - (sum * 0.25);
        rgb += edge.rgb * (u_sharp / 10.0); 
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}</script><script type="x-shader/x-fragment" id="fs-mask">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; 
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.299,0.587,0.114));
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-noise">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; 
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; 

float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec2 pos = v_uv * u_origRes; 
    vec2 cell = floor(pos / max(1.0, u_scale));
    
    vec3 n;
    if (u_type == 1) { 
        float r = hash12(cell + u_seed);
        n = vec3(r);
    } else { 
        float r = hash12(cell + u_seed);
        float g = hash12(cell + u_seed + 1.23);
        float b = hash12(cell + u_seed + 2.45);
        n = vec3(r, g, b);
    }
    
    outColor = vec4(n, 1.0);
}</script><script type="x-shader/x-fragment" id="fs-blur">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; 
uniform float u_rad;

void main() {
    vec4 color = vec4(0.0);
    float total = 0.0;
    for(float i = -4.0; i <= 4.0; i++) {
        float weight = exp(-(i*i) / (2.0 * 2.0)); 
        vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad);
        color += s * weight;
        total += weight;
    }
    outColor = color / total;
}</script><script type="x-shader/x-fragment" id="fs-composite">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; 
uniform int u_nType; 
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; 
uniform float u_ignAstr;

float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); 
    vec3 n = nc.rgb;
    vec3 res;
    vec3 base = bc.rgb;
    
    if (u_nType == 2) {
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        float lum = dot(base, vec3(0.299,0.587,0.114));
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * (u_str/50.0)); 
        res = satColor;
    } else {
        vec3 noiseLayer = nc.rgb;
        if (u_mode == 0) { 
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { 
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { 
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { 
            res = base * noiseLayer;
        } else if (u_mode == 4) { 
            res = base + noiseLayer;
        } else if (u_mode == 5) { 
            res = abs(base - noiseLayer);
        }
        
        float maskVal = mc.r; 
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); 
        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}</script><script type="x-shader/x-fragment" id="fs-chroma">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

void main() {
    if (u_amt <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    
    // Calculate clear zone mask
    float clearMask = 0.0;
    if (u_radius > 0.0 || u_falloff > 0.0) {
        clearMask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    }
    
    // Calculate aberration strength based on distance from center
    float str = dist * dist * (u_amt / 1000.0); 
    str *= (1.0 - clearMask); 
    
    vec4 result = vec4(0.0);
    
    if (u_blur > 0.0) {
        float totalWeight = 0.0;
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * u_blur * 0.002; 
            float w = exp(-(i*i)/2.0); 
            
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t)).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5)).g; 
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t)).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}</script><script type="x-shader/x-fragment" id="fs-copy">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_channel; 

void main() {
    vec4 c = texture(u_tex, v_uv);
    if (u_channel == 1) outColor = vec4(c.rrr, 1.0);
    else if (u_channel == 2) outColor = vec4(c.ggg, 1.0);
    else if (u_channel == 3) outColor = vec4(c.bbb, 1.0);
    else outColor = c;
}</script><script type="x-shader/x-fragment" id="fs-dither">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

// 8x8 Bayer matrix (normalized to 0-1)
float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    // Bayer 8x8 pattern values
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

// Hash for noise dithering
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    
    // Calculate scaled position for dither pattern
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    // Get threshold value based on dither type
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    // Calculate quantization levels
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    // Apply dithering with strength
    vec3 dithered = col.rgb + threshold * (u_strength / 100.0) * (1.0 / levels);
    
    // Quantize to bit depth
    dithered = floor(dithered * levels + 0.5) / levels;
    
    // Apply palette quantization
    dithered = floor(dithered * u_paletteSize + 0.5) / u_paletteSize;
    
    outColor = vec4(clamp(dithered, 0.0, 1.0), col.a);
}</script><script type="x-shader/x-fragment" id="fs-corruption">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_algorithm; // 0=jpeg blocks, 1=pixelation, 2=color bleed
uniform float u_resScale; // 1-100 (lower = more corruption)
uniform vec2 u_res;
uniform float u_iteration; // current iteration for variation

void main() {
    // Calculate block size based on resolution scale (inverted: lower scale = bigger blocks)
    float blockSize = max(2.0, (100.0 - u_resScale) / 5.0 + 1.0);
    
    vec4 col;
    
    if (u_algorithm == 0) {
        // JPEG-like block artifacts
        vec2 blockPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        vec2 blockCenter = blockPos + (blockSize * 0.5) / u_res;
        
        // Sample from block center with some offset for artifact feel
        vec2 offset = (v_uv - blockPos) * u_res / blockSize;
        offset = floor(offset * 2.0) / 2.0 * blockSize / u_res;
        
        col = texture(u_tex, blockPos + offset);
        
        // Add slight color shifting at block edges
        vec2 edgeDist = abs(fract(v_uv * u_res / blockSize) - 0.5);
        float edge = smoothstep(0.3, 0.5, max(edgeDist.x, edgeDist.y));
        col.rgb = mix(col.rgb, col.rgb * 0.95, edge * 0.3);
        
    } else if (u_algorithm == 1) {
        // Pixelation - simple downscale/upscale
        vec2 pixelPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        col = texture(u_tex, pixelPos + (blockSize * 0.5) / u_res);
        
    } else {
        // Color bleed - horizontal color smearing
        float bleedAmount = blockSize / u_res.x;
        vec4 left = texture(u_tex, v_uv - vec2(bleedAmount, 0.0));
        vec4 center = texture(u_tex, v_uv);
        vec4 right = texture(u_tex, v_uv + vec2(bleedAmount, 0.0));
        
        // Shift color channels
        col.r = mix(center.r, right.r, 0.3);
        col.g = center.g;
        col.b = mix(center.b, left.b, 0.3);
        col.a = center.a;
    }
    
    outColor = col;
}</script><script type="x-shader/x-fragment" id="fs-cell">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_levels;         // 2-12
uniform float u_bias;         // -1.0 to 1.0 (contrast bias)
uniform float u_gamma;        // 0.5 to 2.2
uniform int u_quantMode;      // 0=Luma, 1=RGB, 2=HSV
uniform int u_bandMap;        // 0=Linear, 1=Smooth, 2=Poster
uniform int u_edgeMethod;     // 0=None, 1=Sobel, 2=Laplc
uniform float u_edgeStr;      // 0-1
uniform float u_edgeThick;    // 0.5-3.0
uniform int u_colorPreserve;  // 0/1 bool
uniform int u_edgeEnable;     // 0/1 bool

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float getLuma(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

float quantize(float val, int levels, float bias, float gamma) {
    // Apply bias
    val = clamp(val + bias, 0.0, 1.0);
    
    // Apply gamma
    val = pow(val, gamma);
    
    // Quantize
    float fLevels = float(levels);
    float q = floor(val * fLevels) / (fLevels - 1.0);
    
    // Map output based on band mode
    if (u_bandMap == 1) { // Smooth
        q = smoothstep(0.0, 1.0, q);
    } else if (u_bandMap == 2) { // Posterize hard
        q = floor(val * fLevels) / fLevels; 
    }
    
    return q;
}

float sobel(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l00 = getLuma(texture(u_tex, uv + vec2(-px.x, -px.y)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l20 = getLuma(texture(u_tex, uv + vec2(px.x, -px.y)).rgb);
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l02 = getLuma(texture(u_tex, uv + vec2(-px.x, px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l22 = getLuma(texture(u_tex, uv + vec2(px.x, px.y)).rgb);
    
    float gx = l00 + 2.0*l01 + l02 - (l20 + 2.0*l21 + l22);
    float gy = l00 + 2.0*l10 + l20 - (l02 + 2.0*l12 + l22);
    
    return sqrt(gx*gx + gy*gy);
}

float laplacian(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l11 = getLuma(texture(u_tex, uv).rgb); // Center
    
    return abs(l01 + l21 + l10 + l12 - 4.0 * l11) * 2.0;
}

void main() {
    vec4 base = texture(u_tex, v_uv);
    vec3 col = base.rgb;
    
    // Apply Quantization
    vec3 res = col;
    if (u_quantMode == 0) { // Luma
        float l = getLuma(col);
        float q = quantize(l, u_levels, u_bias, u_gamma);
        if (u_colorPreserve == 1) {
            // Preserve color, only quantize lightness
            vec3 hsv = rgb2hsv(col);
            hsv.z = q;
            res = hsv2rgb(hsv);
        } else {
            res = vec3(q);
        }
    } else if (u_quantMode == 1) { // RGB
        res.r = quantize(col.r, u_levels, u_bias, u_gamma);
        res.g = quantize(col.g, u_levels, u_bias, u_gamma);
        res.b = quantize(col.b, u_levels, u_bias, u_gamma);
    } else { // HSV Value
        vec3 hsv = rgb2hsv(col);
        hsv.z = quantize(hsv.z, u_levels, u_bias, u_gamma);
        res = hsv2rgb(hsv);
    }
    
    // Apply Edges
    if (u_edgeEnable == 1 && u_edgeMethod > 0) {
        float edge = 0.0;
        if (u_edgeMethod == 1) edge = sobel(v_uv);
        else if (u_edgeMethod == 2) edge = laplacian(v_uv);
        
        edge = smoothstep(0.1, 1.0, edge * 2.0); // Boost edge visibility
        res = mix(res, vec3(0.0), edge * u_edgeStr);
    }
    
    outColor = vec4(res, base.a);
}</script><script type="x-shader/x-fragment" id="fs-halftone">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform float u_size;           // 1-12
uniform float u_intensity;      // 0-1
uniform float u_sharpness;      // 0-1
uniform int u_pattern;          // 0=Circ, 1=Line, 2=Cross, 3=Diamond
uniform int u_colorMode;        // 0=Luma, 1=RGB, 2=CMY, 3=CMYK
uniform int u_sample;           // 0=Center, 1=Avg
uniform int u_gray;             // Bool
uniform int u_lock;             // Bool
uniform int u_invert;           // Bool

float getPattern(vec2 uv, float angle) {
    float s = sin(angle), c = cos(angle);
    vec2 p = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y) * u_res / u_size; // Map to pattern space
    vec2 grid = fract(p) - 0.5;
    
    float d = 0.0;
    if (u_pattern == 0) { // Circle
        d = length(grid) * 2.0; // 0-1 range center to corner
    } else if (u_pattern == 1) { // Line
        d = abs(grid.y) * 2.0;
    } else if (u_pattern == 2) { // Cross
        d = min(abs(grid.x), abs(grid.y)) * 2.0;
    } else { // Diamond
        d = (abs(grid.x) + abs(grid.y));
    }
    
    return d; // 0 at center/peak, 1 at edge
}

void main() {
    float angle = 0.0; // Default angle
    if (u_sample == 2) angle = 0.785; // 45 deg for rotated
    
    vec2 sampleUV = v_uv;
    if (u_lock == 0) {
        // Pattern follows image (UV space), scale by res ratio to keep square dots
        // Actually simpler: just rely on u_size scaling against u_res
    }
    
    vec4 col = texture(u_tex, v_uv);
    
    // Halftone Logic
    vec3 outRGB = vec3(0.0);
    
    if (u_colorMode == 0) { // Luminance
        float l = dot(col.rgb, vec3(0.299, 0.587, 0.114));
        float pat = getPattern(v_uv, 0.785); // 45 degree default for mono
        
        // Threshold
        // Pattern goes 0(black) to 1(white). Luma 0(black) to 1(white).
        // Standard HT: if luma > pattern -> white. 
        // With intensity: mix pattern with luma.
        
        // Soft edge based on sharpness
        float thresh = 1.0 - l * u_intensity; // Invert luma for pattern comparison
        float softness = 1.0 - u_sharpness;
        float val = smoothstep(thresh - softness, thresh + softness, pat);
        
        if (u_invert == 1) val = 1.0 - val;
        outRGB = vec3(val);
        
    } else if (u_colorMode == 1) { // RGB
        // Separate angles for R, G, B
        float pR = getPattern(v_uv, 0.26); // ~15 deg
        float pG = getPattern(v_uv, 1.30); // ~75 deg
        float pB = getPattern(v_uv, 0.0);  // 0 deg
        
        float soft = 1.0 - u_sharpness;
        
        float r = smoothstep((1.0 - col.r) - soft, (1.0 - col.r) + soft, pR);
        float g = smoothstep((1.0 - col.g) - soft, (1.0 - col.g) + soft, pG);
        float b = smoothstep((1.0 - col.b) - soft, (1.0 - col.b) + soft, pB);
        
        outRGB = vec3(r, g, b);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
        
    } else { // CMY / CMYK
        // Simple RGB -> CMY
        vec3 cmy = 1.0 - col.rgb;
        float k = 0.0;
        if (u_colorMode == 3) { // CMYK
            k = min(min(cmy.x, cmy.y), cmy.z);
            cmy = (cmy - k) / (1.0 - k);
        }
        
        // Angles: C=15, M=75, Y=0, K=45
        float pC = getPattern(v_uv, 0.26);
        float pM = getPattern(v_uv, 1.30);
        float pY = getPattern(v_uv, 0.0);
        float pK = getPattern(v_uv, 0.785);
        
        float soft = 1.0 - u_sharpness;
        
        // Halftone each channel (0=white, 1=ink). 
        // If pattern < ink_amount -> ink. 
        // Pattern 0(center) to 1(edge). Ink 0(none) to 1(full).
        // If pattern < cmy.r => ink.
        // Invert comparison for white checks?
        // Let's use: if pattern > (1.0 - ink) -> ink ?? No.
        
        // Standard: dot grows from center (0). so if pattern < ink -> ink.
        float hC = 1.0 - smoothstep(cmy.x - soft, cmy.x + soft, pC);
        float hM = 1.0 - smoothstep(cmy.y - soft, cmy.y + soft, pM);
        float hY = 1.0 - smoothstep(cmy.z - soft, cmy.z + soft, pY);
        float hK = 1.0 - smoothstep(k - soft, k + soft, pK);
        
        // Combine CMYK -> RGB
        // white - ink
        vec3 resCMY = vec3(hC, hM, hY);
        if (u_colorMode == 3) resCMY += vec3(hK);
        
        outRGB = 1.0 - clamp(resCMY, 0.0, 1.0);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
    }
    
    if (u_gray == 1) {
        float l = dot(outRGB, vec3(0.299, 0.587, 0.114));
        outRGB = vec3(l);
    }
    
    outColor = vec4(outRGB, col.a);
}</script><script type="x-shader/x-fragment" id="fs-bilateral">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_radius;        // 1-30
uniform float u_sigmaCol;    // 0.01 - 1.0
uniform float u_sigmaSpace;  // 0.5 - 15.0
uniform int u_kernel;        // 0=Gauss, 1=Box
uniform int u_edgeMode;      // 0=Luma, 1=RGB

float getDist(vec3 c1, vec3 c2) {
    if (u_edgeMode == 0) {
        float l1 = dot(c1, vec3(0.299, 0.587, 0.114));
        float l2 = dot(c2, vec3(0.299, 0.587, 0.114));
        return abs(l1 - l2);
    } else {
        return length(c1 - c2);
    }
}

void main() {
    vec4 centerCol = texture(u_tex, v_uv);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;
    
    // Separable optimization not easy for true bilateral without ping-pong
    // We will do a full kernel loop but skip somewhat to save perf if radius is high?
    // No, standard loop.
    
    int r = u_radius;
    float fs = u_sigmaSpace;
    float fc = u_sigmaCol;
    
    for (int x = -r; x <= r; x++) {
        for (int y = -r; y <= r; y++) {
            vec2 offset = vec2(float(x), float(y));
            vec2 uv = v_uv + offset / u_res;
            
            vec3 samp = texture(u_tex, uv).rgb;
            
            float spaceDistSq = dot(offset, offset);
            float colorDist = getDist(centerCol.rgb, samp);
            
            float wSpace = 1.0;
            if (u_kernel == 0) wSpace = exp(-spaceDistSq / (2.0 * fs * fs));
            
            float wColor = exp(-(colorDist * colorDist) / (2.0 * fc * fc));
            
            float w = wSpace * wColor;
            
            sum += samp * w;
            weightSum += w;
        }
    }
    
    outColor = vec4(sum / weightSum, centerCol.a);
}</script><script>const state={gl:null,canvas:null,programs:{},textures:{},fbos:{},pingPong:[null,null],thumbnailFBO:null,baseImage:null,width:1,height:1,renderWidth:1,renderHeight:1,fboWidth:0,fboHeight:0,busy:!1,upscaleFactor:1,renderOrder:["noise","adjust","hdr","ca","cell","halftone","bilateral","dither","corruption"],activeLayerPreview:null,caCenter:{x:.5,y:.5},isDraggingPin:!1,layerTextures:{},layerVisibility:{noise:!0,adjust:!0,hdr:!0,ca:!0,cell:!0,halftone:!0,bilateral:!0,dither:!0,corruption:!0},pinIdleTimer:null,isPreviewLocked:!1},UI={},LAYERS={noise:{name:"Noise Group",color:"#fff"},adjust:{name:"Adjustments",color:"#fff"},hdr:{name:"HDR Emulation",color:"#fff"},ca:{name:"Chromatic Aberration",color:"#fff"},cell:{name:"Cell Shading",color:"#fff"},halftone:{name:"Halftoning",color:"#fff"},bilateral:{name:"Bilateral Filter",color:"#fff"},dither:{name:"Dithering",color:"#fff"},corruption:{name:"Corruption",color:"#fff"},shadows:{name:"Shadows Mask",color:"#fff"},highlights:{name:"Highlights Mask",color:"#fff"}};function downloadPreset(){const e={values:{},checks:{},selects:{},renderOrder:state.renderOrder,layerVisibility:state.layerVisibility,upscaleFactor:state.upscaleFactor,caCenter:state.caCenter};document.querySelectorAll("input[type=range]").forEach(t=>e.values[t.id]=t.value),document.querySelectorAll("input[type=text].control-value").forEach(e=>{}),document.querySelectorAll("input[type=checkbox]").forEach(t=>{t.id.startsWith("drag-")||"previewLock"===t.id||(e.checks[t.id]=t.checked)}),document.querySelectorAll("select").forEach(t=>e.selects[t.id]=t.value);const t=new Blob([JSON.stringify(e,null,2)],{type:"application/json"}),a=URL.createObjectURL(t),r=document.createElement("a");r.href=a,r.download="grain-settings.json",r.click()}function uploadPreset(e){const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=e=>{try{const t=JSON.parse(e.target.result);t.values&&Object.keys(t.values).forEach(e=>{const a=document.getElementById(e);a&&(a.value=t.values[e],a.nextElementSibling&&(a.nextElementSibling.value=t.values[e]))}),t.checks&&Object.keys(t.checks).forEach(e=>{const a=document.getElementById(e);a&&(a.checked=t.checks[e])}),t.selects&&Object.keys(t.selects).forEach(e=>{const a=document.getElementById(e);a&&(a.value=t.selects[e])}),t.renderOrder&&(state.renderOrder=t.renderOrder,setupDragLayerList()),t.layerVisibility&&(state.layerVisibility=t.layerVisibility,setupDragLayerList()),t.upscaleFactor&&(state.upscaleFactor=t.upscaleFactor,UI.upscaleInput.value=t.upscaleFactor),t.caCenter&&(state.caCenter=t.caCenter,updatePinPosition()),requestRender()}catch(e){alert("Error loading JSON: "+e)}},a.readAsText(t)}function setupDragLayerList(){const e=document.getElementById("layer-drag-list");e.innerHTML="",state.renderOrder.forEach((t,a)=>{const r=document.createElement("div");r.className="drag-layer",r.draggable=!0,r.dataset.key=t;const o=state.layerVisibility[t]?"checked":"";r.innerHTML=`\n            <div style="display:flex; align-items:center;">\n                <span class="drag-handle">â˜°</span> \n                <input type="checkbox" class="drag-toggle" data-key="${t}" ${o}>\n            </div>\n            <span>${LAYERS[t].name}</span>\n        `,r.querySelector("input").addEventListener("change",e=>{state.layerVisibility[t]=e.target.checked,requestRender()}),r.addEventListener("dragstart",e=>{e.dataTransfer.setData("text/plain",a),r.classList.add("dragging")}),r.addEventListener("dragend",()=>r.classList.remove("dragging")),r.addEventListener("dragover",e=>e.preventDefault()),r.addEventListener("drop",e=>{e.preventDefault();const t=parseInt(e.dataTransfer.getData("text/plain")),r=a;if(t===r)return;const o=state.renderOrder.splice(t,1)[0];state.renderOrder.splice(r,0,o),setupDragLayerList(),setupLayerGridDOM(),requestRender()}),e.appendChild(r)})}window.addEventListener("DOMContentLoaded",async()=>{let e;["imageUpload","displayCanvas","overlayCanvas","overlayOriginal","strength","noiseType","satStrength","satPerNoise","noiseSize","blurriness","blendMode","opacity","enableShadows","shadowThreshold","shadowFade","enableHighlights","highlightThreshold","highlightFade","brightness","contrast","saturationAdj","warmth","sharpen","hdrTolerance","hdrAmount","ignoreAlphaToggle","ignoreAlphaStrength","aberrationAmount","aberrationBlur","caRadius","caFalloff","resetCenterBtn","ditherEnable","ditherBitDepth","ditherPaletteSize","ditherStrength","ditherScale","ditherType","corruptionEnable","corruptionIterations","corruptionAlgorithm","corruptionResScale","cellEnable","cellLevels","cellBias","cellGamma","cellQuantMode","cellBandMap","cellEdgeEnable","cellEdgeStr","cellEdgeThick","cellEdgeMethod","cellColorPreserve","halftoneEnable","halftoneSize","halftoneIntensity","halftoneSharpness","halftonePattern","halftoneColorMode","halftoneSample","halftoneGray","halftoneScreenLock","halftoneInvert","bilateralEnable","bilateralRadius","bilateralColorSig","bilateralSpatialSig","bilateralIter","bilateralHighPrec","bilateralKernel","bilateralEdgeMode","downloadBtn","compareBtn","loading","layerGrid","compareOriginal","compareProcessed","closeCompare","exportSideBySide","exportStacked","previewContainer","caPin","upscaleInput","previewLock","hoverZoomSlider","hoverZoomValue","zoomResIndicator","lensToggleBtn","zoomLens","lensCanvas","downloadJsonBtn","uploadJsonTrigger","jsonUpload"].forEach(e=>UI[e]=document.getElementById(e)),document.querySelectorAll(".tab-btn").forEach(e=>{e.addEventListener("click",e=>{document.querySelectorAll(".tab-btn").forEach(e=>e.classList.remove("active")),document.querySelectorAll(".tab-content").forEach(e=>e.classList.remove("active")),e.target.classList.add("active"),document.getElementById(e.target.dataset.tab).classList.add("active")})}),setupDragLayerList(),document.querySelectorAll("input[type=range]").forEach(e=>{const t=e.nextElementSibling;if(t&&t.classList.contains("control-value")){const a=()=>t.value=e.value;e.addEventListener("input",()=>{a(),requestRender()}),a()}}),document.querySelectorAll("select, input[type=checkbox]").forEach(e=>{e.addEventListener("change",requestRender)}),UI.previewLock.addEventListener("change",e=>{state.isPreviewLocked=e.target.checked,state.isPreviewLocked&&UI.overlayOriginal.classList.remove("show")}),UI.upscaleInput.addEventListener("change",e=>{let t=parseInt(e.target.value);(isNaN(t)||t<1)&&(t=1),t>10&&(t=10),e.target.value=t,state.upscaleFactor=t,state.baseImage&&(reallocateBuffers(!1),requestRender())}),UI.resetCenterBtn.addEventListener("click",()=>{state.caCenter={x:.5,y:.5},updatePinPosition(),requestRender()}),UI.caPin.addEventListener("mousedown",e=>{state.isDraggingPin=!0,state.isPreviewLocked||UI.overlayOriginal.classList.remove("show"),clearTimeout(state.pinIdleTimer),e.preventDefault()}),window.addEventListener("mouseup",()=>{state.isDraggingPin&&(state.isDraggingPin=!1,state.isPreviewLocked||(state.pinIdleTimer=setTimeout(()=>{UI.overlayOriginal.classList.add("show")},4e3)))}),window.addEventListener("mousemove",e=>{if(!state.isDraggingPin)return;const t=UI.previewContainer.getBoundingClientRect();let a=(e.clientX-t.left)/t.width,r=1-(e.clientY-t.top)/t.height;a=Math.max(0,Math.min(1,a)),r=Math.max(0,Math.min(1,r)),state.caCenter={x:a,y:r},updatePinPosition(),requestRender()});const t=UI.previewContainer,a=UI.displayCanvas;UI.hoverZoomSlider.addEventListener("input",()=>{UI.hoverZoomValue.textContent=parseFloat(UI.hoverZoomSlider.value).toFixed(1)+"x"});let r=!1,o=!1;UI.lensToggleBtn.addEventListener("click",()=>{o=!o,UI.lensToggleBtn.textContent=o?"LENS":"FULL",UI.lensToggleBtn.style.background=o?"var(--accent)":"",UI.lensToggleBtn.style.color=o?"#000":"",i()});const s=180;UI.lensCanvas.width=s,UI.lensCanvas.height=s;const n=UI.lensCanvas.getContext("2d"),i=()=>{a.style.transform="",a.style.transformOrigin="",a.style.zIndex="",UI.zoomResIndicator.style.display="none",UI.zoomLens.style.display="none",r&&(r=!1,reallocateBuffers(!1),requestRender())},l=e=>{const l=parseFloat(UI.hoverZoomSlider.value);if(l<=1)return void i();UI.overlayOriginal.classList.remove("show"),r||(r=!0,reallocateBuffers(!0),requestRender());const c=t.getBoundingClientRect(),u=e.clientX-c.left,m=e.clientY-c.top,d=u/c.width,g=m/c.height;if(o){a.style.transform="",a.style.transformOrigin="",a.style.zIndex="",UI.zoomLens.style.display="block",UI.zoomLens.style.left=u-90+"px",UI.zoomLens.style.top=m-90+"px";const e=a.width/a.height;let t,r,o,i;e>c.width/c.height?(t=c.width,r=c.width/e,o=0,i=(c.height-r)/2):(r=c.height,t=c.height*e,o=(c.width-t)/2,i=0);const d=(u-o)/t*a.width,g=(m-i)/r*a.height,f=s/l,p=d-f/2,h=g-f/2;n.clearRect(0,0,s,s),n.drawImage(a,Math.max(0,Math.min(p,a.width-f)),Math.max(0,Math.min(h,a.height-f)),f,f,0,0,s,s)}else UI.zoomLens.style.display="none",a.style.zIndex="15",a.style.transformOrigin=`${100*d}% ${100*g}%`,a.style.transform=`scale(${l})`;const f=state.width*state.upscaleFactor,p=state.height*state.upscaleFactor,h=a.width,U=a.height,E=h>=f&&U>=p?"âœ“ FULL RES":"âš  SCALED",b=o?"LENS":"FULL";UI.zoomResIndicator.innerHTML=`Mode: ${b}<br>Source: ${f}Ã—${p}<br>Canvas: ${h}Ã—${U}<br>${E}`,UI.zoomResIndicator.style.display="block",UI.zoomResIndicator.style.color=h>=f&&U>=p?"#0f0":"#f80",UI.zoomResIndicator.style.borderColor=h>=f&&U>=p?"#0f0":"#f80"};t.addEventListener("mouseenter",t=>{parseFloat(UI.hoverZoomSlider.value)<=1&&!state.isPreviewLocked&&!state.activeLayerPreview&&UI.overlayOriginal.classList.add("show"),clearTimeout(e),l(t)}),t.addEventListener("mouseleave",()=>{UI.overlayOriginal.classList.remove("show"),clearTimeout(e),i()}),t.addEventListener("wheel",t=>{t.preventDefault(),UI.overlayOriginal.classList.remove("show");const a=UI.blendMode,r=a.options.length;let o=a.selectedIndex;o=(o+Math.sign(t.deltaY)+r)%r,a.selectedIndex=o,requestRender(),state.isPreviewLocked||(clearTimeout(e),e=setTimeout(()=>{state.activeLayerPreview||UI.overlayOriginal.classList.add("show")},2e3))},{passive:!1}),t.addEventListener("mousemove",t=>{clearTimeout(e),state.isPreviewLocked||state.activeLayerPreview||UI.overlayOriginal.classList.add("show"),l(t)}),UI.downloadJsonBtn.addEventListener("click",downloadPreset),UI.uploadJsonTrigger.addEventListener("click",()=>UI.jsonUpload.click()),UI.jsonUpload.addEventListener("change",uploadPreset),initWebGL(),UI.imageUpload.addEventListener("change",e=>{const t=e.target.files[0];if(!t)return;const a=new FileReader;a.onload=e=>{const t=new Image;t.onload=()=>loadNewImage(t),t.src=e.target.result},a.readAsDataURL(t)}),UI.downloadBtn.addEventListener("click",downloadFullRes),UI.compareBtn.addEventListener("click",openCompare),UI.closeCompare.addEventListener("click",()=>document.getElementById("compareModal").classList.remove("show")),UI.exportSideBySide.addEventListener("click",()=>exportComparison("side")),UI.exportStacked.addEventListener("click",()=>exportComparison("stack"))});let renderRequested=!1;function requestRender(){!renderRequested&&state.baseImage&&(renderRequested=!0,requestAnimationFrame(()=>{renderFrame(),renderRequested=!1}))}function initWebGL(){state.canvas=UI.displayCanvas;const e=state.canvas.getContext("webgl2",{antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!0});if(!e)return void alert("WebGL2 not supported.");e.getExtension("EXT_color_buffer_float"),e.getExtension("OES_texture_float_linear"),state.gl=e,e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),state.programs={adjust:createProgram(e,"vs-quad","fs-adjust"),mask:createProgram(e,"vs-quad","fs-mask"),noise:createProgram(e,"vs-quad","fs-noise"),blur:createProgram(e,"vs-quad","fs-blur"),composite:createProgram(e,"vs-quad","fs-composite"),chroma:createProgram(e,"vs-quad","fs-chroma"),copy:createProgram(e,"vs-quad","fs-copy"),dither:createProgram(e,"vs-quad","fs-dither"),corruption:createProgram(e,"vs-quad","fs-corruption"),cell:createProgram(e,"vs-quad","fs-cell"),halftone:createProgram(e,"vs-quad","fs-halftone"),bilateral:createProgram(e,"vs-quad","fs-bilateral")};const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,-1,1,0,1,1,-1,1,0,1,1,1,1]),e.STATIC_DRAW),Object.values(state.programs).forEach(t=>{e.useProgram(t);const a=e.getAttribLocation(t,"a_pos"),r=e.getAttribLocation(t,"a_uv");e.enableVertexAttribArray(a),e.enableVertexAttribArray(r),e.vertexAttribPointer(a,2,e.FLOAT,!1,16,0),e.vertexAttribPointer(r,2,e.FLOAT,!1,16,8)});const a=createTexture(e,null,320,180),r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0),state.thumbnailFBO={fbo:r,tex:a,w:320,h:180}}function loadNewImage(e){state.baseImage=e,state.width=e.width,state.height=e.height;const t=state.gl;state.textures.base&&(t.deleteTexture(state.textures.base),state.textures.base=null),state.textures.base=createTexture(t,e),state.fboWidth=0,state.fboHeight=0,reallocateBuffers(!1),UI.downloadBtn.disabled=!1,UI.compareBtn.disabled=!1,UI.overlayCanvas.width=e.width,UI.overlayCanvas.height=e.height,UI.overlayCanvas.getContext("2d").drawImage(e,0,0),UI.caPin.classList.add("active"),setupLayerGridDOM(),requestRender()}function reallocateBuffers(e=!1){const t=state.gl,a=t.getParameter(t.MAX_TEXTURE_SIZE);let r,o;if(e){let e=state.width*state.upscaleFactor,t=state.height*state.upscaleFactor,s=1;(e>a||t>a)&&(s=Math.min(a/e,a/t)),r=Math.round(state.width*state.upscaleFactor*s),o=Math.round(state.height*state.upscaleFactor*s),state._exportScale=s}else{const e=2048;let t=state.width*state.upscaleFactor,s=state.height*state.upscaleFactor,n=1;if((t>e||s>e)&&(n=Math.min(e/t,e/s)),r=Math.round(t*n),o=Math.round(s*n),r>a||o>a){const e=Math.min(a/r,a/o);r=Math.floor(r*e),o=Math.floor(o*e)}state._exportScale=n}if(state.renderWidth=r,state.renderHeight=o,state.fboWidth===r&&state.fboHeight===o)return{w:r,h:o};state.fboWidth=r,state.fboHeight=o;const s=()=>{const e=createTexture(t,null,r,o),a=t.createFramebuffer();return t.bindFramebuffer(t.FRAMEBUFFER,a),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),{tex:e,fbo:a}};state.pingPong[0]?.tex&&(t.deleteTexture(state.pingPong[0].tex),t.deleteFramebuffer(state.pingPong[0].fbo)),state.pingPong[1]?.tex&&(t.deleteTexture(state.pingPong[1].tex),t.deleteFramebuffer(state.pingPong[1].fbo)),state.pingPong[0]=s(),state.pingPong[1]=s(),["tempNoise","blur1","blur2"].forEach(e=>{state.textures[e]&&t.deleteTexture(state.textures[e]),state.fbos[e]&&t.deleteFramebuffer(state.fbos[e])});const n=s();state.textures.tempNoise=n.tex,state.fbos.tempNoise=n.fbo;const i=s();state.textures.blur1=i.tex,state.fbos.blur1=i.fbo;const l=s();return state.textures.blur2=l.tex,state.fbos.blur2=l.fbo,{w:r,h:o}}function renderFrame(e=!1){if(!state.baseImage)return;const t=state.gl,a=reallocateBuffers(e),r=a.w,o=a.h;t.viewport(0,0,r,o);let s=0,n=1,i=state.textures.base;if(e&&(r!==state.width||o!==state.height)){const e=document.createElement("canvas");e.width=r,e.height=o;e.getContext("2d").drawImage(state.baseImage,0,0,state.width,state.height,0,0,r,o),i=t.createTexture(),t.bindTexture(t.TEXTURE_2D,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)}t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[0].fbo),t.useProgram(state.programs.copy),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,i),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6),e&&i!==state.textures.base&&t.deleteTexture(i);const l={u_bright:parseFloat(UI.brightness.value),u_cont:parseFloat(UI.contrast.value),u_sat:parseFloat(UI.saturationAdj.value)/100,u_warmth:parseFloat(UI.warmth.value),u_sharp:parseFloat(UI.sharpen.value),u_step:[1/r,1/o],u_hdrTol:parseFloat(UI.hdrTolerance.value),u_hdrAmt:parseFloat(UI.hdrAmount.value),u_ca_amt:calcCurve(parseFloat(UI.aberrationAmount.value),300,300),u_ca_blur:calcCurve(parseFloat(UI.aberrationBlur.value),100,100),u_ca_center:[state.caCenter.x,state.caCenter.y],u_ca_rad:parseFloat(UI.caRadius.value)/1e3,u_ca_fall:parseFloat(UI.caFalloff.value)/1e3};state.renderOrder.forEach(e=>{if(state.layerVisibility[e])if("adjust"===e){t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.adjust),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.adjust,"u_tex"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_bright"),l.u_bright),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_cont"),l.u_cont),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_sat"),l.u_sat),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_hdrTol"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_hdrAmt"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_warmth"),l.u_warmth),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_sharp"),l.u_sharp),t.uniform2f(t.getUniformLocation(state.programs.adjust,"u_step"),l.u_step[0],l.u_step[1]),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.adjust=state.pingPong[n].tex;let e=s;s=n,n=e}else if("hdr"===e){t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.adjust),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.adjust,"u_tex"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_bright"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_cont"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_sat"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_warmth"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_sharp"),0),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_hdrTol"),l.u_hdrTol),t.uniform1f(t.getUniformLocation(state.programs.adjust,"u_hdrAmt"),l.u_hdrAmt),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.hdr=state.pingPong[n].tex;let e=s;s=n,n=e}else if("noise"===e){t.useProgram(state.programs.noise),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.tempNoise),t.uniform1i(t.getUniformLocation(state.programs.noise,"u_type"),parseInt(UI.noiseType.value)),t.uniform1f(t.getUniformLocation(state.programs.noise,"u_seed"),100*Math.random()),t.uniform2f(t.getUniformLocation(state.programs.noise,"u_res"),r,o),t.uniform2f(t.getUniformLocation(state.programs.noise,"u_origRes"),state.width*state.upscaleFactor,state.height*state.upscaleFactor),t.uniform1f(t.getUniformLocation(state.programs.noise,"u_scale"),parseFloat(UI.noiseSize.value)),t.drawArrays(t.TRIANGLES,0,6);const e=parseFloat(UI.blurriness.value)/100;let a=state.textures.tempNoise;e>0&&(t.useProgram(state.programs.blur),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.blur1),t.bindTexture(t.TEXTURE_2D,state.textures.tempNoise),t.uniform1i(t.getUniformLocation(state.programs.blur,"u_tex"),0),t.uniform2f(t.getUniformLocation(state.programs.blur,"u_dir"),1/r,0),t.uniform1f(t.getUniformLocation(state.programs.blur,"u_rad"),2*e),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.blur2),t.bindTexture(t.TEXTURE_2D,state.textures.blur1),t.uniform2f(t.getUniformLocation(state.programs.blur,"u_dir"),0,1/o),t.drawArrays(t.TRIANGLES,0,6),a=state.textures.blur2),t.useProgram(state.programs.mask),t.bindFramebuffer(t.FRAMEBUFFER,state.fbos.blur1),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.mask,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.mask,"u_useS"),UI.enableShadows.checked?1:0),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_sth"),parseFloat(UI.shadowThreshold.value)),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_sfa"),parseFloat(UI.shadowFade.value)),t.uniform1i(t.getUniformLocation(state.programs.mask,"u_useH"),UI.enableHighlights.checked?1:0),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_hth"),parseFloat(UI.highlightThreshold.value)),t.uniform1f(t.getUniformLocation(state.programs.mask,"u_hfa"),parseFloat(UI.highlightFade.value)),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.shadows=state.textures.blur1,state.layerTextures.highlights=state.textures.blur1,t.useProgram(state.programs.composite),t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,a),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,state.textures.blur1),t.uniform1i(t.getUniformLocation(state.programs.composite,"u_base"),0),t.uniform1i(t.getUniformLocation(state.programs.composite,"u_noise"),1),t.uniform1i(t.getUniformLocation(state.programs.composite,"u_mask"),2),t.uniform1i(t.getUniformLocation(state.programs.composite,"u_mode"),parseInt(UI.blendMode.value)),t.uniform1f(t.getUniformLocation(state.programs.composite,"u_opacity"),parseFloat(UI.opacity.value)),t.uniform1f(t.getUniformLocation(state.programs.composite,"u_str"),parseFloat(UI.strength.value)),t.uniform1i(t.getUniformLocation(state.programs.composite,"u_nType"),parseInt(UI.noiseType.value)),t.uniform1f(t.getUniformLocation(state.programs.composite,"u_satStr"),parseFloat(UI.satStrength.value)),t.uniform1f(t.getUniformLocation(state.programs.composite,"u_satImp"),parseFloat(UI.satPerNoise.value)),t.uniform1i(t.getUniformLocation(state.programs.composite,"u_ignA"),UI.ignoreAlphaToggle.checked?1:0),t.uniform1f(t.getUniformLocation(state.programs.composite,"u_ignAstr"),parseFloat(UI.ignoreAlphaStrength.value)),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.noise=state.pingPong[n].tex;let i=s;s=n,n=i}else if("ca"===e){t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.chroma),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.chroma,"u_tex"),0),t.uniform1f(t.getUniformLocation(state.programs.chroma,"u_amt"),l.u_ca_amt),t.uniform1f(t.getUniformLocation(state.programs.chroma,"u_blur"),l.u_ca_blur),t.uniform2f(t.getUniformLocation(state.programs.chroma,"u_center"),l.u_ca_center[0],l.u_ca_center[1]),t.uniform1f(t.getUniformLocation(state.programs.chroma,"u_radius"),l.u_ca_rad),t.uniform1f(t.getUniformLocation(state.programs.chroma,"u_falloff"),l.u_ca_fall),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.ca=state.pingPong[n].tex;let e=s;s=n,n=e}else if("dither"===e){if(!UI.ditherEnable.checked)return;t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.dither),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.dither,"u_tex"),0),t.uniform1i(t.getUniformLocation(state.programs.dither,"u_type"),parseInt(UI.ditherType.value)),t.uniform1f(t.getUniformLocation(state.programs.dither,"u_bitDepth"),parseFloat(UI.ditherBitDepth.value)),t.uniform1f(t.getUniformLocation(state.programs.dither,"u_paletteSize"),parseFloat(UI.ditherPaletteSize.value)),t.uniform1f(t.getUniformLocation(state.programs.dither,"u_strength"),parseFloat(UI.ditherStrength.value)),t.uniform1f(t.getUniformLocation(state.programs.dither,"u_scale"),parseFloat(UI.ditherScale.value)),t.uniform2f(t.getUniformLocation(state.programs.dither,"u_res"),r,o),t.uniform1f(t.getUniformLocation(state.programs.dither,"u_seed"),1e3*Math.random()),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.dither=state.pingPong[n].tex;let e=s;s=n,n=e}else if("corruption"===e){if(UI.corruptionEnable.checked){let e=state.pingPong[s].tex,a=state.pingPong[n].fbo;state.pingPong[n].tex;Math.max(1,parseInt(UI.corruptionIterations.value));t.useProgram(state.programs.corruption),t.uniform1i(t.getUniformLocation(state.programs.corruption,"u_algorithm"),parseInt(UI.corruptionAlgorithm.value)),t.uniform1f(t.getUniformLocation(state.programs.corruption,"u_resScale"),parseFloat(UI.corruptionResScale.value)),t.uniform2f(t.getUniformLocation(state.programs.corruption,"u_res"),r,o),t.bindFramebuffer(t.FRAMEBUFFER,a),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e),t.uniform1i(t.getUniformLocation(state.programs.corruption,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6)}else t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6);state.layerTextures.corruption=state.pingPong[n].tex;let e=s;s=n,n=e}else if("cell"===e){UI.cellEnable.checked?(t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.cell),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_tex"),0),t.uniform2f(t.getUniformLocation(state.programs.cell,"u_res"),r,o),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_levels"),parseInt(UI.cellLevels.value)),t.uniform1f(t.getUniformLocation(state.programs.cell,"u_bias"),parseFloat(UI.cellBias.value)),t.uniform1f(t.getUniformLocation(state.programs.cell,"u_gamma"),parseFloat(UI.cellGamma.value)),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_quantMode"),parseInt(UI.cellQuantMode.value)),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_bandMap"),parseInt(UI.cellBandMap.value)),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_edgeMethod"),parseInt(UI.cellEdgeMethod.value)),t.uniform1f(t.getUniformLocation(state.programs.cell,"u_edgeStr"),parseFloat(UI.cellEdgeStr.value)),t.uniform1f(t.getUniformLocation(state.programs.cell,"u_edgeThick"),parseFloat(UI.cellEdgeThick.value)),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_colorPreserve"),UI.cellColorPreserve.checked?1:0),t.uniform1i(t.getUniformLocation(state.programs.cell,"u_edgeEnable"),UI.cellEdgeEnable.checked?1:0),t.drawArrays(t.TRIANGLES,0,6)):(t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6)),state.layerTextures.cell=state.pingPong[n].tex;let e=s;s=n,n=e}else if("halftone"===e){UI.halftoneEnable.checked?(t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.halftone),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_tex"),0),t.uniform2f(t.getUniformLocation(state.programs.halftone,"u_res"),r,o),t.uniform1f(t.getUniformLocation(state.programs.halftone,"u_size"),parseFloat(UI.halftoneSize.value)),t.uniform1f(t.getUniformLocation(state.programs.halftone,"u_intensity"),parseFloat(UI.halftoneIntensity.value)),t.uniform1f(t.getUniformLocation(state.programs.halftone,"u_sharpness"),parseFloat(UI.halftoneSharpness.value)),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_pattern"),parseInt(UI.halftonePattern.value)),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_colorMode"),parseInt(UI.halftoneColorMode.value)),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_sample"),parseInt(UI.halftoneSample.value)),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_gray"),UI.halftoneGray.checked?1:0),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_lock"),UI.halftoneScreenLock.checked?1:0),t.uniform1i(t.getUniformLocation(state.programs.halftone,"u_invert"),UI.halftoneInvert.checked?1:0),t.drawArrays(t.TRIANGLES,0,6)):(t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6)),state.layerTextures.halftone=state.pingPong[n].tex;let e=s;s=n,n=e}else if("bilateral"===e)if(UI.bilateralEnable.checked){const e=Math.max(1,parseInt(UI.bilateralIter.value));t.useProgram(state.programs.bilateral),t.uniform2f(t.getUniformLocation(state.programs.bilateral,"u_res"),r,o),t.uniform1i(t.getUniformLocation(state.programs.bilateral,"u_radius"),parseInt(UI.bilateralRadius.value)),t.uniform1f(t.getUniformLocation(state.programs.bilateral,"u_sigmaCol"),parseFloat(UI.bilateralColorSig.value)),t.uniform1f(t.getUniformLocation(state.programs.bilateral,"u_sigmaSpace"),parseFloat(UI.bilateralSpatialSig.value)),t.uniform1i(t.getUniformLocation(state.programs.bilateral,"u_kernel"),parseInt(UI.bilateralKernel.value)),t.uniform1i(t.getUniformLocation(state.programs.bilateral,"u_edgeMode"),parseInt(UI.bilateralEdgeMode.value));for(let a=0;a<e;a++){t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.bilateral,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6);let e=s;s=n,n=e}state.layerTextures.bilateral=state.pingPong[s].tex}else{t.bindFramebuffer(t.FRAMEBUFFER,state.pingPong[n].fbo),t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,state.pingPong[s].tex),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0),t.drawArrays(t.TRIANGLES,0,6),state.layerTextures.bilateral=state.pingPong[n].tex;let e=s;s=n,n=e}}),t.bindFramebuffer(t.FRAMEBUFFER,null),t.canvas.width===r&&t.canvas.height===o||(t.canvas.width=r,t.canvas.height=o),t.viewport(0,0,r,o);const c=state.activeLayerPreview&&state.layerTextures[state.activeLayerPreview]?state.layerTextures[state.activeLayerPreview]:state.pingPong[s].tex;t.useProgram(state.programs.copy),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,c),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_tex"),0);let u=0;"shadows"===state.activeLayerPreview&&(u=2),"highlights"===state.activeLayerPreview&&(u=3),t.uniform1i(t.getUniformLocation(state.programs.copy,"u_channel"),u),t.drawArrays(t.TRIANGLES,0,6),e?t.finish():updateLayerPreviews()}function calcCurve(e,t,a=1){const r=e/t;return r*r*a}function updatePinPosition(){const e=100*state.caCenter.x,t=100*(1-state.caCenter.y);UI.caPin.style.left=e+"%",UI.caPin.style.top=t+"%"}function createShader(e,t,a){const r=document.getElementById(a).text.trim(),o=e.createShader("vs-quad"==t?e.VERTEX_SHADER:e.FRAGMENT_SHADER);return e.shaderSource(o,r),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.error(e.getShaderInfoLog(o)),null)}function createProgram(e,t,a){const r=createShader(e,"vs-quad",t),o=createShader(e,"fs-fragment",a),s=e.createProgram();return e.attachShader(s,r),e.attachShader(s,o),e.linkProgram(s),s}function createTexture(e,t,a,r){const o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),t?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a,r,0,e.RGBA,e.UNSIGNED_BYTE,null),o}async function downloadFullRes(){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),reallocateBuffers(!0),renderFrame(!0);const e=document.createElement("a");e.download="grain-export.png",e.href=state.canvas.toDataURL("image/png",1),e.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function openCompare(){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const e=document.getElementById("compareOriginal"),t=document.getElementById("compareProcessed"),a=state.width/state.height;e.width=600,e.height=600/a,t.width=600,t.height=600/a;const r=e.getContext("2d"),o=t.getContext("2d");r.drawImage(state.baseImage,0,0,e.width,e.height),o.drawImage(state.canvas,0,0,t.width,t.height),document.getElementById("compareModal").classList.add("show"),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}async function exportComparison(e){UI.loading.style.display="block",await new Promise(e=>setTimeout(e,50)),renderFrame(!0);const t=state.canvas.toDataURL(),a=new Image;a.src=t,await new Promise(e=>a.onload=e);const r=document.createElement("canvas"),o=state.canvas.width,s=state.canvas.height;if("side"===e){r.width=2*o,r.height=s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0,o,s),e.drawImage(a,o,0)}else{r.width=o,r.height=2*s;const e=r.getContext("2d");e.drawImage(state.baseImage,0,0,o,s),e.drawImage(a,0,s)}const n=document.createElement("a");n.download=`grain-compare-${e}.png`,n.href=r.toDataURL("image/png",.9),n.click(),reallocateBuffers(!1),requestRender(),UI.loading.style.display="none"}function setupLayerGridDOM(){const e=UI.layerGrid;e.innerHTML="";["noise","adjust","hdr","ca","cell","halftone","bilateral","dither","corruption","shadows","highlights"].forEach(t=>{const a=document.createElement("div");a.className="layer-item",state.activeLayerPreview===t&&a.classList.add("active"),a.onclick=()=>{state.activeLayerPreview===t?(state.activeLayerPreview=null,a.classList.remove("active")):(state.activeLayerPreview=t,document.querySelectorAll(".layer-item").forEach(e=>e.classList.remove("active")),a.classList.add("active"),UI.overlayOriginal.classList.remove("show")),requestRender()},a.innerHTML=`<div class="layer-title">${LAYERS[t].name}</div><canvas class="layer-canvas" id="thumb-${t}" width="320" height="180"></canvas>`,e.appendChild(a)})}function updateLayerPreviews(){const e=state.gl;if(!state.thumbnailFBO)return;e.bindFramebuffer(e.FRAMEBUFFER,state.thumbnailFBO.fbo),e.viewport(0,0,state.thumbnailFBO.w,state.thumbnailFBO.h),e.useProgram(state.programs.copy);const t=new Uint8Array(state.thumbnailFBO.w*state.thumbnailFBO.h*4);Object.keys(state.layerTextures).forEach(a=>{const r=state.layerTextures[a],o=document.getElementById(`thumb-${a}`);if(!o||!r)return;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,r),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_tex"),0);let s=0;"shadows"===a&&(s=2),"highlights"===a&&(s=3),e.uniform1i(e.getUniformLocation(state.programs.copy,"u_channel"),s),e.drawArrays(e.TRIANGLES,0,6),e.readPixels(0,0,state.thumbnailFBO.w,state.thumbnailFBO.h,e.RGBA,e.UNSIGNED_BYTE,t);const n=o.getContext("2d"),i=n.createImageData(state.thumbnailFBO.w,state.thumbnailFBO.h),l=state.thumbnailFBO.w,c=state.thumbnailFBO.h;for(let e=0;e<c;e++){const a=(c-1-e)*l*4,r=e*l*4;i.data.set(t.subarray(a,a+4*l),r)}n.putImageData(i,0,0)})}</script></body></html>