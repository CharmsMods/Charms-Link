<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Digital Grain Studio ‚Äî GPU Accelerated</title>
    <style>
        /* [DESIGN SYSTEM] Global CSS Variables
           Purpose: Standardizes colors, spacing, and transition speeds across the UI.
           Reference: These are used via var(--name) throughout the stylesheet. */
        :root {
            --bg: #000;
            --fg: #fff;
            --panel-max: 460px;
            /* Width of the left control sidebar */
            --muted: #8c8c8c;
            --accent: #2a9df4;
            /* Key interaction color (blue) */
            --border: rgba(255, 255, 255, 0.08);
            --layer-h: 40px;
            --tab-bg: #1a1a1a;
            --tab-active: #2a9df4;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', monospace
        }

        body {
            padding: 16px;
            display: flex;
            gap: 16px;
            align-items: flex-start;
            min-height: 100vh
        }

        .container {
            display: flex;
            gap: 16px;
            width: 100%;
            height: 100%;
        }

        /* [LAYOUT] Sidebar Panel
           Purpose: Fixed-width column on the left; scrollable if content overflows.
           Logic: Uses flex-basis based on --panel-max variable. */
        .controls-panel {
            flex: 0 0 var(--panel-max);
            max-width: var(--panel-max);
            min-width: 320px;
            padding-right: 10px;
            overflow-y: auto;
            height: 100%;
            scrollbar-width: thin;
            scrollbar-color: var(--muted) var(--bg);
            display: flex;
            flex-direction: column;
        }

        .controls-panel h1 {
            font-size: 18px;
            margin: 0 0 4px 0;
            text-align: center;
            letter-spacing: -0.5px;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
            margin-bottom: 12px;
            display: block;
            text-align: center;
        }

        /* [COMPONENTS] Tab Navigation System
           Used in the Sidebar to switch between 'Controls' and 'Render Layer Order'. */
        .tab-toggle-container {
            display: flex;
            gap: 4px;
            margin: 10px 0;
            background: #111;
            padding: 4px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .tab-btn {
            flex: 1;
            padding: 8px;
            font-size: 11px;
            background: #1a1a1a;
            color: var(--muted);
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: var(--accent);
            color: #000;
        }

        .tab-content {
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .tab-content.active {
            display: flex;
        }

        /* [DRAG-AND-DROP] Layer Reordering UI
           Classes applied by the Sortable.js logic or manual drag handlers. */
        .drag-layer {
            background: #111;
            border: 1px solid var(--border);
            padding: 8px 12px;
            margin-bottom: 6px;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            font-size: 13px;
            border-radius: 4px;
        }

        .drag-layer:active {
            cursor: grabbing;
            background: #222;
            border-color: var(--accent);
        }

        .drag-layer.dragging {
            opacity: 0.5;
        }

        .drag-handle {
            color: var(--muted);
            margin-right: 10px;
        }

        .drag-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .drag-toggle {
            cursor: pointer;
            accent-color: var(--accent);
        }

        /* [FORM CONTROLS] Sliders & Toggles
           Targeting 'details' and 'summary' for collapsible tool sections. */
        details {
            border: 1px solid var(--border);
            margin-bottom: 8px;
            padding: 6px;
            border-radius: 4px;
            background: #0a0a0a
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            margin: 0 0 6px 0;
            outline: none;
            user-select: none;
            font-size: 13px;
        }

        summary:hover {
            color: var(--accent);
        }

        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
            min-height: 28px
        }

        .control-row label {
            flex: 0 0 120px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 12px;
        }

        input[type=range] {
            flex: 1;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .control-value {
            width: 60px;
            padding: 2px 4px;
            text-align: right;
            background: #000;
            color: var(--fg);
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 11px;
        }

        select.control-value {
            flex: 1;
            min-width: 120px;
            padding: 4px
        }

        .row-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .palette-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
            padding: 4px;
            border: 1px solid var(--border);
            min-height: 32px;
            background: #050505;
        }

        .palette-color-item {
            display: flex;
            align-items: center;
            background: #1a1a1a;
            border: 1px solid var(--border);
            padding: 2px;
            gap: 4px;
        }

        .palette-color-item input[type="color"] {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
            background: none;
            cursor: pointer;
        }

        .remove-color-btn {
            background: none;
            border: none;
            color: #ff5555;
            cursor: pointer;
            font-size: 14px;
            padding: 0 4px;
            line-height: 1;
        }

        .remove-color-btn:hover {
            color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }

        button {
            background: #111;
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 8px 12px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.small-btn {
            padding: 4px 8px;
            font-size: 10px;
        }

        /* [LAYOUT] Right Preview Column
           Purpose: Expands to fill available space; contains main canvas and grid. */
        .preview-column {
            flex: 1 1 auto;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
            overflow: hidden;
        }

        .preview-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px
        }

        /* [VIEWPORT] Main Canvas Container
           Logic: Uses a checkerboard-style background to show transparency. */
        .preview-container {
            position: relative;
            border: 1px solid var(--border);
            background: repeating-linear-gradient(45deg, #111 0px, #111 10px, #0e0e0e 10px, #0e0e0e 20px);
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        /* Canvas Display */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Overlay (Original) */
        .overlay-original {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        .overlay-original canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .overlay-original.show canvas {
            opacity: 1
        }

        /* CA Pin */
        #caPin {
            width: 12px;
            height: 12px;
            background: var(--accent);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: crosshair;
            z-index: 20;
            box-shadow: 0 0 5px #000;
            display: none;
        }

        #caPin.active {
            display: block;
        }

        #caPin::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none;
        }

        /* [COMPONENTS] Layer Preview Grid
           Purpose: Displays intermediate render textures. */
        .layer-preview-window {
            border: 1px solid var(--border);
            background: #050505;
            padding: 8px;
            height: 160px;
            flex: 0 0 160px;
            overflow: hidden;
        }

        .layer-grid {
            display: flex;
            gap: 4px;
            height: 100%;
        }

        .layer-item {
            border: 1px solid var(--border);
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #000;
            cursor: pointer;
            transition: border-color 0.2s;
            position: relative;
            min-width: 60px;
        }

        .layer-item:hover {
            border-color: var(--muted);
        }

        .layer-item.active {
            border-color: var(--accent);
        }

        .layer-title {
            color: var(--muted);
            font-size: 9px;
            text-transform: uppercase;
            text-align: center;
            padding-top: 4px;
            height: 24px;
            line-height: 1.2;
            word-wrap: break-word;
            padding: 2px;
        }

        .layer-canvas {
            width: 100%;
            flex: 1;
            background: #111;
            border-top: 1px solid #222;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 3000
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto
        }

        .modal {
            background: #111;
            border: 1px solid var(--border);
            padding: 20px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        /* Loading Indicator */
        #loading {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--accent);
            color: #000;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: bold;
            display: none;
            z-index: 4000;
        }

        /* Upscale & Lock Input */
        .upscale-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            border: 1px solid var(--border);
            padding: 4px 8px;
            background: #0a0a0a;
            border-radius: 4px;
        }

        .upscale-input {
            width: 40px;
            background: #000;
            border: 1px solid var(--border);
            color: var(--fg);
            padding: 2px;
            text-align: center;
            font-family: monospace;
        }

        .lock-switch {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            margin-right: 12px;
            border-right: 1px solid var(--border);
            padding-right: 12px;
        }

        .lock-checkbox {
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* File Inputs */
        .json-btn {
            background: #222;
            border: 1px solid var(--border);
            color: var(--accent);
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            margin-top: 4px;
            width: 100%;
            text-align: center;
        }

        .json-btn:hover {
            background: var(--accent);
            color: #000;
        }

        /* [RESPONSIVENESS] Mobile Layout
           Purpose: Stacks the sidebar and viewport vertically on narrow screens. */
        @media (max-width:900px) {
            body {
                padding: 10px;
                flex-direction: column;
            }

            .container {
                flex-direction: column;
            }

            .controls-panel {
                width: 100%;
                max-width: none;
                flex: none;
                height: auto;
                max-height: 40vh;
            }

            .preview-column {
                width: 100%;
                height: 50vh;
            }
        }
    </style>
</head>

<body>

    <!-- [UI] Exporting Overlay -->
    <div id="export-overlay"
        style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 3999; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 1.2em;">
        <div id="export-status">PROCESSING 1/100...</div>
        <button id="stopExportBtn"
            style="margin-top: 20px; padding: 10px 20px; background: #ff5555; color: #fff; border: 1px solid #ff7777; font-size: 0.8em;">CANCEL
            EXPORT</button>
    </div>

    <!-- [UI] Loading Screen: Visible only during complex GPU operations/initialization -->
    <div id="loading">PROCESSING GPU...</div>

    <div class="container">
        <!-- [LEFT PANEL] Controls & Settings Sidebar 
             Targeted by '.controls-panel' in CSS. 
             Contains all user-interactive sliders and selects. -->
        <div class="controls-panel">
            <h1>DIGITAL GRAIN [GPU]</h1>
            <span class="muted">WebGL2 Accelerated Pipeline</span>

            <div style="margin:10px 0; border: 1px dashed var(--border); padding: 10px; text-align: center;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <label for="imageUpload"
                        style="cursor: pointer; display: block; background: #1a1a1a; padding: 8px; border-radius: 4px; border: 1px solid var(--border);">
                        <span style="font-size: 24px; display: block; margin-bottom: 5px;">üìÇ</span>
                        <span style="font-size: 12px; color: var(--accent);">LOAD IMAGE</span>
                    </label>
                    <label id="loadFolderBtn"
                        style="cursor: pointer; display: block; background: #1a1a1a; padding: 8px; border-radius: 4px; border: 1px solid var(--border);">
                        <span style="font-size: 24px; display: block; margin-bottom: 5px;">üóÇÔ∏è</span>
                        <span style="font-size: 12px; color: var(--accent);">LOAD FOLDER</span>
                    </label>
                </div>
                <input id="imageUpload" type="file" accept="image/*" style="display: none;">

                <div id="image-navigation"
                    style="display: none; margin-top: 10px; flex-direction: column; align-items: center; justify-content: center; gap: 10px;">
                    <div
                        style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <button id="prevImageBtn" class="small-btn">‚óÑ Prev</button>
                        <span id="imageCounter"
                            style="font-size: 12px; color: var(--muted); min-width: 80px; text-align: center;">Image 1
                            of 1</span>
                        <button id="nextImageBtn" class="small-btn">Next ‚ñ∫</button>
                    </div>
                    <input type="range" id="imageScrubber" style="width: 80%; accent-color: var(--accent);" min="0"
                        max="0" value="0">
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                        <button id="playBtn" class="small-btn">PLAY ‚ñ∫</button>
                        <input type="number" id="playFps" class="upscale-input" value="10" style="width: 50px;">
                        <span style="font-size: 11px; color: var(--muted);">FPS</span>
                        <span id="actualFps" style="font-size: 11px; color: var(--accent); min-width: 90px;">(Actual:
                            --)</span>
                    </div>
                    <div
                        style="display: flex; align-items: center; gap: 10px; margin-top: 8px; border-top: 1px solid var(--border); padding-top: 8px; width: 100%; justify-content: center;">
                        <label style="font-size: 11px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="keepFolderStructureToggle" style="accent-color: var(--accent);">
                            <span>KEEP FOLDER STRUCTURE ON EXPORT</span>
                        </label>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px;">
                    <button class="json-btn" id="downloadJsonBtn">DOWNLOAD .JSON</button>
                    <button class="json-btn" id="uploadJsonTrigger">UPLOAD .JSON</button>
                    <input id="jsonUpload" type="file" accept=".json" style="display: none;">
                </div>
            </div>

            <!-- [TAB SYSTEM] Switch between global controls and layer stack reordering
                 JS Logic: Handled by 'tab-btn' click listeners in the init sequence. -->
            <div class="tab-toggle-container">
                <button class="tab-btn active" data-tab="tab-controls">Controls</button>
                <button class="tab-btn" data-tab="tab-layers">Render Layer Order</button>
            </div>

            <!-- TAB 1: Main Control Panel
                 Contains all collapsible sections for image manipulation layers. -->
            <div id="tab-controls" class="tab-content active">

                <!-- [SYSTEM SETTINGS] Control global performance and rendering behavior -->
                <details open>
                    <summary>System & Performance</summary>
                    <div class="control-row"
                        title="If enabled, removes the 2048px preview limit. Requires a powerful GPU for large images.">
                        <label>High Quality Preview</label>
                        <input id="clampPreviewToggle" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Full Res</label>
                    </div>
                    <div class="control-row"
                        style="font-size: 9px; color: var(--muted); border-top: 1px solid var(--border); padding-top: 8px; margin-top: 8px;">
                        <span>MAX GPU TEXTURE:</span>
                        <span id="gpuMaxRes"
                            style="margin-left:auto; font-family:monospace; color:var(--accent);">QUERYING...</span>
                    </div>
                </details>

                <!-- Layer: Noise
                     Purpose: Generates procedural grain and handles all noise-related attributes.
                     Combines: Basics, Shape, Blur, Blend, Opacity, and Masking. -->
                <details open>
                    <summary>
                        Noise
                        <input id="noiseEnable" type="checkbox" checked style="margin-left: auto;">
                    </summary>
                    <div class="control-row">
                        <label>Noise Strength</label>
                        <input id="strength" type="range" min="0" max="150" step="0.1" value="40">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Noise Type</label>
                        <select id="noiseType" class="control-value">
                            <option value="1" selected>Grayscale</option>
                            <option value="0">Color</option>
                            <option value="3">Blue Noise</option>
                            <option value="4">Blue Noise (Color)</option>
                            <option value="2">Blend (Sat)</option>
                            <option value="5">Perlin (Cloudy)</option>
                            <option value="6">Worley (Cellular)</option>
                            <option value="7">Scanlines</option>
                            <option value="8">Speckle (Dust)</option>
                            <option value="9">Glitch</option>
                            <option value="10">Anisotropic (Fiber)</option>
                            <option value="11">Voronoi Mosaic</option>
                            <option value="12">Crosshatch</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Sat Strength</label>
                        <input id="satStrength" type="range" min="0" max="4" step="0.1" value="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sat Impact</label>
                        <input id="satPerNoise" type="range" min="-100" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>

                    <!-- Contextual Noise Parameters -->
                    <div id="noiseParamsHeader"
                        style="display:none; border-top: 1px dashed var(--border); margin: 8px 0; padding-top: 8px; font-size: 10px; color: var(--accent); opacity: 0.8; text-transform: uppercase; letter-spacing: 1px;">
                        Advanced Settings</div>
                    <div id="noiseParamRowA" class="control-row" style="display:none;">
                        <label id="noiseLabelA">Param A</label>
                        <input id="noiseParamA" type="range" min="0" max="100" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div id="noiseParamRowB" class="control-row" style="display:none;">
                        <label id="noiseLabelB">Param B</label>
                        <input id="noiseParamB" type="range" min="0" max="100" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div id="noiseParamRowC" class="control-row" style="display:none;">
                        <label id="noiseLabelC">Param C</label>
                        <input id="noiseParamC" type="range" min="0" max="100" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="border-top: 1px dashed var(--border); margin: 8px 0; padding-top: 8px;"></div>
                    <div class="control-row">
                        <label>Scale (Size)</label>
                        <input id="noiseSize" type="range" min="0" max="10" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Blurriness</label>
                        <input id="blurriness" type="range" min="0" max="100" step="1" value="2">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="border-top: 1px dashed var(--border); margin: 8px 0; padding-top: 8px;"></div>
                    <div class="control-row">
                        <label>Blend Mode</label>
                        <select id="blendMode" class="control-value">
                            <option value="0">Normal</option>
                            <option value="1" selected>Overlay</option>
                            <option value="2">Screen</option>
                            <option value="3">Multiply</option>
                            <option value="4">Add</option>
                            <option value="5">Difference</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Opacity</label>
                        <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.5">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="border-top: 1px dashed var(--border); margin: 8px 0; padding-top: 8px;"></div>
                    <div class="control-row">
                        <label>Luma Masking</label>
                        <input id="noiseLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="shadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="shadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="highlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="highlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="border-top: 1px dashed var(--border); margin: 8px 0; padding-top: 8px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="noiseColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="noiseExcludeColor" type="color" value="#000000"
                                style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="noiseExcludeColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="noiseColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="noiseColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="border-top: 1px dashed var(--border); margin: 8px 0; padding-top: 8px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="noiseInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                    <div class="control-row">
                        <label>Skin Protection</label>
                        <input id="skinProtection" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer 1: Alpha -->
                <details>
                    <summary>Alpha Channel</summary>
                    <div class="control-row">
                        <label>Ignore Alpha</label>
                        <input id="ignoreAlphaToggle" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Strength</label>
                        <input id="ignoreAlphaStrength" type="range" min="0" max="100" step="1" value="100">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer: Adjustments
                     Purpose: Fundamental image correction (Brightness, Contrast, Saturation).
                     Shader Ref: 'fs-adjust'
                     JS Ref: 'adjust' key in LAYERS object. -->
                <details>
                    <summary>
                        Adjustments
                        <input id="adjustEnable" type="checkbox" checked style="margin-left: auto;">
                    </summary>
                    <div class="control-row">
                        <label>Brightness</label>
                        <input id="brightness" type="range" min="-100" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Contrast</label>
                        <input id="contrast" type="range" min="-100" max="200" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Saturation</label>
                        <input id="saturationAdj" type="range" min="-100" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Warmth</label>
                        <input id="warmth" type="range" min="-500" max="500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sharpening</label>
                        <input id="sharpen" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sharpen Threshold</label>
                        <input id="sharpenThreshold" type="range" min="0" max="100" step="1" value="5">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="adjColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="adjExcludeColor" type="color" value="#000000" style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="adjExcludeColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="adjColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="adjColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="adjLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="adjShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="adjShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="adjHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="adjHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="adjInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                </details>

                <!-- Layer: HDR Emulation
                     Purpose: Simulates high-dynamic range by boosting specific bright thresholds.
                     Shader Ref: Uses bloom/boost logic in 'fs-adjust'. -->
                <details>
                    <summary>
                        HDR Emulation
                        <input id="hdrEnable" type="checkbox" checked style="margin-left: auto;">
                    </summary>
                    <div class="control-row">
                        <label>Tolerance</label>
                        <input id="hdrTolerance" type="range" min="0" max="1" step="0.01" value="0.35">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Amount</label>
                        <input id="hdrAmount" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer: Chromatic Aberration
                     Purpose: Simulates lens color fringing (RGB splitting).
                     Shader Ref: 'fs-chroma'
                     JS Ref: Controlled in 'renderSingleLayer' under the 'ca' key. -->
                <details>
                    <summary>
                        Chromatic Aberration
                        <input id="caEnable" type="checkbox" checked style="margin-left: auto;">
                    </summary>
                    <div class="control-row">
                        <label>Amount</label>
                        <input id="aberrationAmount" type="range" min="0" max="1500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <!-- Radius & Falloff -->
                    <div class="control-row">
                        <label>Clear Radius</label>
                        <input id="caRadius" type="range" min="0" max="1000" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Radius Falloff</label>
                        <input id="caFalloff" type="range" min="0" max="500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Blur</label>
                        <input id="aberrationBlur" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Zoom Blur</label>
                        <input id="aberrationZoomBlur" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Link Falloff to Blur</label>
                        <input id="caFalloffToBlur" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enabled</label>
                    </div>
                    <div style="text-align: right; margin-top: 5px;">
                        <button id="resetCenterBtn" class="small-btn">RESET CENTER</button>
                    </div>
                </details>

                <!-- Layer: Blur 
                     Purpose: Multipurpose blurring (Gaussian, Box, Motion).
                     Shader Ref: 'fs-blur'
                     JS Ref: 'renderBlur' helper function. -->
                <details>
                    <summary>Blur</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="blurEnable" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Amount</label>
                        <input id="blurAmount" type="range" min="0" max="1000" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Type</label>
                        <select id="blurType" class="control-value">
                            <option value="0" selected>Gaussian</option>
                            <option value="1">Box</option>
                            <option value="2">Motion</option>
                        </select>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="blurColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="blurTargetColor" type="color" value="#000000" style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="blurTargetColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="blurColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="blurColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="blurLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="blurShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="blurShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="blurHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="blurHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="blurInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                </details>

                <!-- Layer: Dithering -->
                <details>
                    <summary>Dithering</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="ditherEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Bit Depth</label>
                        <input id="ditherBitDepth" type="range" min="1" max="8" step="1" value="4">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Palette Size</label>
                        <input id="ditherPaletteSize" type="range" min="2" max="256" step="1" value="16">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Dither Strength</label>
                        <input id="ditherStrength" type="range" min="0" max="1000" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Scale</label>
                        <input id="ditherScale" type="range" min="1" max="16" step="1" value="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Dither Type</label>
                        <select id="ditherType" class="control-value">
                            <option value="0" selected>Bayer (Ordered)</option>
                            <option value="1">Noise (Random)</option>
                        </select>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="ditherColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input id="ditherExcludeColor" type="color" value="#000000"
                                style="width: 40px; height: 24px;">
                            <button class="eyedropper-btn" data-target="ditherExcludeColor"
                                title="Pick from canvas">üñåÔ∏è</button>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="ditherColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="ditherColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="ditherLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="ditherShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="ditherShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="ditherHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="ditherHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Invert Mask</label>
                        <input id="ditherInvertMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Invert</label>
                    </div>
                    <div class="control-row">
                        <label>Soft Mask Depth</label>
                        <input id="ditherSoftMask" type="checkbox" checked>
                        <label style="color: var(--muted); margin-left: auto;">Enabled</label>
                    </div>
                </details>

                <!-- Layer: Corruption 
                     Purpose: Digital artifacts and glitch effects (JPEG, Pixelation).
                     Shader Ref: 'fs-corruption'
                     JS Ref: 'corruption' key in LAYERS object. -->
                <details>
                    <summary>Corruption</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="corruptionEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Iterations</label>
                        <input id="corruptionIterations" type="range" min="0" max="500" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Algorithm</label>
                        <select id="corruptionAlgorithm" class="control-value">
                            <option value="0" selected>JPEG Blocks</option>
                            <option value="1">Pixelation</option>
                            <option value="2">Color Bleed</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Resolution Scale</label>
                        <input id="corruptionResScale" type="range" min="1" max="100" step="1" value="50">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer: Cell Shading 
                     Purpose: Cartoon/Illustrative look with quantized luminance and edges.
                     Shader Ref: 'fs-cell'
                     JS Ref: 'cell' key in LAYERS object. -->
                <details>
                    <summary>Cell Shading</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="cellEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Shading Levels</label>
                        <input id="cellLevels" type="range" min="2" max="12" step="1" value="4">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Contrast Bias</label>
                        <input id="cellBias" type="range" min="-1" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Gamma Curve</label>
                        <input id="cellGamma" type="range" min="0.5" max="2.2" step="0.01" value="1.0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Quantize Mode</label>
                        <select id="cellQuantMode" class="control-value">
                            <option value="0" selected>Luminance</option>
                            <option value="1">RGB</option>
                            <option value="2">HSV Value</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Band Mapping</label>
                        <select id="cellBandMap" class="control-value">
                            <option value="0" selected>Linear</option>
                            <option value="1">Smoothstep</option>
                            <option value="2">Posterize</option>
                        </select>
                    </div>
                    <div style="height: 5px;"></div>
                    <div class="control-row">
                        <label>Edges Enable</label>
                        <input id="cellEdgeEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Edge Strength</label>
                        <input id="cellEdgeStr" type="range" min="0" max="5" step="0.01" value="0.8">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Thickness</label>
                        <input id="cellEdgeThick" type="range" min="0.5" max="10" step="0.1" value="1.0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Method</label>
                        <select id="cellEdgeMethod" class="control-value">
                            <option value="0">None</option>
                            <option value="1" selected>Sobel</option>
                            <option value="2">Laplacian</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Color Preserve</label>
                        <input id="cellColorPreserve" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Quant Luma Only</label>
                    </div>
                </details>

                <!-- Layer: Halftoning 
                     Purpose: CMYK/Circle dot patterns for print aesthetics.
                     Shader Ref: 'fs-halftone'
                     JS Ref: 'halftone' key in LAYERS object. -->
                <details>
                    <summary>Halftoning</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="halftoneEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Dot Size</label>
                        <input id="halftoneSize" type="range" min="1" max="12" step="0.1" value="4">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Intensity</label>
                        <input id="halftoneIntensity" type="range" min="0" max="1" step="0.01" value="0.8">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Sharpness</label>
                        <input id="halftoneSharpness" type="range" min="0" max="1" step="0.01" value="0.5">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Pattern Type</label>
                        <select id="halftonePattern" class="control-value">
                            <option value="0" selected>Circular</option>
                            <option value="1">Line</option>
                            <option value="2">Cross</option>
                            <option value="3">Diamond</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Color Mode</label>
                        <select id="halftoneColorMode" class="control-value">
                            <option value="0" selected>Luminance</option>
                            <option value="1">RGB</option>
                            <option value="2">CMY</option>
                            <option value="3">CMYK</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Sampling</label>
                        <select id="halftoneSample" class="control-value">
                            <option value="0" selected>Center</option>
                            <option value="1">Average</option>
                            <option value="2">Rotated Grid</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Grayscale</label>
                        <input id="halftoneGray" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Screen Lock</label>
                        <input id="halftoneScreenLock" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Invert</label>
                        <input id="halftoneInvert" type="checkbox">
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="halftoneColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <div> <!-- Extra wrapper to match style if needed or just use the flex -->
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input id="halftoneExcludeColor" type="color" value="#000000"
                                    style="width: 40px; height: 24px;">
                                <button class="eyedropper-btn" data-target="halftoneExcludeColor"
                                    title="Pick from canvas">üñåÔ∏è</button>
                            </div>
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="halftoneColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="halftoneColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="halftoneLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="halftoneShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="halftoneShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="halftoneHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="halftoneHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>

                <!-- Layer: Bilateral Filter 
                     Purpose: Skin smoothing / Edge-preserving noise reduction.
                     Shader Ref: 'fs-bilateral'
                     JS Ref: 'bilateral' key in LAYERS object. -->
                <details>
                    <summary>Bilateral Filter</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="bilateralEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Radius</label>
                        <input id="bilateralRadius" type="range" min="1" max="30" step="1" value="5">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Sigma</label>
                        <input id="bilateralColorSig" type="range" min="0.01" max="1.0" step="0.01" value="0.1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Spatial Sigma</label>
                        <input id="bilateralSpatialSig" type="range" min="0.5" max="15.0" step="0.1" value="2.0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Iterations</label>
                        <input id="bilateralIter" type="range" min="1" max="20" step="1" value="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>High Precision</label>
                        <input id="bilateralHighPrec" type="checkbox" checked>
                    </div>
                    <div class="control-row">
                        <label>Kernel Type</label>
                        <select id="bilateralKernel" class="control-value">
                            <option value="0" selected>Gaussian</option>
                            <option value="1">Box</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Edge Preservation</label>
                        <select id="bilateralEdgeMode" class="control-value">
                            <option value="0" selected>Luminance</option>
                            <option value="1">RGB</option>
                        </select>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Color Exclusion</label>
                        <input id="bilateralColorExclude" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>Exclude Color</label>
                        <input id="bilateralExcludeColor" type="color" value="#000000"
                            style="width: 60px; height: 24px;">
                    </div>
                    <div class="control-row">
                        <label>Color Tolerance</label>
                        <input id="bilateralColorTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Color Fade</label>
                        <input id="bilateralColorFade" type="range" min="0" max="100" step="1" value="20">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div style="height: 10px;"></div>
                    <div class="control-row">
                        <label>Luma Mask</label>
                        <input id="bilateralLumaMask" type="checkbox">
                        <label style="color: var(--muted); margin-left: auto;">Enable</label>
                    </div>
                    <div class="control-row">
                        <label>S. Threshold</label>
                        <input id="bilateralShadowThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>S. Fade</label>
                        <input id="bilateralShadowFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Threshold</label>
                        <input id="bilateralHighlightThreshold" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>H. Fade</label>
                        <input id="bilateralHighlightFade" type="range" min="0" max="1" step="0.01" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                </details>




                <!-- Layer: Palette Reconstructor 
                     Purpose: Remaps image colors to a user-defined or extracted palette.
                     Shader Ref: 'fs-palette' (supports up to 256 colors).
                     JS Logic: High-precision 'Farthest First' extraction logic. -->
                <details>
                    <summary>Palette Reconstructor</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="paletteEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Global Blend</label>
                        <input id="paletteBlend" type="range" min="0" max="100" step="1" value="100">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="row-buttons" style="margin-top: 5px;">
                        <button id="addPaletteColor" class="small-btn">+ ADD COLOR</button>
                        <button id="pickPaletteColorBtn" class="small-btn eyedropper-btn" data-target="pickPaletteColor"
                            title="Pick from canvas">üñåÔ∏è PICK FROM CANVAS</button>
                        <button id="randomPalette" class="small-btn">RANDOMIZE</button>
                        <button id="clearPalette" class="small-btn">CLEAR</button>
                        <button id="extractPalette" class="small-btn">Upload Palette Image</button>
                        <input type="file" id="paletteImageUpload" style="display: none;" accept="image/*">
                    </div>
                    <div class="control-row">
                        <label>Smoothing Type</label>
                        <select id="paletteSmoothingType">
                            <option value="0">Box</option>
                            <option value="1">Gaussian</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Palette Smoothing</label>
                        <input id="paletteSmoothing" type="range" min="0" max="100" step="1" value="0">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row" style="margin-top: 5px;">
                        <label>Extract Count</label>
                        <input id="extractCount" type="range" min="2" max="200" value="8" step="1">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div id="paletteList" class="palette-list">
                        <!-- Colors added here -->
                    </div>
                </details>

                <!-- Layer: Edge Effects 
                     Purpose: Advanced Sobel-based edge highlighting and bloom.
                     Shader Ref: 'fs-edge'
                     JS Ref: 'edge' key in LAYERS object. -->
                <details id="edgeDetails">
                    <summary>Edge Effects</summary>
                    <div class="control-row">
                        <label>Enable</label>
                        <input id="edgeEnable" type="checkbox">
                    </div>
                    <div class="control-row">
                        <label>Global Blend</label>
                        <input id="edgeBlend" type="range" min="0" max="100" step="1" value="100">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Mode</label>
                        <select id="edgeMode">
                            <option value="0">Edge Overlay</option>
                            <option value="1">Saturation Mask</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Edge Strength</label>
                        <input id="edgeStrength" type="range" min="0" max="1000" step="1" value="500">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div class="control-row">
                        <label>Edge Tolerance</label>
                        <input id="edgeTolerance" type="range" min="0" max="100" step="1" value="10">
                        <input type="text" class="control-value" readonly>
                    </div>
                    <div id="edgeSatControls"
                        style="display: none; border-top: 1px dashed #333; padding-top: 10px; margin-top: 10px;">
                        <div class="control-row">
                            <label>Foreground Sat</label>
                            <input id="edgeFgSat" type="range" min="0" max="200" step="1" value="150">
                            <input type="text" class="control-value" readonly>
                        </div>
                        <div class="control-row">
                            <label>Background Sat</label>
                            <input id="edgeBgSat" type="range" min="0" max="200" step="1" value="0">
                            <input type="text" class="control-value" readonly>
                        </div>
                        <div class="control-row">
                            <label>Bloom Spread</label>
                            <input id="edgeBloom" type="range" min="0" max="50" step="1" value="10">
                            <input type="text" class="control-value" readonly>
                        </div>
                        <div class="control-row">
                            <label>Bloom Smoothness</label>
                            <input id="edgeSmooth" type="range" min="0" max="100" step="1" value="50">
                            <input type="text" class="control-value" readonly>
                        </div>
                    </div>
                </details>

                <div class="row-buttons">
                    <button id="downloadBtn" disabled>DOWNLOAD FULL RES</button>
                    <button id="downloadCurrentBtn" disabled>DOWNLOAD CURRENT</button>
                    <button id="compareBtn" disabled>COMPARE / EXPORT</button>
                </div>
            </div>

            <!-- TAB 2: Layer Stack Order
                 Purpose: Allows users to drag and reorder the order of operations.
                 JS Logic: Rebuilds 'state.renderOrder' based on drag-and-drop. -->
            <div id="tab-layers" class="tab-content">
                <div style="font-size:11px; color:var(--muted); margin-bottom:10px;">Drag to reorder render pipeline:
                </div>
                <div id="layer-drag-list">
                    <!-- Populated by updateLayerDragList (JS) -->
                </div>
            </div>

        </div>

        <!-- [RIGHT PANEL] Image Viewport & Analysis 
             Contains main canvas, zoom tools, and layer breakdown previews. -->
        <div class="preview-column">
            <div class="preview-top">
                <h3 style="margin:0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Main Preview</h3>

                <div style="display: flex; align-items: center;">
                    <!-- Lens/Zoom Controls: Controlled by wheel/drag and hover listeners in JS -->
                    <div class="upscale-control" style="margin-right: 8px;"
                        title="Zoom level when hovering over preview. Press TAB to lock.">
                        <span
                            style="color: var(--muted); font-size: 9px; margin-right: 8px; border-right: 1px solid var(--border); padding-right: 8px;">TAB
                            TO LOCK</span>
                        <span>HOVER ZOOM</span>
                        <input id="hoverZoomSlider" type="range" min="1" max="8" step="0.1" value="1"
                            style="width: 60px; accent-color: var(--accent);">
                        <span id="hoverZoomValue" style="min-width: 28px; text-align: center;">1x</span>
                    </div>

                    <!-- Lens Mode Toggle: Switch between cursor-locked lens and full-screen zoom -->
                    <button id="lensToggleBtn" class="small-btn"
                        style="margin-right: 12px; padding: 4px 8px; font-size: 9px;"
                        title="Toggle between Full zoom and Lens zoom">FULL</button>

                    <!-- Preview Lock: Prevents mouse hover from showing the original image overlay -->
                    <label class="lock-switch" title="Lock Preview to prevent Original Image overlay">
                        <input type="checkbox" id="previewLock" class="lock-checkbox">
                        <span>LOCK PREVIEW</span>
                    </label>

                    <div class="upscale-control">
                        <span>UPSCALE (x)</span>
                        <input id="upscaleInput" class="upscale-input" type="text" value="1" min="1" max="10">
                    </div>
                </div>
            </div>

            <!-- [VIEWPORT] The core WebGL display area
                 Houses the main canvas and various overlays (pinned center, lens, original comparison). -->
            <div class="preview-container" id="previewContainer">
                <canvas id="displayCanvas"></canvas>
                <div id="caPin"></div> <!-- Draggable center for Chromatic Aberration -->
                <div class="overlay-original" id="overlayOriginal">
                    <canvas id="overlayCanvas"></canvas> <!-- Original image for hover comparison -->
                </div>
                <!-- Indicators & Floating Lens -->
                <div id="zoomResIndicator"
                    style="position:absolute; bottom:8px; left:8px; background:rgba(0,0,0,0.8); color:#0f0; padding:4px 8px; font-size:10px; font-family:monospace; z-index:20; display:none; border:1px solid #0f0;">
                </div>
                <div id="zoomLens"
                    style="position:absolute; width:180px; height:180px; border-radius:50%; border:2px solid var(--accent); overflow:hidden; pointer-events:none; display:none; z-index:25; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
                    <canvas id="lensCanvas" style="position:absolute; top:0; left:0;"></canvas>
                </div>
            </div>

            <!-- [LAYER BREAKDOWN] Bottom strip showing intermediate render steps
                 JS Logic: 'updateLayerPreviews' draws current state to these small canvases. -->
            <div class="preview-top">
                <h3 style="margin:0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Layer Breakdown
                </h3>
                <div style="font-size: 10px; color: var(--muted);">Click to view</div>
            </div>
            <div class="layer-preview-window">
                <div class="layer-grid" id="layerGrid">
                    <!-- Populated by setupLayerGridDOM (JS) -->
                </div>
            </div>
        </div>
    </div>

    <!-- [MODAL] Comparison & Export Tool
         Purpose: Side-by-side view of Original vs Processed for final output.
         JS Logic: Triggered by 'compareBtn', uses 'compareCanvas' for offline rendering. -->
    <div id="compareModal" class="modal-overlay">
        <div class="modal">
            <h2 style="margin-top:0">Comparison & Export</h2>
            <div style="display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap;">
                <div>
                    <div class="muted">Original</div>
                    <canvas id="compareOriginal"
                        style="max-height: 40vh; max-width: 40vw; border: 1px solid #333;"></canvas>
                </div>
                <div>
                    <div class="muted">Processed</div>
                    <canvas id="compareProcessed"
                        style="max-height: 40vh; max-width: 40vw; border: 1px solid #333;"></canvas>
                </div>
            </div>
            <div
                style="text-align: center; margin-bottom: 15px; background: rgba(0,0,0,0.3); padding: 10px; border: 1px solid #333;">
                <div style="font-size: 10px; color: var(--muted); text-transform: uppercase; margin-bottom: 5px;">
                    Rendering Technical Data</div>
                <div id="exportInfo" style="font-family: monospace; color: #0f0; font-size: 11px;">
                    Requested: -- x -- | Actual: -- x -- (Scale: 1.0)
                </div>
            </div>
            <div style="text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button id="exportSideBySide">Export Side-by-Side</button>
                <button id="exportStacked">Export Stacked</button>
                <button id="closeCompare">Close</button>
            </div>
        </div>
    </div>

    <!-- [WEBGL SHADERS] 
         These are the core GPU programs that process the image.
         Each fragment shader (fs-) corresponds to a specific tool or layer.
         The vertex shader (vs-) remains static, just mapping the 2D quad to the screen. -->

    <!-- [VS-QUAD] Basic Vertex Shader
         Purpose: Maps a full-screen triangle/quad to provide UV coordinates for the fragment shaders. -->
    <script type="x-shader/x-vertex" id="vs-quad">
#version 300 es
in vec2 a_pos;
in vec2 a_uv;
out vec2 v_uv;
void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}
</script>

    <!-- [FS-ADJUST] Image Adjustments Shader
         Purpose: Core color correction (Brightness, Contrast, Saturation, Warmth).
         Logic: Implements standard linear color manipulation and 3x3 sharpening kernel.
         JS Pointer: Used in 'renderSingleLayer' when layer type is 'adjust'. -->
    <script type="x-shader/x-fragment" id="fs-adjust">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform float u_sharpThresh;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Balanced Sharpening (USM Approximation)
    if (u_sharp > 0.0) {
        vec3 blurred = (
            texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2( 0.0,      -u_step.y)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2( u_step.x, -u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2(-u_step.x,  0.0)).rgb * 0.125 +
            texture(u_tex, v_uv).rgb * 0.25 +
            texture(u_tex, v_uv + vec2( u_step.x,  0.0)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y)).rgb * 0.0625 +
            texture(u_tex, v_uv + vec2( 0.0,       u_step.y)).rgb * 0.125 +
            texture(u_tex, v_uv + vec2( u_step.x,  u_step.y)).rgb * 0.0625
        );
        vec3 diff = rgb - blurred;
        // u_sharpThresh 0-100. 
        // A common threshold range for USM is 0.001 to 0.1 in luma. 
        // Let's use a scale that makes the slider feel responsive.
        float th = (u_sharpThresh / 100.0) * 0.1; 
        float factor = smoothstep(th, th * 1.5 + 0.001, length(diff));
        rgb += diff * (u_sharp / 15.0) * factor;
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script>

    <!-- [FS-MASK] Luminance Masking Shader
         Purpose: Generates a grayscale mask based on shadows and highlights thresholds.
         Logic: Uses 'smoothstep' on the dot product (luma) of RGB.
         JS Pointer: Used to generate textures for 'fs-noise' and 'fs-adjust' masking. -->
    <script type="x-shader/x-fragment" id="fs-mask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_useS; 
uniform int u_useH;
uniform float u_sth;
uniform float u_sfa;
uniform float u_hth;
uniform float u_hfa;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float l = dot(c.rgb, vec3(0.299,0.587,0.114));
    
    float sMask = 0.0;
    if (u_useS == 1) {
        float low = u_sth - u_sfa * 0.5;
        float high = u_sth + u_sfa * 0.5;
        sMask = 1.0 - smoothstep(low, high, l);
    }

    float hMask = 0.0;
    if (u_useH == 1) {
        float low = u_hth - u_hfa * 0.5;
        float high = u_hth + u_hfa * 0.5;
        hMask = smoothstep(low, high, l);
    }

    float combined = max(sMask, hMask);
    // Output: R=Combined, G=Shadow, B=Highlight
    outColor = vec4(combined, sMask, hMask, 1.0);
}
</script>

    <script type="x-shader/x-fragment" id="fs-colorMask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;
uniform float u_tolerance;
uniform float u_fade;

void main() {
    vec4 c = texture(u_tex, v_uv);
    float d = distance(c.rgb, u_targetColor);
    float mask = 1.0 - smoothstep(u_tolerance, u_tolerance + u_fade + 0.001, d);
    outColor = vec4(mask, mask, mask, 1.0);
}
</script>

    <!-- [FS-NOISE] Procedural Noise Generator
         Purpose: Creates the grain/texture.
         Logic: Uses a 'hash12' function for GPU-based randomness (Color or Grayscale).
         JS Pointer: Rendered into an offscreen framebuffer if 'noiseSize' > 0. -->
    <script type="x-shader/x-fragment" id="fs-noise">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform int u_type; 
uniform float u_seed;
uniform vec2 u_res;
uniform float u_scale;
uniform vec2 u_origRes; 
uniform float u_paramA;
uniform float u_paramB;
uniform float u_paramC;

float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec2 hash22(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

// Interleaved Gradient Noise
float IGN(vec2 p) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(p, magic.xy)));
}

float getBlue(vec2 p) {
    float white = IGN(p);
    float low = (IGN(p + vec2(1.0, 0.0)) + IGN(p - vec2(1.0, 0.0)) + IGN(p + vec2(0.0, 1.0)) + IGN(p - vec2(0.0, 1.0))) * 0.25;
    return clamp(white - low + 0.5, 0.0, 1.0); 
}

// Perlin Noise (Simple Value Noise variant for better GPU stability)
float perlin(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash12(i);
    float b = hash12(i + vec2(1.0, 0.0));
    float c = hash12(i + vec2(0.0, 1.0));
    float d = hash12(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

// Worley Noise
float worley(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);
    float d = 1.0;
    for(int y = -1; y <= 1; y++) {
        for(int x = -1; x <= 1; x++) {
            vec2 g = vec2(float(x), float(y));
            vec2 o = hash22(n + g);
            vec2 r = g + o - f;
            d = min(d, dot(r, r));
        }
    }
    return sqrt(d);
}

void main() {
    vec2 pos = v_uv * u_origRes; 
    float s = max(1.0, u_scale);
    vec2 cell = floor(pos / s);
    
    vec3 n;
    if (u_type == 1) { // Grayscale White
        n = vec3(hash12(cell + u_seed));
    } else if (u_type == 0) { // Color White
        n = vec3(hash12(cell + u_seed), hash12(cell + u_seed + 1.23), hash12(cell + u_seed + 2.45));
    } else if (u_type == 3) { // Blue Noise (Gray)
        n = vec3(getBlue(cell + u_seed * 11.0));
    } else if (u_type == 4) { // Blue Noise (Color)
        n = vec3(getBlue(cell + u_seed * 11.0), getBlue(cell + u_seed * 17.0 + 1.23), getBlue(cell + u_seed * 23.0 + 2.45));
    } else if (u_type == 5) { // Perlin (Cloudy)
        float octs = floor(u_paramA * 7.0) + 1.0; // 1-8 octaves
        float persistence = 0.5 + (u_paramC - 0.5) * 0.5;
        float noiseSum = 0.0;
        float amp = 1.0;
        float freq = 1.0 / (s * 10.0 + (u_paramB * 50.0));
        for(int i = 0; i < 8; i++) {
            if(float(i) >= octs) break;
            noiseSum += perlin(pos * freq + u_seed * 1.5) * amp;
            amp *= persistence;
            freq *= 2.0;
        }
        n = vec3(noiseSum);
    } else if (u_type == 6) { // Worley (Cellular)
        float jitter = u_paramA;
        float density = 1.0 / (s * 5.0 + (u_paramB * 20.0));
        vec2 p = pos * density;
        vec2 n_cell = floor(p);
        vec2 f = fract(p);
        float d = 1.0;
        for(int y = -1; y <= 1; y++) {
            for(int x = -1; x <= 1; x++) {
                vec2 g = vec2(float(x), float(y));
                vec2 o = hash22(n_cell + g) * jitter;
                vec2 r = g + o - f;
                float dist = mix(abs(r.x) + abs(r.y), length(r), u_paramC); // Morph between Manhattan and Euclidean
                d = min(d, dist);
            }
        }
        n = vec3(d);
    } else if (u_type == 7) { // Scanlines
        float thick = mix(0.1, 0.9, u_paramA);
        float jitter = (hash12(vec2(u_seed)) - 0.5) * u_paramB * 5.0;
        float line = sin((pos.y + jitter) / s * 3.14159) * 0.5 + 0.5;
        float val = step(thick, line);
        n = vec3(mix(val, val * hash12(cell + u_seed), u_paramC));
    } else if (u_type == 8) { // Speckle (Dust)
        float density = mix(0.8, 0.999, u_paramA);
        float h = hash12(cell + u_seed);
        float speck = smoothstep(density, density + mix(0.01, 0.1, u_paramB), h);
        float sizeVar = hash12(cell * 0.5 + u_seed);
        n = vec3(speck * mix(1.0, sizeVar, u_paramC));
    } else if (u_type == 9) { // Glitch
        float blockSize = s * (5.0 + u_paramA * 50.0);
        float block = floor(pos.y / blockSize);
        float shift = (hash12(vec2(block, u_seed)) - 0.5) * u_paramB * 100.0;
        float split = u_paramC * 10.0;
        n = vec3(
            hash12(floor((pos + vec2(shift - split, 0.0)) / s) + u_seed),
            hash12(floor((pos + vec2(shift, 0.0)) / s) + u_seed),
            hash12(floor((pos + vec2(shift + split, 0.0)) / s) + u_seed)
        );
    } else if (u_type == 10) { // Anisotropic (Fiber)
        float stretch = 0.01 + u_paramA * 0.5;
        float rot = u_paramB * 6.28;
        mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
        vec2 p = (m * pos) * vec2(stretch, 1.0) / s;
        float h = hash12(floor(p) + u_seed);
        n = vec3(mix(h, h * hash12(cell + u_seed), u_paramC));
    } else if (u_type == 11) { // Voronoi Mosaic
        float scale = 1.0 / (s * 10.0 + u_paramA * 40.0);
        vec2 p = pos * scale;
        vec2 n_cell = floor(p);
        vec2 f = fract(p);
        float d = 1.0;
        vec2 m_cell;
        for(int y = -1; y <= 1; y++) {
            for(int x = -1; x <= 1; x++) {
                vec2 g = vec2(float(x), float(y));
                vec2 o = hash22(n_cell + g) * u_paramB;
                vec2 r = g + o - f;
                float dist = dot(r, r);
                if (dist < d) { d = dist; m_cell = n_cell + g; }
            }
        }
        vec3 col = vec3(hash12(m_cell + u_seed), hash12(m_cell + u_seed + 1.1), hash12(m_cell + u_seed + 2.2));
        n = mix(col, vec3(sqrt(d)), u_paramC);
    } else if (u_type == 12) { // Crosshatch
        float dens = 1.0 / (s * (1.0 + u_paramA * 5.0));
        float angle = u_paramB * 1.57;
        mat2 m1 = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        mat2 m2 = mat2(cos(-angle), -sin(-angle), sin(-angle), cos(-angle));
        float l1 = step(0.8, sin((m1 * pos).x * dens) * 0.5 + 0.5);
        float l2 = step(0.8, sin((m2 * pos).x * dens) * 0.5 + 0.5);
        float hatch = max(l1, l2);
        n = vec3(mix(hatch, hatch * hash12(cell + u_seed), u_paramC));
    } else {
        n = vec3(hash12(cell + u_seed));
    }
    
    outColor = vec4(n, 1.0);
}
</script>

    <!-- [FS-BLUR] One-Pass Gaussian/Box Blur
         Purpose: Softens noise or image content.
         Logic: Samples 9 neighbors with exponential weights for Gaussian smoothing.
         JS Pointer: Called twice (Horizontal/Vertical) for separable high-quality blur. -->
    <script type="x-shader/x-fragment" id="fs-blur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (32 taps, directional)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = 1.0 - abs(i) / 16.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.0);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 5.0 * 5.0)); // Larger sigma for wider kernel
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s * weight;
            total += weight;
        }
    }
    outColor = color / total;
}
</script>

    <!-- [FS-COMPOSITE] Overlay & Blending Shader
         Purpose: Merges the procedural Noise layer with the original Image.
         Logic: Implements 'Normal', 'Overlay', 'Screen', 'Multiply', 'Add', and 'Difference' modes.
         JS Pointer: The final step of the Noise pass in 'renderSingleLayer'. -->
    <script type="x-shader/x-fragment" id="fs-composite">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_base;
uniform sampler2D u_noise;
uniform sampler2D u_mask;
uniform int u_mode;
uniform float u_opacity;
uniform float u_str; 
uniform int u_nType; 
uniform float u_satStr;
uniform float u_satImp;
uniform int u_ignA; 
uniform float u_ignAstr;
uniform float u_skinProt;

float overlay(float b, float n) {
    return b < 0.5 ? (2.0 * b * n) : (1.0 - 2.0 * (1.0 - b) * (1.0 - n));
}

float getSkinMask(vec3 rgb) {
    float r = rgb.r * 255.0;
    float g = rgb.g * 255.0;
    float b = rgb.b * 255.0;
    float cb = 128.0 + ( -0.168736 * r - 0.331264 * g + 0.5 * b );
    float cr = 128.0 + ( 0.5 * r - 0.418688 * g - 0.081312 * b );
    float dist = length(vec2(cr - 153.0, cb - 102.0)) / 30.0;
    return 1.0 - smoothstep(0.8, 1.2, dist);
}

void main() {
    vec4 bc = texture(u_base, v_uv);
    vec4 nc = texture(u_noise, v_uv);
    vec4 mc = texture(u_mask, v_uv); 
    vec3 n = nc.rgb;
    vec3 res;
    vec3 base = bc.rgb;
    
    if (u_nType == 2) {
        float noiseVal = nc.r; 
        float centered = (noiseVal - 0.5) * 2.0;
        float delta = centered * (u_satStr * (1.0 + u_satImp/100.0));
        float lum = dot(base, vec3(0.299,0.587,0.114));
        float effectStr = u_str/50.0;
        if (u_skinProt > 0.0) {
            float skin = getSkinMask(base);
            effectStr *= (1.0 - skin * (u_skinProt / 100.0));
        }
        vec3 satColor = mix(vec3(lum), base, 1.0 + delta * effectStr); 
        res = satColor;
    } else {
        vec3 noiseLayer = nc.rgb;
        if (u_mode == 0) { 
            res = mix(base, noiseLayer, u_opacity); 
        } else if (u_mode == 1) { 
            res.r = overlay(base.r, noiseLayer.r);
            res.g = overlay(base.g, noiseLayer.g);
            res.b = overlay(base.b, noiseLayer.b);
        } else if (u_mode == 2) { 
            res = 1.0 - (1.0 - base) * (1.0 - noiseLayer);
        } else if (u_mode == 3) { 
            res = base * noiseLayer;
        } else if (u_mode == 4) { 
            res = base + noiseLayer;
        } else if (u_mode == 5) { 
            res = abs(base - noiseLayer);
        }
        
        float maskVal = mc.r; 
        float alphaFactor = 1.0;
        if (u_ignA == 1) {
            alphaFactor = 1.0 - (u_ignAstr/100.0) * (1.0 - bc.a);
        }
        
        float finalOp = u_opacity * maskVal * alphaFactor * (u_str / 50.0); 
        
        if (u_skinProt > 0.0) {
            float skin = getSkinMask(base);
            finalOp *= (1.0 - skin * (u_skinProt / 100.0));
        }

        res = mix(base, res, clamp(finalOp, 0.0, 1.0));
    }

    outColor = vec4(clamp(res, 0.0, 1.0), bc.a);
}
</script>

    <!-- [FS-CHROMA] Chromatic Aberration Shader
         Purpose: Simulates lens color separation (fringing).
         Logic: Offsets Red, Green, and Blue channels based on radial distance from a center point.
         JS Pointer: Uses 'u_center' which is controlled by the 'caPin' DOM element. -->
    <script type="x-shader/x-fragment" id="fs-chroma">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform float u_amt;
uniform float u_blur;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

uniform float u_zoomBlur;
uniform int u_falloffToBlur;

void main() {
    if (u_amt <= 0.0 && u_blur <= 0.0 && u_zoomBlur <= 0.0) {
        outColor = texture(u_tex, v_uv);
        return;
    }
    
    vec2 dir = v_uv - u_center;
    float dist = length(dir);
    
    // Calculate clear zone mask
    float clearMask = 0.0;
    if (u_radius > 0.0 || u_falloff > 0.0) {
        clearMask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    }
    
    float blurStr = u_blur;
    float zoomStr = u_zoomBlur;
    if (u_falloffToBlur == 1) {
        blurStr *= (1.0 - clearMask);
        zoomStr *= (1.0 - clearMask);
    }

    // Calculate aberration strength based on distance from center
    float str = dist * dist * (u_amt / 1000.0); 
    str *= (1.0 - clearMask); 
    
    vec4 result = vec4(0.0);
    
    // We combine edge blur (directional jitter) and zoom blur (radial jitter)
    if (blurStr > 0.0 || zoomStr > 0.0) {
        float totalWeight = 0.0;
        for(float i = -2.0; i <= 2.0; i++) {
            float t = i * blurStr * 0.002; 
            // Zoom blur: samples along the 'dir' vector
            vec2 zoomOff = dir * (i * zoomStr * 0.02);
            float w = exp(-(i*i)/2.0); 
            
            float r = texture(u_tex, v_uv - dir * str + vec2(t, -t) + zoomOff).r;
            float g = texture(u_tex, v_uv + vec2(t*0.5, t*0.5) + zoomOff * 0.5).g; 
            float b = texture(u_tex, v_uv + dir * str + vec2(-t, t) + zoomOff * 1.5).b;
            
            result += vec4(r, g, b, 1.0) * w;
            totalWeight += w;
        }
        result /= totalWeight;
        result.a = texture(u_tex, v_uv).a;
    } else {
        float r = texture(u_tex, v_uv - dir * str).r;
        float g = texture(u_tex, v_uv).g;
        float b = texture(u_tex, v_uv + dir * str).b;
        float a = texture(u_tex, v_uv).a;
        result = vec4(r, g, b, a);
    }
    
    outColor = result;
}
</script>

    <!-- [FS-RADIAL] Radial Visualization Shader
         Purpose: Visualizes radial parameters like Chromatic Aberration falloff.
         Logic: Simple circular gradient based on radius and falloff uniforms. -->
    <script type="x-shader/x-fragment" id="fs-radial">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform vec2 u_res;
uniform vec2 u_center;
uniform float u_radius;
uniform float u_falloff;

void main() {
    float dist = length(v_uv - u_center);
    float mask = 1.0 - smoothstep(u_radius, u_radius + u_falloff, dist);
    outColor = vec4(vec3(mask), 1.0);
}
</script>

    <!-- [FS-PALETTE] Palette Mapping Shader
         Purpose: Constrains the image to a fixed set of colors.
         Logic: Finds the nearest neighbor in the uniform 'u_palette' array for every pixel.
         JS Pointer: Supports up to 256 colors; implements optional Gaussian pre-smoothing. -->
    <script type="x-shader/x-fragment" id="fs-palette">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_palette[256];
uniform int u_paletteSize;
uniform float u_blend;
uniform float u_smoothing;
uniform int u_smoothingType;
uniform vec2 u_res;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec2 texel = 1.0 / u_res;
    
    if (u_smoothing > 0.0) {
        float sumW = 0.0;
        vec3 sumC = vec3(0.0);
        float r = u_smoothing / 10.0; // Effective radius
        
        for(float i = -1.0; i <= 1.0; i++) {
            for(float j = -1.0; j <= 1.0; j++) {
                vec2 off = vec2(i, j) * texel * r;
                float weight = 1.0;
                
                if (u_smoothingType == 1) {
                    // 3x3 Gaussian Weights
                    float distSq = i*i + j*j;
                    weight = exp(-distSq / 1.0); // Simple Gaussian
                }
                
                sumC += texture(u_tex, v_uv + off).rgb * weight;
                sumW += weight;
            }
        }
        original = sumC / sumW;
    }
    
    if (u_paletteSize == 0) {
        outColor = c;
        return;
    }
    
    float minDist = 1e10;
    vec3 bestColor = u_palette[0];
    
    for (int i = 0; i < u_paletteSize; i++) {
        float d = distance(original, u_palette[i]);
        if (d < minDist) {
            minDist = d;
            bestColor = u_palette[i];
        }
    }
    
    vec3 res = mix(original, bestColor, u_blend);
    outColor = vec4(clamp(res, 0.0, 1.0), c.a);
}
</script>

    <!-- [FS-EDGE] Advanced Edge & Saturation Mask
         Purpose: Highlights edges (Edge Effects tool).
         Logic: 3x3 Sobel Convolution for edge detection + Bloom/Spread logic for soft masks.
         JS Pointer: Controlled by 'edgeMode' (Overlay vs Saturation Mask). -->
    <script type="x-shader/x-fragment" id="fs-edge">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;
uniform int u_mode; // 0=Overlay, 1=Saturation
uniform float u_strength;
uniform float u_tolerance;
uniform float u_bgSat;
uniform float u_fgSat;
uniform float u_bloom;
uniform float u_smooth;
uniform float u_blend;

float getLuma(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

void main() {
    vec2 texel = 1.0 / u_res;
    
    // Sobel Kernels
    float x = texel.x;
    float y = texel.y;
    
    float m00 = getLuma(texture(u_tex, v_uv + vec2(-x, -y)).rgb);
    float m01 = getLuma(texture(u_tex, v_uv + vec2( 0, -y)).rgb);
    float m02 = getLuma(texture(u_tex, v_uv + vec2( x, -y)).rgb);
    float m10 = getLuma(texture(u_tex, v_uv + vec2(-x,  0)).rgb);
    float m12 = getLuma(texture(u_tex, v_uv + vec2( x,  0)).rgb);
    float m20 = getLuma(texture(u_tex, v_uv + vec2(-x,  y)).rgb);
    float m21 = getLuma(texture(u_tex, v_uv + vec2( 0,  y)).rgb);
    float m22 = getLuma(texture(u_tex, v_uv + vec2( x,  y)).rgb);
    
    float gx = (m02 + 2.0*m12 + m22) - (m00 + 2.0*m10 + m20);
    float gy = (m00 + 2.0*m01 + m02) - (m20 + 2.0*m21 + m22);
    
    float edge = sqrt(gx*gx + gy*gy);
    
    // Threshold & Strength
    edge = smoothstep(u_tolerance / 100.0, (u_tolerance + 10.0) / 100.0, edge) * (u_strength / 100.0);
    edge = clamp(edge, 0.0, 1.0);
    
    vec4 c = texture(u_tex, v_uv);
    vec3 res = c.rgb;
    
    if (u_mode == 0) {
        // Overlay Mode
        res = mix(c.rgb, vec3(1.0), edge);
    } else {
        // Saturation Mask Mode
        float spreadMask = edge;
        if (u_bloom > 0.0) {
            // Efficient spatial spread: sample neighbors and take max
            float maxE = edge;
            float stepScale = u_bloom / 5.0; // Scale step size by bloom
            
            for(float i = -2.0; i <= 2.0; i += 1.0) {
                for(float j = -2.0; j <= 2.0; j += 1.0) {
                    if (i == 0.0 && j == 0.0) continue;
                    vec2 off = vec2(i, j) * texel * stepScale;
                    // Recalculate edge at neighbor (Simplified Sobel or just Luma diff?)
                    // For performance, we'll just use a slightly faster luma-based edge check for spread
                    vec3 nCol = texture(u_tex, v_uv + off).rgb;
                    float nLuma = getLuma(nCol);
                    // Standard Sobel is too heavy to run 25 times. 
                    // Let's use the luma difference from center as a proxy for "nearby edge"
                    float dist = length(vec2(i, j)) / 2.82; // Normalized dist
                    float e = smoothstep(u_tolerance / 100.0, (u_tolerance + 10.0) / 100.0, abs(nLuma - getLuma(c.rgb)) * 2.0);
                    maxE = max(maxE, e * (1.0 - dist * (u_smooth / 100.0)));
                }
            }
            spreadMask = clamp(maxE, 0.0, 1.0);
        }

        float lum = getLuma(c.rgb);
        vec3 bw = vec3(lum);
        
        // Background: Desaturated or partially saturated
        vec3 bg = mix(bw, c.rgb, u_bgSat / 100.0);
        // Foreground: Saturated
        vec3 fg = mix(bw, c.rgb, u_fgSat / 100.0);
        
        res = mix(bg, fg, spreadMask);
    }
    
    outColor = vec4(mix(c.rgb, res, u_blend / 100.0), c.a);
}
</script>

    <!-- [FS-COPY] Channel Swapping / Copy Shader
         Purpose: Extracts specific RGBA channels or creates a direct copy.
         Logic: Simple conditional selection of R, G, or B components.
         JS Pointer: Used for debug previews and mask visualization. -->
    <script type="x-shader/x-fragment" id="fs-copy">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_channel; 

void main() {
    vec4 c = texture(u_tex, v_uv);
    if (u_channel == 1) outColor = vec4(c.rrr, 1.0);
    else if (u_channel == 2) outColor = vec4(c.ggg, 1.0);
    else if (u_channel == 3) outColor = vec4(c.bbb, 1.0);
    else outColor = c;
}
</script>

    <!-- [FS-INVERT] Mask Inversion Shader
         Purpose: Flips the values of a grayscale mask (Black -> White).
         Logic: OutColor = 1.0 - Texture.
         JS Pointer: Used when the 'Invert Mask' checkbox is enabled. -->
    <script type="x-shader/x-fragment" id="fs-invert">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;

void main() {
    float mask = texture(u_tex, v_uv).r;
    float inv = 1.0 - mask;
    // We output inversed mask to R channel (and everything else for safety)
    outColor = vec4(inv, inv, inv, 1.0);
}
</script>

    <!-- [FS-DITHER] Color Quantization & Dithering
         Purpose: Reduces bit-depth while maintaining detail through patterns.
         Logic: Implements 8x8 Bayer Matrix and White Noise algorithms.
         JS Pointer: Used in the 'Dithering' tool; handles palette-size constraints. -->
    <script type="x-shader/x-fragment" id="fs-dither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

// 8x8 Bayer matrix (normalized to 0-1)
float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    // Bayer 8x8 pattern values
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

// Hash for noise dithering
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    
    // Calculate scaled position for dither pattern
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    // Get threshold value based on dither type
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    // Calculate quantization levels
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    // Apply dithering with strength
    vec3 dithered = col.rgb + threshold * (u_strength) * (1.0 / levels);
    
    // Quantize to bit depth
    dithered = floor(dithered * levels + 0.5) / levels;
    
    // Apply palette quantization
    dithered = floor(dithered * u_paletteSize + 0.5) / u_paletteSize;
    
    outColor = vec4(clamp(dithered, 0.0, 1.0), col.a);
}
</script>

    <!-- [FS-CORRUPTION] Digital Glitch & Artifact Shader
         Purpose: Simulates format degradation (JPEG, Pixelation, Bleeding).
         Logic: Samples from chunky coordinates to mimic 8x8 block artifacts.
         JS Pointer: Controlled by 'Corruption' algorithm selection. -->
    <script type="x-shader/x-fragment" id="fs-corruption">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform int u_algorithm; // 0=jpeg blocks, 1=pixelation, 2=color bleed
uniform float u_resScale; // 1-100 (lower = more corruption)
uniform vec2 u_res;
uniform float u_iteration; // current iteration for variation

void main() {
    // Calculate block size based on resolution scale (inverted: lower scale = bigger blocks)
    float blockSize = max(2.0, (100.0 - u_resScale) / 5.0 + 1.0);
    
    vec4 col;
    
    if (u_algorithm == 0) {
        // JPEG-like block artifacts
        vec2 blockPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        vec2 blockCenter = blockPos + (blockSize * 0.5) / u_res;
        
        // Sample from block center with some offset for artifact feel
        vec2 offset = (v_uv - blockPos) * u_res / blockSize;
        offset = floor(offset * 2.0) / 2.0 * blockSize / u_res;
        
        col = texture(u_tex, blockPos + offset);
        
        // Add slight color shifting at block edges
        vec2 edgeDist = abs(fract(v_uv * u_res / blockSize) - 0.5);
        float edge = smoothstep(0.3, 0.5, max(edgeDist.x, edgeDist.y));
        col.rgb = mix(col.rgb, col.rgb * 0.95, edge * 0.3);
        
    } else if (u_algorithm == 1) {
        // Pixelation - simple downscale/upscale
        vec2 pixelPos = floor(v_uv * u_res / blockSize) * blockSize / u_res;
        col = texture(u_tex, pixelPos + (blockSize * 0.5) / u_res);
        
    } else {
        // Color bleed - horizontal color smearing
        float bleedAmount = blockSize / u_res.x;
        vec4 left = texture(u_tex, v_uv - vec2(bleedAmount, 0.0));
        vec4 center = texture(u_tex, v_uv);
        vec4 right = texture(u_tex, v_uv + vec2(bleedAmount, 0.0));
        
        // Shift color channels
        col.r = mix(center.r, right.r, 0.3);
        col.g = center.g;
        col.b = mix(center.b, left.b, 0.3);
        col.a = center.a;
    }
    
    outColor = col;
}
</script>

    <!-- [FS-CELL] Cell Shading & Posterization
         Purpose: High-contrast illustrative look.
         Logic: Quantizes luminance into discrete bands + Sobel/Laplacian edge stroke.
         JS Pointer: Uses 'u_quantMode' to switch between Luma and RGB quantization. -->
    <script type="x-shader/x-fragment" id="fs-cell">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_levels;         // 2-12
uniform float u_bias;         // -1.0 to 1.0 (contrast bias)
uniform float u_gamma;        // 0.5 to 2.2
uniform int u_quantMode;      // 0=Luma, 1=RGB, 2=HSV
uniform int u_bandMap;        // 0=Linear, 1=Smooth, 2=Poster
uniform int u_edgeMethod;     // 0=None, 1=Sobel, 2=Laplc
uniform float u_edgeStr;      // 0-1
uniform float u_edgeThick;    // 0.5-3.0
uniform int u_colorPreserve;  // 0/1 bool
uniform int u_edgeEnable;     // 0/1 bool

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float getLuma(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

float quantize(float val, int levels, float bias, float gamma) {
    // Apply bias
    val = clamp(val + bias, 0.0, 1.0);
    
    // Apply gamma
    val = pow(val, gamma);
    
    // Quantize
    float fLevels = float(levels);
    float q = floor(val * fLevels) / (fLevels - 1.0);
    
    // Map output based on band mode
    if (u_bandMap == 1) { // Smooth
        q = smoothstep(0.0, 1.0, q);
    } else if (u_bandMap == 2) { // Posterize hard
        q = floor(val * fLevels) / fLevels; 
    }
    
    return q;
}

float sobel(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l00 = getLuma(texture(u_tex, uv + vec2(-px.x, -px.y)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l20 = getLuma(texture(u_tex, uv + vec2(px.x, -px.y)).rgb);
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l02 = getLuma(texture(u_tex, uv + vec2(-px.x, px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l22 = getLuma(texture(u_tex, uv + vec2(px.x, px.y)).rgb);
    
    float gx = l00 + 2.0*l01 + l02 - (l20 + 2.0*l21 + l22);
    float gy = l00 + 2.0*l10 + l20 - (l02 + 2.0*l12 + l22);
    
    return sqrt(gx*gx + gy*gy);
}

float laplacian(vec2 uv) {
    vec2 px = vec2(u_edgeThick, u_edgeThick) / u_res;
    float l01 = getLuma(texture(u_tex, uv + vec2(-px.x, 0.0)).rgb);
    float l21 = getLuma(texture(u_tex, uv + vec2(px.x, 0.0)).rgb);
    float l10 = getLuma(texture(u_tex, uv + vec2(0.0, -px.y)).rgb);
    float l12 = getLuma(texture(u_tex, uv + vec2(0.0, px.y)).rgb);
    float l11 = getLuma(texture(u_tex, uv).rgb); // Center
    
    return abs(l01 + l21 + l10 + l12 - 4.0 * l11) * 2.0;
}

void main() {
    vec4 base = texture(u_tex, v_uv);
    vec3 col = base.rgb;
    
    // Apply Quantization
    vec3 res = col;
    if (u_quantMode == 0) { // Luma
        float l = getLuma(col);
        float q = quantize(l, u_levels, u_bias, u_gamma);
        if (u_colorPreserve == 1) {
            // Preserve color, only quantize lightness
            vec3 hsv = rgb2hsv(col);
            hsv.z = q;
            res = hsv2rgb(hsv);
        } else {
            res = vec3(q);
        }
    } else if (u_quantMode == 1) { // RGB
        res.r = quantize(col.r, u_levels, u_bias, u_gamma);
        res.g = quantize(col.g, u_levels, u_bias, u_gamma);
        res.b = quantize(col.b, u_levels, u_bias, u_gamma);
    } else { // HSV Value
        vec3 hsv = rgb2hsv(col);
        hsv.z = quantize(hsv.z, u_levels, u_bias, u_gamma);
        res = hsv2rgb(hsv);
    }
    
    // Apply Edges
    if (u_edgeEnable == 1 && u_edgeMethod > 0) {
        float edge = 0.0;
        if (u_edgeMethod == 1) edge = sobel(v_uv);
        else if (u_edgeMethod == 2) edge = laplacian(v_uv);
        
        edge = smoothstep(0.1, 1.0, edge * 2.0); // Boost edge visibility
        res = mix(res, vec3(0.0), edge * u_edgeStr);
    }
    
    outColor = vec4(res, base.a);
}
</script>

    <!-- [FS-HALFTONE] Print Media Halftoning
         Purpose: Simulates ink dots or line screens.
         Logic: CMYK conversion + Rotated coordinate sampling for pattern grids.
         JS Pointer: Offers Circular, Line, Cross, and Diamond pattern types. -->
    <script type="x-shader/x-fragment" id="fs-halftone">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform float u_size;           // 1-12
uniform float u_intensity;      // 0-1
uniform float u_sharpness;      // 0-1
uniform int u_pattern;          // 0=Circ, 1=Line, 2=Cross, 3=Diamond
uniform int u_colorMode;        // 0=Luma, 1=RGB, 2=CMY, 3=CMYK
uniform int u_sample;           // 0=Center, 1=Avg
uniform int u_gray;             // Bool
uniform int u_lock;             // Bool
uniform int u_invert;           // Bool

float getPattern(vec2 uv, float angle) {
    float s = sin(angle), c = cos(angle);
    vec2 p = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y) * u_res / u_size; // Map to pattern space
    vec2 grid = fract(p) - 0.5;
    
    float d = 0.0;
    if (u_pattern == 0) { // Circle
        d = length(grid) * 2.0; // 0-1 range center to corner
    } else if (u_pattern == 1) { // Line
        d = abs(grid.y) * 2.0;
    } else if (u_pattern == 2) { // Cross
        d = min(abs(grid.x), abs(grid.y)) * 2.0;
    } else { // Diamond
        d = (abs(grid.x) + abs(grid.y));
    }
    
    return d; // 0 at center/peak, 1 at edge
}

void main() {
    float angle = 0.0; // Default angle
    if (u_sample == 2) angle = 0.785; // 45 deg for rotated
    
    vec2 sampleUV = v_uv;
    if (u_lock == 0) {
        // Pattern follows image (UV space), scale by res ratio to keep square dots
        // Actually simpler: just rely on u_size scaling against u_res
    }
    
    vec4 col = texture(u_tex, v_uv);
    
    // Halftone Logic
    vec3 outRGB = vec3(0.0);
    
    if (u_colorMode == 0) { // Luminance
        float l = dot(col.rgb, vec3(0.299, 0.587, 0.114));
        float pat = getPattern(v_uv, 0.785); // 45 degree default for mono
        
        // Threshold
        // Pattern goes 0(black) to 1(white). Luma 0(black) to 1(white).
        // Standard HT: if luma > pattern -> white. 
        // With intensity: mix pattern with luma.
        
        // Soft edge based on sharpness
        float thresh = 1.0 - l * u_intensity; // Invert luma for pattern comparison
        float softness = 1.0 - u_sharpness;
        float val = smoothstep(thresh - softness, thresh + softness, pat);
        
        if (u_invert == 1) val = 1.0 - val;
        outRGB = vec3(val);
        
    } else if (u_colorMode == 1) { // RGB
        // Separate angles for R, G, B
        float pR = getPattern(v_uv, 0.26); // ~15 deg
        float pG = getPattern(v_uv, 1.30); // ~75 deg
        float pB = getPattern(v_uv, 0.0);  // 0 deg
        
        float soft = 1.0 - u_sharpness;
        
        float r = smoothstep((1.0 - col.r) - soft, (1.0 - col.r) + soft, pR);
        float g = smoothstep((1.0 - col.g) - soft, (1.0 - col.g) + soft, pG);
        float b = smoothstep((1.0 - col.b) - soft, (1.0 - col.b) + soft, pB);
        
        outRGB = vec3(r, g, b);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
        
    } else { // CMY / CMYK
        // Simple RGB -> CMY
        vec3 cmy = 1.0 - col.rgb;
        float k = 0.0;
        if (u_colorMode == 3) { // CMYK
            k = min(min(cmy.x, cmy.y), cmy.z);
            cmy = (cmy - k) / (1.0 - k);
        }
        
        // Angles: C=15, M=75, Y=0, K=45
        float pC = getPattern(v_uv, 0.26);
        float pM = getPattern(v_uv, 1.30);
        float pY = getPattern(v_uv, 0.0);
        float pK = getPattern(v_uv, 0.785);
        
        float soft = 1.0 - u_sharpness;
        
        // Halftone each channel (0=white, 1=ink). 
        // If pattern < ink_amount -> ink. 
        // Pattern 0(center) to 1(edge). Ink 0(none) to 1(full).
        // If pattern < cmy.r => ink.
        // Invert comparison for white checks?
        // Let's use: if pattern > (1.0 - ink) -> ink ?? No.
        
        // Standard: dot grows from center (0). so if pattern < ink -> ink.
        float hC = 1.0 - smoothstep(cmy.x - soft, cmy.x + soft, pC);
        float hM = 1.0 - smoothstep(cmy.y - soft, cmy.y + soft, pM);
        float hY = 1.0 - smoothstep(cmy.z - soft, cmy.z + soft, pY);
        float hK = 1.0 - smoothstep(k - soft, k + soft, pK);
        
        // Combine CMYK -> RGB
        // white - ink
        vec3 resCMY = vec3(hC, hM, hY);
        if (u_colorMode == 3) resCMY += vec3(hK);
        
        outRGB = 1.0 - clamp(resCMY, 0.0, 1.0);
        if (u_invert == 1) outRGB = 1.0 - outRGB;
    }
    
    if (u_gray == 1) {
        float l = dot(outRGB, vec3(0.299, 0.587, 0.114));
        outRGB = vec3(l);
    }
    
    outColor = vec4(outRGB, col.a);
}
</script>

    <!-- [FS-BILATERAL] Edge-Preserving Denoise
         Purpose: Smooths surfaces (like skin) while keeping sharp edges intact.
         Logic: Two-weight filter (Spatial + Range/Color similarity).
         JS Pointer: High-performance iteration loop in the rendering pipeline. -->
    <script type="x-shader/x-fragment" id="fs-bilateral">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

// Controls
uniform int u_radius;        // 1-30
uniform float u_sigmaCol;    // 0.01 - 1.0
uniform float u_sigmaSpace;  // 0.5 - 15.0
uniform int u_kernel;        // 0=Gauss, 1=Box
uniform int u_edgeMode;      // 0=Luma, 1=RGB

float getDist(vec3 c1, vec3 c2) {
    if (u_edgeMode == 0) {
        float l1 = dot(c1, vec3(0.299, 0.587, 0.114));
        float l2 = dot(c2, vec3(0.299, 0.587, 0.114));
        return abs(l1 - l2);
    } else {
        return length(c1 - c2);
    }
}

void main() {
    vec4 centerCol = texture(u_tex, v_uv);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;
    
    // Separable optimization not easy for true bilateral without ping-pong
    // We will do a full kernel loop but skip somewhat to save perf if radius is high?
    // No, standard loop.
    
    int r = u_radius;
    float fs = u_sigmaSpace;
    float fc = u_sigmaCol;
    
    for (int x = -r; x <= r; x++) {
        for (int y = -r; y <= r; y++) {
            vec2 offset = vec2(float(x), float(y));
            vec2 uv = v_uv + offset / u_res;
            
            vec3 samp = texture(u_tex, uv).rgb;
            
            float spaceDistSq = dot(offset, offset);
            float colorDist = getDist(centerCol.rgb, samp);
            
            float wSpace = 1.0;
            if (u_kernel == 0) wSpace = exp(-spaceDistSq / (2.0 * fs * fs));
            
            float wColor = exp(-(colorDist * colorDist) / (2.0 * fc * fc));
            
            float w = wSpace * wColor;
            
            sum += samp * w;
            weightSum += w;
        }
    }
    
    outColor = vec4(sum / weightSum, centerCol.a);
}
</script>

    <!-- [FS-COLOR-MASK] Color-Based Selection Shader
         Purpose: Creates a mask based on color proximity (Eyedropper / Color Exclude).
         Logic: Calculates Euclidean distance between pixel color and target color.
         JS Pointer: Used to generate exclusion masks for Adjustments and Noise. -->
    <script type="x-shader/x-fragment" id="fs-colorMask">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec3 u_targetColor;  // RGB 0-1
uniform float u_tolerance;   // 0-1
uniform float u_fade;        // 0-1

void main() {
    vec4 c = texture(u_tex, v_uv);
    float dist = length(c.rgb - u_targetColor);
    float low = u_tolerance - u_fade * 0.5;
    float high = u_tolerance + u_fade * 0.5;
    float mask = smoothstep(low, high, dist);
    // mask = 0 when color matches (to exclude), 1 elsewhere
    outColor = vec4(mask, mask, mask, 1.0);
}
</script>

    <!-- [FS-MASKED-BLUR] Mask-Aware Blur Shader
         Purpose: Applies blur only to areas defined by a grayscale mask.
         Logic: Supports Gaussian, Box, and Motion blur types; lerps between original and blurred.
         JS Pointer: Used for high-quality localized softening. -->
    <script type="x-shader/x-fragment" id="fs-maskedBlur">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform vec2 u_dir; 
uniform float u_rad;
uniform int u_blurType; // 0=Gaussian, 1=Box, 2=Motion

void main() {
    float maskVal = texture(u_mask, v_uv).r;
    vec4 original = texture(u_tex, v_uv);
    
    if (maskVal < 0.01) {
        outColor = original;
        return;
    }
    
    vec4 color = vec4(0.0);
    float total = 0.0;
    
    if (u_blurType == 1) {
        // Box blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s;
            total += 1.0;
        }
    } else if (u_blurType == 2) {
        // Motion blur (32 taps, directional)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = 1.0 - abs(i) / 16.0;
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 1.0);
            color += s * weight;
            total += weight;
        }
    } else {
        // Gaussian blur (32 taps)
        for(float i = -15.0; i <= 16.0; i++) {
            float weight = exp(-(i*i) / (2.0 * 5.0 * 5.0)); 
            vec4 s = texture(u_tex, v_uv + u_dir * i * u_rad * 0.5);
            color += s * weight;
            total += weight;
        }
    }
    
    vec4 blurred = color / total;
    outColor = mix(original, blurred, maskVal);
}
</script>

    <!-- [FS-MASKED-DITHER] Mask-Aware Dithering Shader
         Purpose: Constrains bit-reduction to specific image regions.
         Logic: Combines Bayer/Noise dithering algorithms with a mask weighting factor.
         JS Pointer: Part of the 'Dithering' tool logic. -->
    <script type="x-shader/x-fragment" id="fs-maskedDither">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_type; // 0=bayer, 1=noise
uniform float u_bitDepth;
uniform float u_paletteSize;
uniform float u_strength;
uniform float u_scale;
uniform vec2 u_res;
uniform float u_seed;

float bayer8x8(vec2 pos) {
    int x = int(mod(pos.x, 8.0));
    int y = int(mod(pos.y, 8.0));
    int index = x + y * 8;
    int pattern[64] = int[64](
         0, 32,  8, 40,  2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44,  4, 36, 14, 46,  6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
         3, 35, 11, 43,  1, 33,  9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47,  7, 39, 13, 45,  5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    );
    return float(pattern[index]) / 64.0;
}

float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void main() {
    vec4 col = texture(u_tex, v_uv);
    float maskVal = texture(u_mask, v_uv).r;
    
    if (maskVal < 0.01) {
        outColor = col;
        return;
    }
    
    vec2 scaledPos = floor(v_uv * u_res / max(1.0, u_scale));
    
    float threshold;
    if (u_type == 0) {
        threshold = bayer8x8(scaledPos) - 0.5;
    } else {
        threshold = hash12(scaledPos + u_seed) - 0.5;
    }
    
    float levels = pow(2.0, u_bitDepth);
    float paletteDiv = 256.0 / u_paletteSize;
    
    // Corrected strength: u_strength is 0-1 from JS, matching fs-dither logic
    vec3 dithered = col.rgb + threshold * (u_strength) * (1.0 / levels);
    
    // Low bit-depth quantized color
    vec3 quantized = floor(dithered * levels + 0.5) / levels;
    quantized = floor(quantized * u_paletteSize + 0.5) / u_paletteSize;
    
    // Smooth LERP between original and low-depth dithered
    vec3 result = mix(col.rgb, quantized, maskVal);
    
    outColor = vec4(clamp(result, 0.0, 1.0), col.a);
}
</script>

    <!-- [FS-ADJUST-MASKED] Mask-Aware Adjustment Shader
         Purpose: Applies basic adjustments (Contrast, etc.) through a variable mask.
         Logic: Direct extension of FS-ADJUST with a final mix step based on u_mask.
         JS Pointer: Main processor for the 'Adjustments' tool. -->
    <script type="x-shader/x-fragment" id="fs-adjustMasked">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform sampler2D u_mask;
uniform int u_useMask;
uniform float u_bright;
uniform float u_cont;
uniform float u_sat;
uniform float u_hdrTol;
uniform float u_hdrAmt;
uniform float u_warmth;
uniform float u_sharp;
uniform float u_sharpThresh;
uniform vec2 u_step;

void main() {
    vec4 c = texture(u_tex, v_uv);
    vec3 original = c.rgb;
    vec3 rgb = c.rgb;

    // Saturation
    float lum = dot(rgb, vec3(0.299,0.587,0.114));
    rgb = mix(vec3(lum), rgb, 1.0 + u_sat);

    // Contrast
    rgb = (rgb - 0.5) * (1.0 + u_cont/100.0) + 0.5;

    // Brightness
    rgb += u_bright/100.0;

    // Warmth
    if (u_warmth != 0.0) {
        vec3 warmColor = vec3(1.0, 0.9, 0.8); 
        vec3 coolColor = vec3(0.8, 0.9, 1.1); 
        float t = clamp(u_warmth / 100.0, -1.0, 1.0);
        vec3 tint = mix(coolColor, warmColor, t * 0.5 + 0.5);
        float mask = smoothstep(0.0, 1.0, lum);
        rgb = mix(rgb, rgb * tint, abs(t) * mask);
    }

    // Sharpening
    if (u_sharp > 0.0) {
        vec4 sum = vec4(0.0);
        sum += texture(u_tex, v_uv + vec2(-u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x, -u_step.y));
        sum += texture(u_tex, v_uv + vec2(-u_step.x,  u_step.y));
        sum += texture(u_tex, v_uv + vec2( u_step.x,  u_step.y));
        vec4 edge = c - (sum * 0.25);
        rgb += edge.rgb * (u_sharp / 10.0); 
    }

    // HDR Emulation
    float l = dot(rgb, vec3(0.299,0.587,0.114));
    if (l < u_hdrTol && u_hdrTol > 0.0) {
        float f = (u_hdrAmt/100.0) * (1.0 - l/u_hdrTol);
        rgb *= (1.0 - f);
    }

    // Apply mask if enabled
    if (u_useMask == 1) {
        float maskVal = texture(u_mask, v_uv).r;
        rgb = mix(original, rgb, maskVal);
    }

    outColor = vec4(clamp(rgb, 0.0, 1.0), c.a);
}
</script>



    <script>
        // --- GLOBAL STATE ---
        /** 
         * The 'state' object holds the single source of truth for the application.
         * It manages WebGL resources (gl, programs, textures, fbos), 
         * render stack configuration (renderOrder), and persistent user settings.
         */
        const state = {
            gl: null,             // The WebGL2RenderingContext instance
            canvas: null,         // The main #displayCanvas DOM element
            programs: {},         // Map of compiled Shader Programs (id -> WebGLProgram)
            textures: {},         // Map of reusable WebGL textures (e.g. 'base', 'noise')
            fbos: {},             // Map of Framebuffer Objects for intermediate render steps
            pingPong: [null, null], // Double-buffer for iterative effects like Bilateral Filter
            thumbnailFBO: null,
            baseImage: null,      // The original HTMLImageElement uploaded by the user
            imageFiles: [],       // Array of image file handles for multi-image mode
            currentImageIndex: 0, // Index for the imageFiles array
            isMultiImageMode: false, // Are we editing a single image or a folder?
            isExporting: false,   // Is a batch export in progress?
            playInterval: null,   // Interval ID for the play feature
            isPlaying: false,     // Is the animation playing?
            lastFrameTime: 0,     // Timestamp of the last rendered frame
            realtimeFps: 0,       // Calculated real-time FPS
            frameRenderCount: 0,  // Counter to periodically update FPS display
            width: 1,             // Original image width
            height: 1,            // Original image height
            renderWidth: 1,       // Scaled viewport width
            renderHeight: 1,      // Scaled viewport height
            fboWidth: 0,          // Actual pixel width of offscreen buffers
            fboHeight: 0,         // Actual pixel height of offscreen buffers
            busy: false,          // Mutex to prevent overlapping render calls
            upscaleFactor: 1,     // Multiplier for export-quality rendering (1x-10x)
            // The pipeline order: processed from first to last
            renderOrder: ['noise', 'adjust', 'hdr', 'ca', 'blur', 'cell', 'halftone', 'bilateral', 'dither', 'palette', 'edge', 'corruption'],
            activeLayerPreview: null,
            activeSection: 'adjust', // Currently open UI section (used for 'Isolated' previews)
            caCenter: { x: 0.5, y: 0.5 }, // UV coordinates for Chromatic Aberration center
            isDraggingPin: false,
            layerTextures: {},    // Stores the results of each layer for the 'Breakdown' view
            layerVisibility: { noise: true, adjust: true, hdr: true, ca: true, blur: true, cell: true, halftone: true, bilateral: true, dither: true, palette: true, edge: true, corruption: true },
            palette: [],          // Current list of Hex colors for Palette Reconstructor
            lastExtractionImage: null,
            pinIdleTimer: null,
            isPreviewLocked: false, // Prevents the original-hover-compare overlay
            clampPreview: true,     // Default safety: limit preview to 2048px
            isZoomLocked: false,    // Tab key toggle to stay at a specific spot
            lastMousePos: { x: 0, y: 0 },
            isZooming: false,       // Current active zoom operation
            isLensMode: false,      // Toggle between FULL and LENS zoom
            keepFolderStructure: false, // Toggle to preserve folder structure on export
            allFiles: []            // Array of all files (including non-images) for full replica export
        };

        /** 'UI' is a cache of DOM element references. 
         *  Populated automatically during init to avoid redundant document.getElementById calls. */
        const UI = {};

        /** 'LAYERS' provides user-facing metadata for each pipeline step. */
        const LAYERS = {
            'noise': { name: 'Noise Group', color: '#fff' },
            'adjust': { name: 'Adjustments', color: '#fff' },
            'hdr': { name: 'HDR Emulation', color: '#fff' },
            'ca': { name: 'Chromatic Aberration', color: '#fff' },
            'blur': { name: 'Blur', color: '#fff' },
            'cell': { name: 'Cell Shading', color: '#fff' },
            'halftone': { name: 'Halftoning', color: '#fff' },
            'bilateral': { name: 'Bilateral Filter', color: '#fff' },
            'dither': { name: 'Dithering', color: '#fff' },
            'palette': { name: 'Palette Reconstructor', color: '#fff' },
            'edge': { name: 'Edge Effects', color: '#fff' },
            'corruption': { name: 'Corruption', color: '#fff' },
            'shadows': { name: 'Shadows Mask', color: '#fff' },
            'highlights': { name: 'Highlights Mask', color: '#fff' }
        };

        // --- INIT ---
        /** Entry point: Initializes WebGL, UI bindings, and default state. */
        window.addEventListener('DOMContentLoaded', async () => {
            // [DOM COLLECTION] Auto-populate UI object for fast reference
            document.querySelectorAll('input, select, button, canvas').forEach(el => {
                if (el.id) UI[el.id] = el;
            });
            // Additional containers
            UI.layerGrid = document.getElementById('layerGrid');
            UI.previewContainer = document.getElementById('previewContainer');
            UI.overlayOriginal = document.getElementById('overlayOriginal');
            UI.loading = document.getElementById('loading');
            UI.hoverZoomValue = document.getElementById('hoverZoomValue');
            UI.hoverZoomSlider = document.getElementById('hoverZoomSlider'); // Fix: Targeted input directly
            UI.zoomResIndicator = document.getElementById('zoomResIndicator');
            UI.loadFolderBtn = document.getElementById('loadFolderBtn');
            UI.prevImageBtn = document.getElementById('prevImageBtn');
            UI.nextImageBtn = document.getElementById('nextImageBtn');
            UI.imageCounter = document.getElementById('imageCounter');
            UI.imageScrubber = document.getElementById('imageScrubber');
            UI.playBtn = document.getElementById('playBtn');
            UI.playFps = document.getElementById('playFps');
            UI.actualFps = document.getElementById('actualFps');
            UI['export-overlay'] = document.getElementById('export-overlay');
            UI['export-status'] = document.getElementById('export-status');
            UI.stopExportBtn = document.getElementById('stopExportBtn');

            // Critical interactive elements (might not be input/button tags)
            UI.caPin = document.getElementById('caPin');
            UI.previewLock = document.getElementById('previewLock');
            UI.resetCenterBtn = document.getElementById('resetCenterBtn');
            UI.upscaleInput = document.getElementById('upscaleInput');
            UI.clampPreviewToggle = document.getElementById('clampPreviewToggle');
            UI.gpuMaxRes = document.getElementById('gpuMaxRes');
            UI.exportInfo = document.getElementById('exportInfo');
            UI.zoomLens = document.getElementById('zoomLens');
            UI.lensToggleBtn = document.getElementById('lensToggleBtn');
            UI.lensCanvas = document.getElementById('lensCanvas');

            // Explicitly collect Blur/Dither controls to ensure no initialization race conditions
            const manualIds = [
                'blurEnable', 'blurAmount', 'blurType',
                'blurColorExclude', 'blurTargetColor', 'blurColorTolerance', 'blurColorFade',
                'blurLumaMask', 'blurShadowThreshold', 'blurShadowFade', 'blurHighlightThreshold', 'blurHighlightFade',
                'ditherEnable', 'ditherBitDepth', 'ditherPaletteSize', 'ditherStrength', 'ditherScale', 'ditherType',
                'ditherColorExclude', 'ditherExcludeColor', 'ditherColorTolerance', 'ditherColorFade',
                'ditherLumaMask', 'ditherShadowThreshold', 'ditherShadowFade', 'ditherHighlightThreshold', 'ditherHighlightFade',
                'paletteEnable', 'paletteBlend', 'paletteSmoothing', 'paletteSmoothingType', 'paletteList', 'extractCount',
                'edgeEnable', 'edgeBlend', 'edgeMode', 'edgeStrength', 'edgeTolerance', 'edgeFgSat', 'edgeBgSat', 'edgeBloom', 'edgeSmooth', 'edgeSatControls'
            ];
            manualIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) UI[id] = el;
            });

            // [TABS] Handle navigation between 'Controls' and 'Render Layer Order'
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    e.target.classList.add('active');
                    document.getElementById(e.target.dataset.tab).classList.add('active');
                });
            });

            // [SIDEBAR] Only one section open at a time logic
            document.querySelectorAll('#controls details').forEach(details => {
                details.addEventListener('toggle', (e) => {
                    if (details.open) {
                        document.querySelectorAll('#controls details').forEach(other => {
                            if (other !== details && other.open) other.open = false;
                        });

                        // Update active section logic
                        const input = details.querySelector('input, select');
                        if (input) {
                            const section = getSectionFromId(input.id);
                            if (section) {
                                state.activeSection = section;
                                requestRender();
                            }
                        }
                    }
                });
            });

            setupDragLayerList();

            // [VALUE BINDING] Sync range sliders with their adjacent text indicators
            document.querySelectorAll('input[type=range]').forEach(range => {
                const text = range.nextElementSibling;
                if (text && text.classList.contains('control-value')) {
                    const update = () => text.value = range.value;
                    range.addEventListener('input', () => { update(); requestRender(); });
                    update();
                }
            });

            // Specific Listener for Zoom to update State
            if (UI.hoverZoomValue) {
                UI.hoverZoomValue.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!isNaN(val)) state.zoomLevel = val;
                    // requestRender handled by generic listener above? 
                    // No, generic listener only attaches if next element is control-value.
                    // Checking HTML: does hoverZoomValue have sibling? 
                    // Safer to call requestRender here too.
                    requestRender();
                });
            }
            document.querySelectorAll('select, input[type=checkbox], input[type=color]').forEach(el => {
                el.addEventListener('change', () => {
                    if (el.id === 'clampPreviewToggle') {
                        // "High Quality Preview" checked = No Clamping
                        state.clampPreview = !el.checked;
                        // Always respect the current zoom state when flipping resolution limits
                        reallocateBuffers(state.isZooming);
                    }
                    requestRender();
                });
                el.addEventListener('input', requestRender);
            });

            UI.edgeMode.addEventListener('change', () => {
                UI.edgeSatControls.style.display = UI.edgeMode.value === '1' ? 'block' : 'none';
            });
            // Initial trigger
            UI.edgeMode.dispatchEvent(new Event('change'));

            // Palette buttons
            const getRandomHex = () => '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');

            UI.addPaletteColor.addEventListener('click', () => {
                state.palette.push(getRandomHex());
                updatePaletteUI();
                requestRender();
            });

            // Palette Canvas Picker Logic
            // Create a hidden input for the canvas picker to target
            const palettePickerInput = document.createElement('input');
            palettePickerInput.id = 'pickPaletteColor';
            palettePickerInput.type = 'color';
            palettePickerInput.style.display = 'none';
            document.body.appendChild(palettePickerInput);
            UI.pickPaletteColorInput = palettePickerInput;

            palettePickerInput.addEventListener('change', (e) => {
                state.palette.push(e.target.value);
                updatePaletteUI();
                requestRender();
            });

            UI.clearPalette.addEventListener('click', () => {
                state.palette = [];
                updatePaletteUI();
                requestRender();
            });
            UI.randomPalette.addEventListener('click', () => {
                const len = state.palette.length;
                if (len === 0) {
                    const count = Math.floor(Math.random() * 5) + 3;
                    const newPalette = new Set();
                    while (newPalette.size < count) newPalette.add(getRandomHex());
                    state.palette = Array.from(newPalette);
                } else {
                    for (let i = 0; i < len; i++) {
                        state.palette[i] = getRandomHex();
                    }
                }
                updatePaletteUI();
                requestRender();
            });

            UI.extractPalette.addEventListener('click', () => UI.paletteImageUpload.click());
            UI.paletteImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        state.lastExtractionImage = img;
                        const count = parseInt(UI.extractCount?.value || 8);
                        extractPaletteFromImage(img, count);
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            });

            UI.extractCount.addEventListener('input', () => {
                if (state.lastExtractionImage) {
                    const count = parseInt(UI.extractCount.value);
                    extractPaletteFromImage(state.lastExtractionImage, count);
                }
            });

            // Lock Toggle Logic
            UI.previewLock.addEventListener('change', (e) => {
                state.isPreviewLocked = e.target.checked;
                if (state.isPreviewLocked) {
                    UI.overlayOriginal.classList.remove('show');
                }
            });

            // [UPSCALE] Handles the multiplier for the rendering buffers.
            UI.upscaleInput.addEventListener('change', (e) => {
                let val = parseInt(e.target.value);
                if (isNaN(val) || val < 1) val = 1;
                if (val > 10) val = 10;
                e.target.value = val;
                state.upscaleFactor = val;
                if (state.baseImage) {
                    reallocateBuffers(false); // Rebuild WebGL textures at new size
                    requestRender();
                }
            });

            // [PIN INTERACTIONS] Chromatic Aberration Center Control
            // Purpose: Allows users to drag the center of the CA effect on the preview.
            // Logic: Maps DOM mouse coordinates to normalized 0.0-1.0 UV space for the shader.
            UI.resetCenterBtn.addEventListener('click', () => {
                state.caCenter = { x: 0.5, y: 0.5 };
                updatePinPosition();
                requestRender();
            });

            UI.caPin.addEventListener('mousedown', (e) => {
                state.isDraggingPin = true;
                // Lock logic: If globally locked, just keep preview. If not, hide overlay.
                if (!state.isPreviewLocked) UI.overlayOriginal.classList.remove('show');
                clearTimeout(state.pinIdleTimer);
                e.preventDefault();
            });

            window.addEventListener('mouseup', () => {
                if (state.isDraggingPin) {
                    state.isDraggingPin = false;
                    // Idle timer only matters if not locked
                    if (!state.isPreviewLocked) {
                        state.pinIdleTimer = setTimeout(() => {
                            UI.overlayOriginal.classList.add('show');
                        }, 4000);
                    }
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (!state.isDraggingPin) return;
                const rect = UI.previewContainer.getBoundingClientRect();
                let x = (e.clientX - rect.left) / rect.width;
                let y = 1.0 - (e.clientY - rect.top) / rect.height;
                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                state.caCenter = { x, y };
                updatePinPosition();
                requestRender();
            });

            // [HOVER ZOOM & LENS] High-Resolution Detail Viewer
            // Purpose: Full-screen scaling OR circular lens magnification on hover.
            // Logic: 
            // 1. Temporarily upsizes rendering buffers to 'Full Res' on hover (to avoid blurriness).
            // 2. Maps mouse coordinates to CSS transform-origin (FULL) or 2D context sample area (LENS).
            let hoverTimeout;
            const pContainer = UI.previewContainer;
            const displayCanvas = UI.displayCanvas;

            // Hover Zoom Slider Logic
            const parseZoom = (val) => {
                let v = parseFloat(val);
                if (isNaN(v)) return 1.0;
                return v;
            };

            // Lens toggle button
            UI.lensToggleBtn.addEventListener('click', () => {
                state.isLensMode = !state.isLensMode;
                UI.lensToggleBtn.textContent = state.isLensMode ? 'LENS' : 'FULL';
                UI.lensToggleBtn.style.background = state.isLensMode ? 'var(--accent)' : '';
                UI.lensToggleBtn.style.color = state.isLensMode ? '#000' : '';
                resetZoom();
            });

            // Setup lens canvas
            const lensSize = 180;
            UI.lensCanvas.width = lensSize;
            UI.lensCanvas.height = lensSize;
            const lensCtx = UI.lensCanvas.getContext('2d');

            // Reset zoom transform when mouse leaves
            const resetZoom = (force = false) => {
                if (state.isZoomLocked && !force) return;

                displayCanvas.style.transform = '';
                displayCanvas.style.transformOrigin = '';
                displayCanvas.style.zIndex = '';
                UI.zoomResIndicator.style.display = 'none';
                if (UI.zoomLens) UI.zoomLens.style.display = 'none';
                if (state.isZooming) {
                    state.isZooming = false;
                    // Return to preview resolution (only if clamping is active)
                    if (state.clampPreview) {
                        reallocateBuffers(false);
                        requestRender();
                    }
                }
            };

            // Apply zoom transform based on cursor position
            const applyZoom = (e) => {
                const zoomInput = UI.hoverZoomSlider;
                const zoomLevel = parseZoom(zoomInput.value);

                if (zoomLevel <= 1.0) {
                    resetZoom();
                    return;
                }


                // Hide the overlay when zooming
                UI.overlayOriginal.classList.remove('show');

                // Render at full resolution for zoom if not already
                if (!state.isZooming) {
                    state.isZooming = true;
                    reallocateBuffers(true);
                    requestRender();
                }

                const rect = pContainer.getBoundingClientRect();

                // Use cached mouse position if locked
                if (!state.isZoomLocked && e) {
                    state.lastMousePos = { x: e.clientX, y: e.clientY };
                }

                const mouseX = state.lastMousePos.x - rect.left;
                const mouseY = state.lastMousePos.y - rect.top;
                const xPct = mouseX / rect.width;
                const yPct = mouseY / rect.height;

                if (state.isLensMode) {
                    // LENS MODE: Show circular magnifier following cursor
                    displayCanvas.style.transform = '';
                    displayCanvas.style.transformOrigin = '';
                    displayCanvas.style.zIndex = '';

                    // Position lens centered on cursor
                    if (UI.zoomLens) {
                        UI.zoomLens.style.display = 'block';
                        UI.zoomLens.style.left = (mouseX - lensSize / 2) + 'px';
                        UI.zoomLens.style.top = (mouseY - lensSize / 2) + 'px';
                    }

                    // Calculate the actual displayed canvas size (object-fit: contain)
                    const canvasAspect = displayCanvas.width / displayCanvas.height;
                    const containerAspect = rect.width / rect.height;
                    let displayedW, displayedH, offsetX, offsetY;

                    if (canvasAspect > containerAspect) {
                        displayedW = rect.width;
                        displayedH = rect.width / canvasAspect;
                        offsetX = 0;
                        offsetY = (rect.height - displayedH) / 2;
                    } else {
                        displayedH = rect.height;
                        displayedW = rect.height * canvasAspect;
                        offsetX = (rect.width - displayedW) / 2;
                        offsetY = 0;
                    }

                    // Map mouse position to canvas pixel coordinates
                    const canvasX = ((mouseX - offsetX) / displayedW) * displayCanvas.width;
                    const canvasY = ((mouseY - offsetY) / displayedH) * displayCanvas.height;

                    // Calculate source region size based on zoom
                    const srcSize = lensSize / zoomLevel;
                    const srcX = canvasX - srcSize / 2;
                    const srcY = canvasY - srcSize / 2;

                    // Draw zoomed portion to lens canvas
                    if (lensCtx) {
                        lensCtx.clearRect(0, 0, lensSize, lensSize);
                        lensCtx.drawImage(
                            displayCanvas,
                            Math.max(0, Math.min(srcX, displayCanvas.width - srcSize)),
                            Math.max(0, Math.min(srcY, displayCanvas.height - srcSize)),
                            srcSize, srcSize,
                            0, 0, lensSize, lensSize
                        );
                    }
                } else {
                    // FULL MODE: Scale entire canvas from cursor point
                    if (UI.zoomLens) UI.zoomLens.style.display = 'none';
                    displayCanvas.style.zIndex = '15';

                    // Correct mapping for object-fit: contain (centered canvas)
                    const canvasAspect = displayCanvas.width / displayCanvas.height;
                    const containerAspect = rect.width / rect.height;
                    let offsetX = 0, offsetY = 0, displayedW = rect.width, displayedH = rect.height;

                    if (canvasAspect > containerAspect) {
                        displayedH = rect.width / canvasAspect;
                        offsetY = (rect.height - displayedH) / 2;
                    } else {
                        displayedW = rect.height * canvasAspect;
                        offsetX = (rect.width - displayedW) / 2;
                    }

                    const localX = (mouseX - offsetX) / displayedW;
                    const localY = (mouseY - offsetY) / displayedH;

                    displayCanvas.style.transformOrigin = `${localX * 100}% ${localY * 100}%`;
                    displayCanvas.style.transform = `scale(${zoomLevel})`;
                }

                // Show resolution indicator
                const srcW = state.width * state.upscaleFactor;
                const srcH = state.height * state.upscaleFactor;
                const bufW = displayCanvas.width;
                const bufH = displayCanvas.height;
                const match = (bufW >= srcW && bufH >= srcH) ? '‚úì FULL RES' : '‚ö† SCALED';
                const modeLabel = state.isLensMode ? 'LENS' : 'FULL';
                UI.zoomResIndicator.innerHTML = `Mode: ${modeLabel}<br>Source: ${srcW}√ó${srcH}<br>Canvas: ${bufW}√ó${bufH}<br>${match}`;
                UI.zoomResIndicator.style.display = 'block';
                UI.zoomResIndicator.style.color = (bufW >= srcW && bufH >= srcH) ? '#0f0' : '#f80';
                UI.zoomResIndicator.style.borderColor = (bufW >= srcW && bufH >= srcH) ? '#0f0' : '#f80';
            };

            pContainer.addEventListener('mouseenter', (e) => {
                const zoomLevel = parseFloat(UI.hoverZoomSlider.value);
                if (zoomLevel <= 1 && !state.isPreviewLocked && !state.activeLayerPreview) {
                    UI.overlayOriginal.classList.add('show');
                }
                clearTimeout(hoverTimeout);
                applyZoom(e);
            });

            pContainer.addEventListener('mouseleave', (e) => {
                UI.overlayOriginal.classList.remove('show');
                clearTimeout(hoverTimeout);

                // If the mouse leaves but it's locked, we don't reset
                if (!state.isZoomLocked) {
                    resetZoom();
                }
            });

            pContainer.addEventListener('wheel', (e) => {
                // If Ctrl/Meta is held, we cycle blend modes (legacy behavior)
                // Otherwise, wheel controls zoom level
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const sel = UI.blendMode;
                    const len = sel.options.length;
                    let idx = sel.selectedIndex;
                    const dir = Math.sign(e.deltaY);
                    idx = (idx + dir + len) % len;
                    sel.selectedIndex = idx;
                    requestRender();
                } else {
                    // Standard Wheel to Zoom
                    e.preventDefault();
                    let val = parseFloat(UI.hoverZoomSlider.value);
                    const dir = -Math.sign(e.deltaY);
                    val += dir * 0.5;
                    val = Math.max(1, Math.min(8, val));
                    UI.hoverZoomSlider.value = val;
                    // Trigger input event manually to update text and state
                    UI.hoverZoomSlider.dispatchEvent(new Event('input'));
                    applyZoom(e);
                }
            }, { passive: false });

            pContainer.addEventListener('mousemove', (e) => {
                clearTimeout(hoverTimeout);
                const zVal = parseFloat(UI.hoverZoomSlider.value);
                if (!state.isPreviewLocked && !state.activeLayerPreview && zVal <= 1) {
                    UI.overlayOriginal.classList.add('show');
                }
                applyZoom(e);
            });

            // [ZOOM LOCK] Tab keybind
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    // Only toggle if we are currently hovering or already locked
                    const isHovering = UI.previewContainer.matches(':hover');
                    if (isHovering || state.isZoomLocked) {
                        e.preventDefault();
                        state.isZoomLocked = !state.isZoomLocked;

                        // If we just unlocked and aren't hovering, snap back
                        if (!state.isZoomLocked && !isHovering) {
                            resetZoom(true);
                        } else if (state.isZoomLocked) {
                            // Ensure zoom stays high-res
                            applyZoom();
                        }
                    }
                }
            });

            // JSON Handlers
            UI.downloadJsonBtn.addEventListener('click', downloadPreset);
            UI.uploadJsonTrigger.addEventListener('click', () => UI.jsonUpload.click());
            UI.jsonUpload.addEventListener('change', uploadPreset);

            initWebGL();

            // Single image load
            UI.imageUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                state.isMultiImageMode = false;
                state.imageFiles = [file];
                state.currentImageIndex = 0;
                loadImageFromFile(file).then(updateUIMode);
            });

            // Folder load
            UI.loadFolderBtn.addEventListener('click', loadFolder);

            // Navigation
            UI.prevImageBtn.addEventListener('click', () => changeImage(-1));
            UI.nextImageBtn.addEventListener('click', () => changeImage(1));

            // Scrubber
            UI.imageScrubber.addEventListener('input', (e) => {
                const newIndex = parseInt(e.target.value, 10);
                if (newIndex !== state.currentImageIndex) {
                    state.currentImageIndex = newIndex;
                    // Don't wait for image to load, makes scrubber feel laggy
                    requestAnimationFrame(() => {
                        loadImageFromFile(state.imageFiles[state.currentImageIndex]).then(updateUIMode);
                    });
                }
            });

            // --- Playback Logic ---
            const startPlay = () => {
                if (state.playInterval) clearInterval(state.playInterval);
                state.isPlaying = true;
                UI.playBtn.textContent = 'STOP ‚ñ†';
                const fps = parseInt(UI.playFps.value, 10) || 10;

                state.playInterval = setInterval(() => {
                    let newIndex = (state.currentImageIndex + 1) % state.imageFiles.length;
                    state.currentImageIndex = newIndex;
                    // Don't await, just fire and forget to keep timing consistent
                    loadImageFromFile(state.imageFiles[state.currentImageIndex]);
                    updateUIMode(); // Update scrubber and counter
                }, 1000 / fps);
            };

            const stopPlay = () => {
                if (state.playInterval) {
                    clearInterval(state.playInterval);
                    state.playInterval = null;
                }
                state.isPlaying = false;
                UI.playBtn.textContent = 'PLAY ‚ñ∫';
            };

            UI.playBtn.addEventListener('click', () => {
                if (state.isPlaying) {
                    stopPlay();
                } else {
                    startPlay();
                }
            });

            UI.keepFolderStructureToggle.addEventListener('change', (e) => {
                state.keepFolderStructure = e.target.checked;
            });

            // Download button now handles both modes
            UI.downloadBtn.addEventListener('click', () => {
                if (state.isMultiImageMode && state.imageFiles.length > 1) {
                    downloadAllImages();
                } else {
                    downloadSingleImage();
                }
            });

            UI.downloadCurrentBtn = document.getElementById('downloadCurrentBtn');
            UI.compareBtn.addEventListener('click', openCompare);
            UI.downloadCurrentBtn.addEventListener('click', downloadSingleImage);
            UI.closeCompare.addEventListener('click', () => document.getElementById('compareModal').classList.remove('show'));
            UI.exportSideBySide.addEventListener('click', () => exportComparison('side'));
            UI.exportStacked.addEventListener('click', () => exportComparison('stack'));

            // [NOISE PARAM DYNAMICS]
            // Purpose: Dynamically renames and toggles noise parameters based on algorithm.
            UI.noiseType.addEventListener('change', syncNoiseUI);
            syncNoiseUI(); // Initial call

            // [EYEDROPPER TOOL] Localized Color Selection
            // Purpose: Picks colors directly from the WebGL canvas for palette or exclusion masks.
            // Logic: Reads pixel data from the 'null' framebuffer (screen) at the mapped click coordinate.
            // Note: Uses WebGL's inverted Y-axis relative to DOM coordinates.
            const style = document.createElement('style');
            style.textContent = `
                .eyedropper-btn { background: none; border: none; cursor: pointer; font-size: 1.2em; padding: 0 5px; opacity: 0.7; transition: opacity 0.2s; }
                .eyedropper-btn:hover { opacity: 1; }
                .eyedropper-active { cursor: crosshair !important; }
            `;
            document.head.appendChild(style);

            let eyedropperTarget = null;
            document.querySelectorAll('.eyedropper-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    if (eyedropperTarget === targetId) {
                        eyedropperTarget = null;
                        UI.displayCanvas.classList.remove('eyedropper-active');
                    } else {
                        eyedropperTarget = targetId;
                        UI.displayCanvas.classList.add('eyedropper-active');
                    }
                    e.stopPropagation();
                });
            });

            UI.displayCanvas.addEventListener('click', (e) => {
                if (!eyedropperTarget) return;

                const rect = UI.displayCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gl = state.gl;
                const canvas = UI.displayCanvas;
                const cw = canvas.width;
                const ch = canvas.height;

                // 1. Map DOM click to Relative UV (0-1) across the "Contain" rect
                const imgAspect = state.width / state.height;
                const rectAspect = rect.width / rect.height;

                let drawW, drawH, ox, oy;
                if (imgAspect > rectAspect) {
                    drawW = rect.width;
                    drawH = rect.width / imgAspect;
                    ox = 0;
                    oy = (rect.height - drawH) / 2;
                } else {
                    drawH = rect.height;
                    drawW = rect.height * imgAspect;
                    ox = (rect.width - drawW) / 2;
                    oy = 0;
                }

                if (x < ox || x > ox + drawW || y < oy || y > oy + drawH) return;

                const relX = (x - ox) / drawW;
                const relY = (y - oy) / drawH;

                // 2. Pick from Original Texture (state.textures.base)
                // We use a temporary FBO to read from the base texture directly
                const tempFbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, state.textures.base, 0);

                // Map UV to base image dimensions
                const pickX = Math.floor(relX * state.width);
                const pickY = Math.floor((1.0 - relY) * state.height);

                const pixel = new Uint8Array(4);
                gl.readPixels(pickX, pickY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

                // Clean up
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.deleteFramebuffer(tempFbo);

                const hex = "#" + ((1 << 24) + (pixel[0] << 16) + (pixel[1] << 8) + pixel[2]).toString(16).slice(1);

                const input = document.getElementById(eyedropperTarget);
                if (input) {
                    input.value = hex;
                    input.dispatchEvent(new Event('input'));
                    input.dispatchEvent(new Event('change'));
                }

                eyedropperTarget = null;
                UI.displayCanvas.classList.remove('eyedropper-active');
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && eyedropperTarget) {
                    eyedropperTarget = null;
                    UI.displayCanvas.classList.remove('eyedropper-active');
                }
            });
        });

        // --- JSON PRESETS ---
        /** 
         * Serializes the current 'state' and all UI input values into a JSON file.
         * Purpose: Allows users to save and share their custom noise profiles.
         */
        function downloadPreset() {
            const preset = {
                values: {},
                checks: {},
                selects: {},
                renderOrder: state.renderOrder,
                layerVisibility: state.layerVisibility,
                upscaleFactor: state.upscaleFactor,
                caCenter: state.caCenter,
                palette: state.palette
            };

            // Collect inputs
            document.querySelectorAll('input[type=range]').forEach(el => preset.values[el.id] = el.value);
            document.querySelectorAll('input[type=text].control-value').forEach(el => {
                // Read-only text inputs are for display, skip them
            });
            document.querySelectorAll('input[type=checkbox]').forEach(el => {
                if (!el.id.startsWith('drag-') && el.id !== 'previewLock') { // Skip drag toggles and lock
                    preset.checks[el.id] = el.checked;
                }
            });
            document.querySelectorAll('select').forEach(el => preset.selects[el.id] = el.value);

            const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'grain-settings.json';
            link.click();
        }

        /** 
         * Parses a JSON file to restore app state.
         * logic: Iterates through preset object and dispatches 'input' events 
         * to trigger re-renders for each restored value.
         */
        function uploadPreset(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = evt => {
                try {
                    const preset = JSON.parse(evt.target.result);

                    // Apply values
                    if (preset.values) {
                        Object.keys(preset.values).forEach(id => {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = preset.values[id];
                                if (el.nextElementSibling && el.nextElementSibling.classList.contains('control-value')) {
                                    el.nextElementSibling.value = preset.values[id];
                                }
                                el.dispatchEvent(new Event('input'));
                                el.dispatchEvent(new Event('change'));
                            }
                        });
                    }
                    if (preset.checks) {
                        Object.keys(preset.checks).forEach(id => {
                            const el = document.getElementById(id);
                            if (el) {
                                el.checked = preset.checks[id];
                                el.dispatchEvent(new Event('change'));
                            }
                        });
                    }
                    if (preset.selects) {
                        Object.keys(preset.selects).forEach(id => {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = preset.selects[id];
                                el.dispatchEvent(new Event('change'));
                            }
                        });
                    }

                    // Apply State
                    if (preset.renderOrder) {
                        state.renderOrder = preset.renderOrder;
                        setupDragLayerList();
                    }
                    if (preset.layerVisibility) {
                        state.layerVisibility = preset.layerVisibility;
                        setupDragLayerList();
                    }
                    if (preset.upscaleFactor) {
                        state.upscaleFactor = preset.upscaleFactor;
                        UI.upscaleInput.value = preset.upscaleFactor;
                    }
                    if (preset.caCenter) {
                        state.caCenter = preset.caCenter;
                        updatePinPosition();
                    }
                    if (preset.palette) {
                        state.palette = preset.palette;
                        updatePaletteUI();
                    }

                    requestRender();
                } catch (err) {
                    alert("Error loading JSON: " + err);
                }
            };
            reader.readAsText(file);
        }

        // --- MULTI-IMAGE FUNCTIONS ---

        async function loadFolder() {
            try {
                const dirHandle = await window.showDirectoryPicker();
                const imageFiles = [];
                const allFiles = [];

                async function scan(handle, path = "") {
                    for await (const entry of handle.values()) {
                        if (entry.kind === 'file') {
                            const file = await entry.getFile();
                            file.relativePath = path; // Store for export
                            allFiles.push(file);
                            if (file.type.startsWith('image/')) {
                                imageFiles.push(file);
                            }
                        } else if (entry.kind === 'directory') {
                            await scan(entry, path + entry.name + "/");
                        }
                    }
                }

                UI.loading.textContent = 'SCANNING FOLDER...';
                UI.loading.style.display = 'block';
                await scan(dirHandle);
                UI.loading.style.display = 'none';

                if (imageFiles.length > 0) {
                    state.imageFiles = imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
                    state.allFiles = allFiles; // Store all files for replica export
                    state.isMultiImageMode = true;
                    state.currentImageIndex = 0;
                    await loadImageFromFile(state.imageFiles[0]);
                    updateUIMode();
                } else {
                    alert('No images found in the selected folder.');
                }
            } catch (err) {
                console.error('Error loading folder:', err);
                UI.loading.style.display = 'none';
                if (err.name !== 'AbortError') {
                    alert('Could not load folder. Please ensure your browser supports the File System Access API and you have granted permission.');
                }
            }
        }

        async function changeImage(direction) {
            if (!state.isMultiImageMode || state.imageFiles.length === 0) return;

            let newIndex = state.currentImageIndex + direction;

            if (newIndex < 0) return;
            if (newIndex >= state.imageFiles.length) return;

            state.currentImageIndex = newIndex;
            await loadImageFromFile(state.imageFiles[state.currentImageIndex]);
            updateUIMode();
        }

        async function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const url = URL.createObjectURL(file);
                img.src = url;
                img.onload = () => {
                    loadNewImage(img);
                    URL.revokeObjectURL(url);
                    resolve();
                };
                img.onerror = (err) => {
                    URL.revokeObjectURL(url);
                    reject(err);
                };
            });
        }

        function updateUIMode() {
            const nav = document.getElementById('image-navigation');
            const scrubber = UI.imageScrubber;
            if (state.isMultiImageMode && state.imageFiles.length > 1) {
                nav.style.display = 'flex';
                UI.imageCounter.textContent = `Image ${state.currentImageIndex + 1} of ${state.imageFiles.length}`;
                UI.downloadBtn.textContent = `DOWNLOAD ALL (${state.imageFiles.length})`;
                scrubber.max = state.imageFiles.length - 1;
                scrubber.value = state.currentImageIndex;
                if (UI.downloadCurrentBtn) UI.downloadCurrentBtn.style.display = 'block';
            } else {
                nav.style.display = 'none';
                UI.downloadBtn.textContent = 'DOWNLOAD FULL RES';
                if (UI.downloadCurrentBtn) UI.downloadCurrentBtn.style.display = 'none';
            }

            if (state.imageFiles.length > 1) {
                UI.prevImageBtn.disabled = state.currentImageIndex === 0;
                UI.nextImageBtn.disabled = state.currentImageIndex === state.imageFiles.length - 1;
            }
        }

        async function downloadSingleImage() {
            UI.loading.textContent = 'PROCESSING GPU...';
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            reallocateBuffers(true);
            renderFrame(true);

            const link = document.createElement('a');
            const originalName = state.isMultiImageMode ? state.imageFiles[state.currentImageIndex].name.split('.')[0] : 'grain-export';
            link.download = `${originalName}-processed.png`;
            link.href = state.canvas.toDataURL('image/png', 1.0);
            link.click();

            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        async function downloadAllImages() {
            let dirHandle;
            try {
                dirHandle = await window.showDirectoryPicker();
            } catch (err) {
                if (err.name === 'AbortError') return;
                alert('Could not open directory. Permission denied.');
                return;
            }

            state.isExporting = true;
            const overlay = UI['export-overlay'];
            overlay.style.display = 'flex';

            const stopExportHandler = () => {
                state.isExporting = false;
            };
            UI.stopExportBtn.addEventListener('click', stopExportHandler);

            const originalIndex = state.currentImageIndex;
            const filesToExport = state.keepFolderStructure ? state.allFiles : state.imageFiles;

            try {
                for (let i = 0; i < filesToExport.length; i++) {
                    if (!state.isExporting) {
                        alert('Export cancelled.');
                        break;
                    }

                    const file = filesToExport[i];
                    UI['export-status'].textContent = `EXPORTING ${i + 1}/${filesToExport.length}...`;

                    try {
                        let targetDir = dirHandle;
                        if (state.keepFolderStructure && file.relativePath) {
                            const parts = file.relativePath.split("/").filter(p => p !== "");
                            for (const part of parts) {
                                targetDir = await targetDir.getDirectoryHandle(part, { create: true });
                            }
                        }

                        // Check if this file is one of the images we should process
                        const isProcessableImage = state.imageFiles.includes(file);

                        if (isProcessableImage) {
                            await loadImageFromFile(file);
                            reallocateBuffers(true);
                            renderFrame(true);

                            const blob = await new Promise(resolve => state.canvas.toBlob(resolve, 'image/png'));
                            const exportName = state.keepFolderStructure ? file.name : `${i + 1}.png`;
                            const fileHandle = await targetDir.getFileHandle(exportName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                        } else if (state.keepFolderStructure) {
                            // Non-image file or non-processable: Copy directly
                            const fileHandle = await targetDir.getFileHandle(file.name, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(file);
                            await writable.close();
                        }
                    } catch (err) {
                        console.error(`Error exporting ${file.name}:`, err);
                    }
                    await new Promise(r => setTimeout(r, 10)); // Yield to main thread
                }
                if (state.isExporting) {
                    alert(`Export Complete. Processed ${state.imageFiles.length} images and copied ${state.allFiles.length - state.imageFiles.length} other files.`);
                }
            } finally {
                state.isExporting = false;
                overlay.style.display = 'none';
                UI.stopExportBtn.removeEventListener('click', stopExportHandler);

                // Restore to the image that was active before downloading
                await loadImageFromFile(state.imageFiles[originalIndex]);
                state.currentImageIndex = originalIndex;
                updateUIMode();
                reallocateBuffers(false);
                requestRender();
            }
        }


        // --- DRAG LAYER LIST ---
        /** 
         * Manages the 'Render Layer Order' tab.
         * logic: Uses native HTML5 Drag and Drop to reorder the 'state.renderOrder' array.
         * UI Pointer: Referenced as 'tab-layers' in the HTML.
         */
        function setupDragLayerList() {
            const list = document.getElementById('layer-drag-list');
            list.innerHTML = '';

            state.renderOrder.forEach((key, index) => {
                const div = document.createElement('div');
                div.className = 'drag-layer';
                div.draggable = true;
                div.dataset.key = key;

                const isChecked = state.layerVisibility[key] ? 'checked' : '';

                div.innerHTML = `
            <div style="display:flex; align-items:center;">
                <span class="drag-handle">‚ò∞</span> 
                <input type="checkbox" class="drag-toggle" data-key="${key}" ${isChecked}>
            </div>
            <span>${LAYERS[key].name}</span>
        `;

                div.querySelector('input').addEventListener('change', (e) => {
                    state.layerVisibility[key] = e.target.checked;
                    requestRender();
                });

                div.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    div.classList.add('dragging');
                });

                div.addEventListener('dragend', () => div.classList.remove('dragging'));

                div.addEventListener('dragover', (e) => e.preventDefault());

                div.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = index;
                    if (fromIndex === toIndex) return;

                    const item = state.renderOrder.splice(fromIndex, 1)[0];
                    state.renderOrder.splice(toIndex, 0, item);

                    setupDragLayerList();
                    setupLayerGridDOM();
                    requestRender();
                });

                list.appendChild(div);
            });
        }

        // --- RENDER LOOP MANAGER ---
        /** 
         * Debounced rendering function.
         * Ensures we don't drop frames by batching multiple input changes 
         * into a single requestAnimationFrame call.
         */
        let renderRequested = false;
        function requestRender() {
            if (!renderRequested && state.baseImage) {
                renderRequested = true;
                requestAnimationFrame(() => {
                    renderFrame();
                    renderRequested = false;
                });
            }
        }

        // --- WEBGL CORE ---
        /** 
         * Initializes the WebGL2 context, compiles all shaders, and sets up 
         * the static full-screen quad geometry (VBO).
         */
        function initWebGL() {
            state.canvas = UI.displayCanvas;
            // WebGL2 is required for advanced features like 'EXP' blurring and complex dithering.
            const gl = state.canvas.getContext('webgl2', { antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: true });
            if (!gl) { alert('WebGL2 not supported.'); return; }

            // Enable specialized texture formats
            gl.getExtension('EXT_color_buffer_float');
            gl.getExtension('OES_texture_float_linear');

            state.gl = gl;
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

            // [SHADER COMPILATION] Link all fs- scripts to programs
            state.programs = {
                adjust: createProgram(gl, 'vs-quad', 'fs-adjust'),
                adjustMasked: createProgram(gl, 'vs-quad', 'fs-adjustMasked'),
                mask: createProgram(gl, 'vs-quad', 'fs-mask'),
                colorMask: createProgram(gl, 'vs-quad', 'fs-colorMask'),
                noise: createProgram(gl, 'vs-quad', 'fs-noise'),
                blur: createProgram(gl, 'vs-quad', 'fs-blur'),
                maskedBlur: createProgram(gl, 'vs-quad', 'fs-maskedBlur'),
                composite: createProgram(gl, 'vs-quad', 'fs-composite'),
                chroma: createProgram(gl, 'vs-quad', 'fs-chroma'),
                copy: createProgram(gl, 'vs-quad', 'fs-copy'),
                dither: createProgram(gl, 'vs-quad', 'fs-dither'),
                maskedDither: createProgram(gl, 'vs-quad', 'fs-maskedDither'),
                corruption: createProgram(gl, 'vs-quad', 'fs-corruption'),
                cell: createProgram(gl, 'vs-quad', 'fs-cell'),
                halftone: createProgram(gl, 'vs-quad', 'fs-halftone'),
                bilateral: createProgram(gl, 'vs-quad', 'fs-bilateral'),
                palette: createProgram(gl, 'vs-quad', 'fs-palette'),
                edge: createProgram(gl, 'vs-quad', 'fs-edge'),
                invert: createProgram(gl, 'vs-quad', 'fs-invert'),
                radial: createProgram(gl, 'vs-quad', 'fs-radial'),
                final: createProgram(gl, 'vs-quad', 'fs-final')
            };

            // [GEOMETRY] Single full-screen quad (2 triangles)
            const quadVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 0, 0,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                -1, 1, 0, 1,
                1, -1, 1, 0,
                1, 1, 1, 1
            ]), gl.STATIC_DRAW);

            // Bind global attributes
            Object.values(state.programs).forEach(p => {
                gl.useProgram(p);
                const posLoc = gl.getAttribLocation(p, 'a_pos');
                const uvLoc = gl.getAttribLocation(p, 'a_uv');
                gl.enableVertexAttribArray(posLoc);
                gl.enableVertexAttribArray(uvLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
                gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);
            });

            // Create FBO for background thumbnail processing
            const tw = 320, th = 180;
            const tTex = createTexture(gl, null, tw, th);
            const tFbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, tFbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tTex, 0);
            state.thumbnailFBO = { fbo: tFbo, tex: tTex, w: tw, h: th };

            // Display Hardware Limit
            if (UI.gpuMaxRes) {
                const max = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                UI.gpuMaxRes.textContent = `${max}px`;
            }
        }

        function loadNewImage(img) {
            state.baseImage = img;
            state.width = img.width;
            state.height = img.height;

            const gl = state.gl;
            if (state.textures.base) {
                gl.deleteTexture(state.textures.base);
                state.textures.base = null;
            }
            state.textures.base = createTexture(gl, img);

            // Force FBOs to be reallocated for any size (preview or export) after image change
            state.fboWidth = 0;
            state.fboHeight = 0;

            reallocateBuffers(false);

            UI.downloadBtn.disabled = false;
            UI.downloadCurrentBtn.disabled = false;
            UI.compareBtn.disabled = false;

            UI.overlayCanvas.width = img.width;
            UI.overlayCanvas.height = img.height;
            UI.overlayCanvas.getContext('2d').drawImage(img, 0, 0);

            UI.caPin.classList.add('active');

            setupLayerGridDOM();
            requestRender();
        }

        /** 
         * Resizes all internal offscreen textures to match current viewport or upscale factor.
         * Logic: Deletes old FBOs and re-initializes them at the new 'targetW/H'.
         * Reference: Uses 'state.upscaleFactor' to determine final buffer dimensions.
         */
        function reallocateBuffers(fullRes = false) {
            const gl = state.gl;
            // Check browser limits
            const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            let targetW, targetH;

            if (fullRes) {
                let requestW = state.width * state.upscaleFactor;
                let requestH = state.height * state.upscaleFactor;
                let scale = 1.0;
                if (requestW > maxTexSize || requestH > maxTexSize) {
                    scale = Math.min(maxTexSize / requestW, maxTexSize / requestH);
                }
                targetW = Math.round(state.width * state.upscaleFactor * scale);
                targetH = Math.round(state.height * state.upscaleFactor * scale);
                state._exportScale = scale; // Store for use in export
            } else {
                // [CLAMPER] Toggleable resolution cap (Default: 2048px)
                const maxDim = state.clampPreview ? 2048 : maxTexSize;
                let tempW = state.width * state.upscaleFactor;
                let tempH = state.height * state.upscaleFactor;
                let scale = 1.0;
                if (tempW > maxDim || tempH > maxDim) {
                    scale = Math.min(maxDim / tempW, maxDim / tempH);
                }
                targetW = Math.round(tempW * scale);
                targetH = Math.round(tempH * scale);
                // Clamp to max texture size for preview as well
                if (targetW > maxTexSize || targetH > maxTexSize) {
                    const s = Math.min(maxTexSize / targetW, maxTexSize / targetH);
                    targetW = Math.floor(targetW * s);
                    targetH = Math.floor(targetH * s);
                }
                state._exportScale = scale;
            }

            state.renderWidth = targetW;
            state.renderHeight = targetH;

            if (state.fboWidth === targetW && state.fboHeight === targetH) {
                return { w: targetW, h: targetH };
            }

            state.fboWidth = targetW;
            state.fboHeight = targetH;

            const makeFBO = (highPrec = true) => {
                const tex = createTexture(gl, null, targetW, targetH, highPrec);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                return { tex, fbo };
            };

            if (state.pingPong[0]?.tex) { gl.deleteTexture(state.pingPong[0].tex); gl.deleteFramebuffer(state.pingPong[0].fbo); }
            if (state.pingPong[1]?.tex) { gl.deleteTexture(state.pingPong[1].tex); gl.deleteFramebuffer(state.pingPong[1].fbo); }

            state.pingPong[0] = makeFBO();
            state.pingPong[1] = makeFBO();

            ['tempNoise', 'blur1', 'blur2', 'preview'].forEach(k => {
                if (state.textures[k]) gl.deleteTexture(state.textures[k]);
                if (state.fbos[k]) gl.deleteFramebuffer(state.fbos[k]);
            });

            const nse = makeFBO();
            state.textures.tempNoise = nse.tex; state.fbos.tempNoise = nse.fbo;
            const b1 = makeFBO();
            state.textures.blur1 = b1.tex; state.fbos.blur1 = b1.fbo;
            const b2 = makeFBO();
            state.textures.blur2 = b2.tex; state.fbos.blur2 = b2.fbo;

            const prev = makeFBO();
            state.textures.preview = prev.tex; state.fbos.preview = prev.fbo;

            return { w: targetW, h: targetH };
        }

        // --- LAYER LOGIC EXTRACTOR ---
        /** 
         * The core of the render pipeline.
         * logic: Dynamically selects the appropriate shader and uniform set for a given layer.
         * Pass-through: Takes 'inputTex' and writes result to 'outputFbo'.
         * @param {string} key - The ID of the layer (e.g. 'noise', 'blur').
         */
        function renderSingleLayer(gl, key, inputTex, outputFbo, uniforms, force = false) {
            const w = state.renderWidth;
            const h = state.renderHeight;
            gl.viewport(0, 0, w, h);

            if (key === 'adjust') {
                // [TOOL: ADJUSTMENTS] Color, Sharpening, Brightness
                if (!UI.adjustEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                let maskTex = null;
                const hasSH = UI.adjLumaMask?.checked;
                const hasCol = UI.adjColorExclude?.checked;

                if (hasSH || hasCol) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                    if (hasSH) {
                        gl.useProgram(state.programs.mask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.adjShadowThreshold?.value || 0));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.adjShadowFade?.value || 0));
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.adjHighlightThreshold?.value || 1));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.adjHighlightFade?.value || 0));
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    if (hasCol) {
                        const targetColor = UI.adjExcludeColor?.value || '#000000';
                        const r = parseInt(targetColor.slice(1, 3), 16) / 255;
                        const g = parseInt(targetColor.slice(3, 5), 16) / 255;
                        const b = parseInt(targetColor.slice(5, 7), 16) / 255;
                        gl.useProgram(state.programs.colorMask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                        gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), r, g, b);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.adjColorTolerance?.value || 10) / 100.0);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.adjColorFade?.value || 0) / 100.0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    gl.disable(gl.BLEND);
                    maskTex = state.textures.blur1;

                    if (maskTex && UI.adjInvertMask?.checked) {
                        gl.useProgram(state.programs.invert);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        maskTex = state.textures.blur2;
                    }
                }

                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                const prog = state.programs.adjustMasked || state.programs.adjust;
                gl.useProgram(prog);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, inputTex);

                gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bright'), uniforms.u_bright);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_cont'), uniforms.u_cont);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sat'), uniforms.u_sat);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hdrTol'), 0.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_hdrAmt'), 0.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_warmth'), uniforms.u_warmth);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sharp'), uniforms.u_sharp);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_sharpThresh'), uniforms.u_sharpThresh);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_step'), uniforms.u_step[0], uniforms.u_step[1]);

                if (maskTex && prog) {
                    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_useMask'), 1);
                } else if (prog) {
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_useMask'), 0);
                }

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                return outputFbo; // Effectively specific texture attached to this FBO
            }
            else if (key === 'hdr') {
                // [TOOL: HDR EMULATION] Luminance Compression
                if (!UI.hdrEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.adjust);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.adjust, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_bright'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_cont'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_sat'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_warmth'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_sharp'), 0.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_hdrTol'), uniforms.u_hdrTol);
                gl.uniform1f(gl.getUniformLocation(state.programs.adjust, 'u_hdrAmt'), uniforms.u_hdrAmt);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'noise') {
                // [TOOL: NOISE GROUP] Procedural Grain & Compositing
                if (!UI.noiseEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.useProgram(state.programs.noise);
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.tempNoise);
                gl.uniform1i(gl.getUniformLocation(state.programs.noise, 'u_type'), parseInt(UI.noiseType.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_seed'), Math.random() * 100.0);
                gl.uniform2f(gl.getUniformLocation(state.programs.noise, 'u_res'), w, h);
                gl.uniform2f(gl.getUniformLocation(state.programs.noise, 'u_origRes'), state.width * state.upscaleFactor, state.height * state.upscaleFactor);
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_scale'), parseFloat(UI.noiseSize.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_paramA'), parseFloat(document.getElementById('noiseParamA').value) / 100.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_paramB'), parseFloat(document.getElementById('noiseParamB').value) / 100.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.noise, 'u_paramC'), parseFloat(document.getElementById('noiseParamC').value) / 100.0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                const blurAmt = parseFloat(UI.blurriness.value) / 100.0;
                let noiseTex = state.textures.tempNoise;
                if (blurAmt > 0) {
                    gl.useProgram(state.programs.blur);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.bindTexture(gl.TEXTURE_2D, state.textures.tempNoise);
                    gl.uniform1i(gl.getUniformLocation(state.programs.blur, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(state.programs.blur, 'u_dir'), 1.0 / w, 0.0);
                    gl.uniform1f(gl.getUniformLocation(state.programs.blur, 'u_rad'), blurAmt * 2.0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                    gl.bindTexture(gl.TEXTURE_2D, state.textures.blur1);
                    gl.uniform2f(gl.getUniformLocation(state.programs.blur, 'u_dir'), 0.0, 1.0 / h);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    noiseTex = state.textures.blur2;
                }

                // Masking logic for Noise
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                gl.clearColor(1, 1, 1, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                if (UI.noiseLumaMask.checked) {
                    gl.useProgram(state.programs.mask);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                    gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.shadowThreshold.value));
                    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.shadowFade.value));
                    gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.highlightThreshold.value));
                    gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.highlightFade.value));
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                if (UI.noiseColorExclude.checked) {
                    const rgb = hexToRgb(UI.noiseExcludeColor.value);
                    gl.useProgram(state.programs.colorMask);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                    gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), rgb.r, rgb.g, rgb.b);
                    gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.noiseColorTolerance.value) / 100.0);
                    gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.noiseColorFade.value) / 100.0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                gl.disable(gl.BLEND);

                let maskTex = state.textures.blur1;
                if (UI.noiseInvertMask.checked) {
                    const targetFbo = (noiseTex === state.textures.blur2) ? state.fbos.tempNoise : state.fbos.blur2;
                    const targetTex = (noiseTex === state.textures.blur2) ? state.textures.tempNoise : state.textures.blur2;
                    gl.useProgram(state.programs.invert);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, targetFbo);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    maskTex = targetTex;
                }

                // Composite
                gl.useProgram(state.programs.composite);
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, noiseTex);
                gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, maskTex);

                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_base'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_noise'), 1);
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_mask'), 2);
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_mode'), parseInt(UI.blendMode.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_opacity'), parseFloat(UI.opacity.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_str'), parseFloat(UI.strength.value));
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_nType'), parseInt(UI.noiseType.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_satStr'), parseFloat(UI.satStrength.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_satImp'), parseFloat(UI.satPerNoise.value));
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_skinProt'), parseFloat(UI.skinProtection.value));
                gl.uniform1i(gl.getUniformLocation(state.programs.composite, 'u_ignA'), UI.ignoreAlphaToggle.checked ? 1 : 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.composite, 'u_ignAstr'), parseFloat(UI.ignoreAlphaStrength.value));

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'ca') {
                // [TOOL: CHROMATIC ABERRATION] Lens Fringing
                if (!UI.caEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.chroma);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.chroma, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_amt'), uniforms.u_ca_amt);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_blur'), uniforms.u_ca_blur);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_zoomBlur'), parseFloat(UI.aberrationZoomBlur.value) / 50.0);
                gl.uniform2f(gl.getUniformLocation(state.programs.chroma, 'u_center'), uniforms.u_ca_center[0], uniforms.u_ca_center[1]);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_radius'), uniforms.u_ca_rad);
                gl.uniform1f(gl.getUniformLocation(state.programs.chroma, 'u_falloff'), uniforms.u_ca_fall);
                gl.uniform1i(gl.getUniformLocation(state.programs.chroma, 'u_falloffToBlur'), UI.caFalloffToBlur.checked ? 1 : 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'blur') {
                // [TOOL: BLUR] Masked Gaussian/Box/Motion Blur
                if (!UI.blurEnable?.checked) {
                    // Pass-through copy if needed, but often we just skip.
                    // If we need to write to outputFbo to maintain chain:
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }

                let maskTex = null;
                const hasSH = UI.blurLumaMask?.checked;
                const hasCol = UI.blurColorExclude?.checked;

                if (hasSH || hasCol) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                    if (hasSH) {
                        gl.useProgram(state.programs.mask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.blurShadowThreshold?.value || 0));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.blurShadowFade?.value || 0));
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.blurHighlightThreshold?.value || 1));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.blurHighlightFade?.value || 0));
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    if (hasCol) {
                        const targetColor = UI.blurTargetColor?.value || '#000000';
                        const r = parseInt(targetColor.slice(1, 3), 16) / 255;
                        const g = parseInt(targetColor.slice(3, 5), 16) / 255;
                        const b = parseInt(targetColor.slice(5, 7), 16) / 255;
                        gl.useProgram(state.programs.colorMask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                        gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), r, g, b);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.blurColorTolerance?.value || 10) / 100.0);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.blurColorFade?.value || 20) / 100.0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    gl.disable(gl.BLEND);
                    gl.disable(gl.BLEND);
                    maskTex = state.textures.blur1;

                    if (maskTex && UI.blurInvertMask?.checked) {
                        // Blur uses blur2 for H Pass, so we must use tempNoise for inverted mask
                        gl.useProgram(state.programs.invert);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.tempNoise);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        maskTex = state.textures.tempNoise;
                    }
                }

                const blurAmt = parseFloat(UI.blurAmount?.value || 0) / 100.0;
                if (blurAmt > 0) {
                    const prog = maskTex ? state.programs.maskedBlur : state.programs.blur;
                    gl.useProgram(prog);
                    // H Pass
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(prog, 'u_dir'), 1.0 / w, 0.0);
                    gl.uniform1f(gl.getUniformLocation(prog, 'u_rad'), blurAmt * 2.0);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_blurType'), parseInt(UI.blurType?.value || 0));

                    if (maskTex) {
                        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                    }
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    // V Pass
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.blur2);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                    gl.uniform2f(gl.getUniformLocation(prog, 'u_dir'), 0.0, 1.0 / h);
                    gl.uniform1f(gl.getUniformLocation(prog, 'u_rad'), blurAmt * 2.0);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_blurType'), parseInt(UI.blurType?.value || 0));

                    if (maskTex) {
                        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                    }
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                } else {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
            }
            else if (key === 'cell') {
                // [TOOL: CELL SHADING] Posterization & Outlines
                if (!UI.cellEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.cell);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(state.programs.cell, 'u_res'), w, h);
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_levels'), parseInt(UI.cellLevels?.value || 4));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_bias'), parseFloat(UI.cellBias?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_gamma'), parseFloat(UI.cellGamma?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_quantMode'), parseInt(UI.cellQuantMode?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_bandMap'), parseInt(UI.cellBandMap?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_edgeMethod'), parseInt(UI.cellEdgeMethod?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_edgeStr'), parseFloat(UI.cellEdgeStr?.value || 1));
                gl.uniform1f(gl.getUniformLocation(state.programs.cell, 'u_edgeThick'), parseFloat(UI.cellEdgeThick?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_colorPreserve'), UI.cellColorPreserve?.checked ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.cell, 'u_edgeEnable'), UI.cellEdgeEnable?.checked ? 1 : 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'halftone') {
                // [TOOL: HALFTONING] Simulated Print Screen
                if (!UI.halftoneEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.halftone);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(state.programs.halftone, 'u_res'), w, h);
                gl.uniform1f(gl.getUniformLocation(state.programs.halftone, 'u_size'), parseFloat(UI.halftoneSize?.value || 4));
                gl.uniform1f(gl.getUniformLocation(state.programs.halftone, 'u_intensity'), parseFloat(UI.halftoneIntensity?.value || 1));
                gl.uniform1f(gl.getUniformLocation(state.programs.halftone, 'u_sharpness'), parseFloat(UI.halftoneSharpness?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_pattern'), parseInt(UI.halftonePattern?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_colorMode'), parseInt(UI.halftoneColorMode?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_sample'), parseInt(UI.halftoneSample?.value || 1));
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_gray'), UI.halftoneGray?.checked ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_lock'), UI.halftoneScreenLock?.checked ? 1 : 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.halftone, 'u_invert'), UI.halftoneInvert?.checked ? 1 : 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'bilateral') {
                // [TOOL: BILATERAL FILTER] Skin Smoothing
                if (!UI.bilateralEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                const iters = Math.max(1, parseInt(UI.bilateralIter?.value || 1));
                gl.useProgram(state.programs.bilateral);
                gl.uniform2f(gl.getUniformLocation(state.programs.bilateral, 'u_res'), w, h);
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_radius'), parseInt(UI.bilateralRadius?.value || 2));
                gl.uniform1f(gl.getUniformLocation(state.programs.bilateral, 'u_sigmaCol'), parseFloat(UI.bilateralColorSig?.value || 0.1));
                gl.uniform1f(gl.getUniformLocation(state.programs.bilateral, 'u_sigmaSpace'), parseFloat(UI.bilateralSpatialSig?.value || 2));
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_kernel'), parseInt(UI.bilateralKernel?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_edgeMode'), parseInt(UI.bilateralEdgeMode?.value || 0));

                // Single pass for now as logic for pingpong inside here is complex without new FBOs
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.bilateral, 'u_tex'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'dither') {
                // [TOOL: DITHERING] Bit-depth Reduction
                if (!UI.ditherEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }

                let maskTex = null;
                const hasSH = UI.ditherLumaMask?.checked;
                const hasCol = UI.ditherColorExclude?.checked;

                if ((hasSH || hasCol) && state.fbos.blur1) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur1);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.DST_COLOR, gl.ZERO);

                    if (hasSH) {
                        gl.useProgram(state.programs.mask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI.ditherShadowThreshold.value));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI.ditherShadowFade.value));
                        gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI.ditherHighlightThreshold.value));
                        gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI.ditherHighlightFade.value));
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    if (hasCol) {
                        const targetColor = UI.ditherExcludeColor?.value || '#000000';
                        const r = parseInt(targetColor.slice(1, 3), 16) / 255;
                        const g = parseInt(targetColor.slice(3, 5), 16) / 255;
                        const b = parseInt(targetColor.slice(5, 7), 16) / 255;
                        gl.useProgram(state.programs.colorMask);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
                        gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), r, g, b);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI.ditherColorTolerance?.value || 10) / 100.0);
                        gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI.ditherColorFade?.value || 0) / 100.0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                    gl.disable(gl.BLEND);
                    maskTex = state.textures.blur1;

                    if (maskTex && UI.ditherInvertMask?.checked) {
                        gl.useProgram(state.programs.invert);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.blur2);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                        gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        maskTex = state.textures.blur2;
                    }
                }

                const prog = maskTex ? state.programs.maskedDither : state.programs.dither;
                gl.useProgram(prog);

                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_type'), parseInt(UI.ditherType?.value || 0));
                gl.uniform1f(gl.getUniformLocation(prog, 'u_bitDepth'), parseFloat(UI.ditherBitDepth.value));
                gl.uniform1f(gl.getUniformLocation(prog, 'u_paletteSize'), parseFloat(UI.ditherPaletteSize.value));
                gl.uniform1f(gl.getUniformLocation(prog, 'u_strength'), parseFloat(UI.ditherStrength.value) / 100.0);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_scale'), parseFloat(UI.ditherScale.value));
                gl.uniform2f(gl.getUniformLocation(prog, 'u_res'), w, h);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_seed'), Math.random() * 100.0);

                if (maskTex) {
                    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                    gl.uniform1i(gl.getUniformLocation(prog, 'u_mask'), 1);
                }

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'corruption') {
                // [TOOL: CORRUPTION] Glitch & Block Artifacts
                if (!UI.corruptionEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.corruption);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.corruption, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.corruption, 'u_algorithm'), parseInt(UI.corruptionAlgorithm?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.corruption, 'u_resScale'), parseFloat(UI.corruptionResScale?.value || 1));
                gl.uniform2f(gl.getUniformLocation(state.programs.corruption, 'u_res'), w, h);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'palette') {
                // [TOOL: PALETTE RECONSTRUCTOR] Indexed Color Mapping
                if (!UI.paletteEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.palette);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.palette, 'u_tex'), 0);
                gl.uniform1f(gl.getUniformLocation(state.programs.palette, 'u_blend'), parseFloat(UI.paletteBlend?.value || 100) / 100.0);
                gl.uniform1f(gl.getUniformLocation(state.programs.palette, 'u_smoothing'), parseFloat(UI.paletteSmoothing?.value || 0));
                gl.uniform1i(gl.getUniformLocation(state.programs.palette, 'u_smoothingType'), parseInt(UI.paletteSmoothingType?.value || 0));
                gl.uniform2f(gl.getUniformLocation(state.programs.palette, 'u_res'), w, h);

                const pSize = Math.min(state.palette.length, 256);
                gl.uniform1i(gl.getUniformLocation(state.programs.palette, 'u_paletteSize'), pSize);

                const flatPalette = new Float32Array(256 * 3);
                for (let i = 0; i < pSize; i++) {
                    const hex = state.palette[i];
                    flatPalette[i * 3 + 0] = parseInt(hex.slice(1, 3), 16) / 255;
                    flatPalette[i * 3 + 1] = parseInt(hex.slice(3, 5), 16) / 255;
                    flatPalette[i * 3 + 2] = parseInt(hex.slice(5, 7), 16) / 255;
                }
                gl.uniform3fv(gl.getUniformLocation(state.programs.palette, 'u_palette'), flatPalette);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else if (key === 'edge') {
                // [TOOL: EDGE EFFECTS] Advanced Outlines & Bloom
                if (!UI.edgeEnable?.checked && !force) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                    gl.useProgram(state.programs.copy);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                    gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    return;
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputFbo);
                gl.useProgram(state.programs.edge);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.edge, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(state.programs.edge, 'u_res'), w, h);
                gl.uniform1i(gl.getUniformLocation(state.programs.edge, 'u_mode'), parseInt(UI.edgeMode?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_strength'), parseFloat(UI.edgeStrength?.value || 500));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_tolerance'), parseFloat(UI.edgeTolerance?.value || 10));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_bgSat'), parseFloat(UI.edgeBgSat?.value || 0));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_fgSat'), parseFloat(UI.edgeFgSat?.value || 150));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_bloom'), parseFloat(UI.edgeBloom?.value || 10));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_smooth'), parseFloat(UI.edgeSmooth?.value || 50));
                gl.uniform1f(gl.getUniformLocation(state.programs.edge, 'u_blend'), parseFloat(UI.edgeBlend?.value || 100));

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
        }

        // --- PIPELINE EXECUTION ---

        // --- PIPELINE EXECUTION ---
        /** 
         * The orchestrator for the entire render process.
         * logic: 
         * 1. Reallocates FBOs if resolution changed.
         * 2. Uploads the base image to the first ping-pong buffer.
         * 3. Iterates through 'state.renderOrder' and calls 'renderSingleLayer' for each.
         * 4. Copies the final result to the screen/display canvas.
         */
        function renderFrame(isExport = false) {
            if (!state.baseImage) return;

            // --- FPS Counter ---
            if (!isExport) {
                const now = performance.now();
                if (state.lastFrameTime > 0) {
                    const deltaTime = now - state.lastFrameTime;
                    state.realtimeFps = 1000 / deltaTime;
                }
                state.lastFrameTime = now;
                state.frameRenderCount++;
                if (state.frameRenderCount % 15 === 0) { // Update UI every 15 frames
                    UI.actualFps.textContent = `(Actual: ${Math.round(state.realtimeFps)} FPS)`;
                }
            }
            // --------------------

            const gl = state.gl;
            const size = reallocateBuffers(isExport);
            const w = size.w;
            const h = size.h;
            gl.viewport(0, 0, w, h);

            let inputIdx = 0;
            let outputIdx = 1;

            // [EXPORT LOGIC] Draw upscaled base image to a temp canvas and upload as high-res texture
            let baseTex = state.textures.base;
            if (isExport && (w !== state.width || h !== state.height)) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(state.baseImage, 0, 0, state.width, state.height, 0, 0, w, h);
                // Create a new texture from the upscaled image
                baseTex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, baseTex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tempCanvas);
            }

            // Start with Base
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.pingPong[0].fbo);
            gl.useProgram(state.programs.copy);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, baseTex);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Clean up temp texture if created
            if (isExport && baseTex !== state.textures.base) {
                gl.deleteTexture(baseTex);
            }

            const uniforms = {
                u_bright: parseFloat(UI.brightness.value),
                u_cont: parseFloat(UI.contrast.value),
                u_sat: parseFloat(UI.saturationAdj.value) / 100.0,
                u_warmth: parseFloat(UI.warmth.value),
                u_sharp: parseFloat(UI.sharpen.value),
                u_sharpThresh: parseFloat(UI.sharpenThreshold.value),
                u_step: [1.0 / w, 1.0 / h],
                u_hdrTol: parseFloat(UI.hdrTolerance.value),
                u_hdrAmt: parseFloat(UI.hdrAmount.value),
                u_ca_amt: calcCurve(parseFloat(UI.aberrationAmount.value), 300, 300),
                u_ca_blur: calcCurve(parseFloat(UI.aberrationBlur.value), 100, 100.0),
                u_ca_center: [state.caCenter.x, state.caCenter.y],
                u_ca_rad: parseFloat(UI.caRadius.value) / 1000.0,
                u_ca_fall: parseFloat(UI.caFalloff.value) / 1000.0,
            };

            state.renderOrder.forEach(layerKey => {
                if (!state.layerVisibility[layerKey]) return;

                // Execute layer
                renderSingleLayer(gl, layerKey, state.pingPong[inputIdx].tex, state.pingPong[outputIdx].fbo, uniforms);

                // Save output for chain preview (and old grid logic)
                state.layerTextures[layerKey] = state.pingPong[outputIdx].tex;

                // Swap buffers
                let temp = inputIdx; inputIdx = outputIdx; outputIdx = temp;
            });

            // FINAL OUTPUT
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // Resize canvas DOM element to match render size
            // Setting width/height clears the canvas if preserveDrawingBuffer is false (it's true, but safer to assume it clears).
            // We draw immediately after resize.
            if (gl.canvas.width !== w || gl.canvas.height !== h) {
                gl.canvas.width = w;
                gl.canvas.height = h;
            }
            gl.viewport(0, 0, w, h);

            const sourceTex = state.activeLayerPreview && state.layerTextures[state.activeLayerPreview]
                ? state.layerTextures[state.activeLayerPreview]
                : state.pingPong[inputIdx].tex;

            let chan = 0;
            if (state.activeLayerPreview === 'shadows') chan = 2;
            if (state.activeLayerPreview === 'highlights') chan = 3;

            if (chan === 0) {
                gl.useProgram(state.programs.final);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, sourceTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.final, 'u_tex'), 0);
                gl.uniform2f(gl.getUniformLocation(state.programs.final, 'u_res'), w, h);
            } else {
                gl.useProgram(state.programs.copy);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, sourceTex);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), chan);
            }

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Ensure rendering is complete before export (toDataURL relies on buffer)
            if (isExport) {
                gl.finish();
            } else {
                updateLayerPreviews();
            }
        }

        function calcCurve(val, max, scale = 1.0) {
            const norm = val / max;
            return (norm * norm) * scale;
        }

        function updatePinPosition() {
            const x = state.caCenter.x * 100;
            const y = (1.0 - state.caCenter.y) * 100;
            UI.caPin.style.left = x + '%';
            UI.caPin.style.top = y + '%';
        }

        function updatePaletteUI() {
            UI.paletteList.innerHTML = '';
            state.palette.forEach((color, index) => {
                const item = document.createElement('div');
                item.className = 'palette-color-item';
                item.innerHTML = `
                    <input type="color" value="${color}">
                    <button class="remove-color-btn" title="Remove">&times;</button>
                `;
                item.querySelector('input').addEventListener('input', (e) => {
                    state.palette[index] = e.target.value;
                    requestRender();
                });
                item.querySelector('.remove-color-btn').addEventListener('click', () => {
                    state.palette.splice(index, 1);
                    updatePaletteUI();
                    requestRender();
                });
                UI.paletteList.appendChild(item);
            });
        }

        function syncNoiseUI() {
            const type = parseInt(UI.noiseType.value);
            const header = document.getElementById('noiseParamsHeader');
            const rowA = document.getElementById('noiseParamRowA');
            const rowB = document.getElementById('noiseParamRowB');
            const rowC = document.getElementById('noiseParamRowC');
            const labelA = document.getElementById('noiseLabelA');
            const labelB = document.getElementById('noiseLabelB');
            const labelC = document.getElementById('noiseLabelC');

            // Reset
            [header, rowA, rowB, rowC].forEach(el => el.style.display = 'none');

            const showSet = (a, b, c) => {
                header.style.display = 'block';
                if (a) { rowA.style.display = 'flex'; labelA.textContent = a; }
                if (b) { rowB.style.display = 'flex'; labelB.textContent = b; }
                if (c) { rowC.style.display = 'flex'; labelC.textContent = c; }
            };

            switch (type) {
                case 5: // Perlin
                    showSet("Complexity", "Organic Flow", "Octave Mix");
                    UI.noiseParamA.min = 1; UI.noiseParamA.max = 8; UI.noiseParamA.step = 1;
                    if (UI.noiseParamA.value > 8) UI.noiseParamA.value = 4;
                    break;
                case 6: // Worley
                    showSet("Cell Jitter", "Density", "Sphericity");
                    UI.noiseParamA.min = 0; UI.noiseParamA.max = 100; UI.noiseParamA.step = 1;
                    break;
                case 7: // Scanlines
                    showSet("Line Thickness", "Vertical Jitter", "Sync Grain");
                    break;
                case 8: // Speckle
                    showSet("Density", "Sharpness", "Variable Size");
                    break;
                case 9: // Glitch
                    showSet("Block Size", "Horiz Shift", "RGB Split");
                    break;
                case 10: // Anisotropic
                    showSet("Stretch", "Rotation", "Fiber Link");
                    break;
                case 11: // Voronoi Mosaic
                    showSet("Cell Detail", "Randomness", "Smoothness");
                    break;
                case 12: // Crosshatch
                    showSet("Line Density", "Diagonal Angle", "Pressure");
                    break;
            }
        }

        /** 
         * Procedural Color Palette Extraction.
         * logic: Uses 'Farthest First Traversal' to ensure the extracted palette 
         * is diverse and representative, not just the most common colors.
         * Reference: Controlled by 'Palette Reconstructor' UI.
         */
        async function extractPaletteFromImage(img, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 128; // Small size for faster analysis
            canvas.width = size;
            canvas.height = size;
            ctx.drawImage(img, 0, 0, size, size);
            const data = ctx.getImageData(0, 0, size, size).data;

            const counts = {};
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue; // Skip transparency
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
                counts[hex] = (counts[hex] || 0) + 1;
            }

            const uniqueColors = Object.entries(counts).map(([hex, freq]) => {
                return {
                    hex,
                    freq,
                    r: parseInt(hex.slice(1, 3), 16),
                    g: parseInt(hex.slice(3, 5), 16),
                    b: parseInt(hex.slice(5, 7), 16)
                };
            });

            if (uniqueColors.length === 0) return;

            // Farthest First Traversal (Diversity Logic)
            const resultPalette = [];
            // 1. Pick the most frequent as the anchor
            uniqueColors.sort((a, b) => b.freq - a.freq);
            resultPalette.push(uniqueColors[0]);

            // 2. Iteratively pick colors that are farthest from the current palette
            const dists = new Float32Array(uniqueColors.length).fill(1e10);

            const updateDists = (lastPicked) => {
                for (let i = 0; i < uniqueColors.length; i++) {
                    const c = uniqueColors[i];
                    const d = Math.sqrt(
                        Math.pow(c.r - lastPicked.r, 2) +
                        Math.pow(c.g - lastPicked.g, 2) +
                        Math.pow(c.b - lastPicked.b, 2)
                    );
                    if (d < dists[i]) dists[i] = d;
                }
            };

            updateDists(resultPalette[0]);

            const targetCount = Math.min(count, uniqueColors.length);
            while (resultPalette.length < targetCount) {
                let bestIdx = -1;
                let maxMinDist = -1;

                for (let i = 0; i < uniqueColors.length; i++) {
                    if (dists[i] > maxMinDist) {
                        maxMinDist = dists[i];
                        bestIdx = i;
                    }
                }

                if (bestIdx === -1) break;
                const picked = uniqueColors[bestIdx];
                resultPalette.push(picked);
                updateDists(picked);
            }

            state.palette = resultPalette.map(c => c.hex);
            updatePaletteUI();
            requestRender();
        }

        // [SHADER HELPERS] Direct WebGL wrapper functions
        function createShader(gl, type, srcId) {
            const src = document.getElementById(srcId).text.trim();
            const shader = gl.createShader(type == 'vs-quad' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
            gl.shaderSource(shader, src);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsId, fsId) {
            const vs = createShader(gl, 'vs-quad', vsId);
            const fs = createShader(gl, 'fs-fragment', fsId);
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.attachShader(p, fs);
            gl.linkProgram(p);
            return p;
        }

        function createTexture(gl, img, w, h, highPrec = false) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            const internalFormat = highPrec ? gl.RGBA16F : gl.RGBA;
            const format = gl.RGBA;
            const type = highPrec ? gl.HALF_FLOAT : gl.UNSIGNED_BYTE;

            if (img) {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, format, type, img);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
            }
            return tex;
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return { r, g, b };
        }

        // --- UTILS: EXPORT & UI ---

        /** 
         * [EXPORT] Renders and saves the final image at the highest quality.
         * logic: Temporarily sets 'upscaleFactor' to target resolution, processes 
         * the full stack, and extracts the buffer via 'toDataURL'.
         */
        async function downloadFullRes() {
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            // Ensure buffers are allocated for full resolution export
            reallocateBuffers(true);
            renderFrame(true);

            const link = document.createElement('a');
            link.download = 'grain-export.png';
            link.href = state.canvas.toDataURL('image/png', 1.0);
            link.click();

            // Restore buffers to preview size after export
            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        /** 
         * [COMPARISON MODAL] Visual A/B Testing.
         * logic: Renders full image at 1:1, copies to a side-by-side modal for detail inspection.
         * Note: Temporarily forces full-res buffers to ensure accuracy.
         */
        async function openCompare() {
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            renderFrame(true);

            const original = document.getElementById('compareOriginal');
            const processed = document.getElementById('compareProcessed');

            const aspect = state.width / state.height;
            original.width = 600; original.height = 600 / aspect;
            processed.width = 600; processed.height = 600 / aspect;

            const ctxO = original.getContext('2d');
            const ctxP = processed.getContext('2d');

            ctxO.drawImage(state.baseImage, 0, 0, original.width, original.height);
            ctxP.drawImage(state.canvas, 0, 0, processed.width, processed.height);

            // Update Export Info
            if (UI.exportInfo) {
                const reqW = Math.round(state.width * state.upscaleFactor);
                const reqH = Math.round(state.height * state.upscaleFactor);
                const actW = state.renderWidth;
                const actH = state.renderHeight;
                const scale = state._exportScale || 1.0;

                UI.exportInfo.innerHTML = `Requested: ${reqW}x${reqH} | Actual: ${actW}x${actH} (Safe Scale: ${scale.toFixed(2)})`;

                if (scale < 1.0) {
                    UI.exportInfo.style.color = '#ffaa00'; // Warning color if downscaled
                } else {
                    UI.exportInfo.style.color = '#0f0';
                }
            }

            document.getElementById('compareModal').classList.add('show');

            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        /** 
         * [EXPORT] Multi-panel Comparison Image.
         * logic: Combines original and processed images into a single vertical or horizontal layout.
         */
        async function exportComparison(mode) {
            UI.loading.style.display = 'block';
            await new Promise(r => setTimeout(r, 50));

            renderFrame(true);
            const processedData = state.canvas.toDataURL();
            const processedImg = new Image();
            processedImg.src = processedData;
            await new Promise(r => processedImg.onload = r);

            const exp = document.createElement('canvas');
            const w = state.canvas.width;
            const h = state.canvas.height;

            if (mode === 'side') {
                exp.width = w * 2;
                exp.height = h;
                const ctx = exp.getContext('2d');
                ctx.drawImage(state.baseImage, 0, 0, w, h);
                ctx.drawImage(processedImg, w, 0);
            } else {
                exp.width = w;
                exp.height = h * 2;
                const ctx = exp.getContext('2d');
                ctx.drawImage(state.baseImage, 0, 0, w, h);
                ctx.drawImage(processedImg, 0, h);
            }

            const link = document.createElement('a');
            link.download = `grain-compare-${mode}.png`;
            link.href = exp.toDataURL('image/png', 0.9);
            link.click();

            reallocateBuffers(false);
            requestRender();
            UI.loading.style.display = 'none';
        }

        // --- PREVIEW SYSTEM REFACTOR ---

        /** 
         * Maps an input element index to its parent tool category.
         * logic: Used to auto-update the Section Breakdown grid when a slider is moved.
         */
        function getSectionFromId(id) {
            if (!id) return null;
            if (id.startsWith('adj') || id === 'brightness' || id === 'contrast' || id === 'saturationAdj' || id === 'warmth' || id === 'sharpen') return 'adjust';
            if (id.startsWith('hdr')) return 'hdr';
            if (id.startsWith('noise') || id === 'opacity' || id === 'strength' || id === 'blendMode' || id.startsWith('sat') || id.startsWith('ignore')) return 'noise';
            if (id.startsWith('blur')) return 'blur';
            if (id.startsWith('dither')) return 'dither';
            if (id.startsWith('cell')) return 'cell';
            if (id.startsWith('halftone')) return 'halftone';
            if (id.startsWith('bilateral')) return 'bilateral';
            if (id.startsWith('aberration') || id.startsWith('ca')) return 'ca';
            if (id.startsWith('corruption')) return 'corruption';
            if (id.startsWith('palette')) return 'palette';
            if (id.startsWith('edge')) return 'edge';
            return 'adjust'; // Default fallthrough to adjust if unknown (or null)
        }

        /** 
         * Dynamically builds the 'Layer Breakdown' UI based on the current active tool.
         * logic: Injects 'Chain Result', 'Isolated', and 'Mask' preview tiles.
         */
        function setupLayerGridDOM(section) {
            const grid = UI.layerGrid;
            grid.innerHTML = '';

            const items = [
                { id: 'chain', label: 'Chain' },
                { id: 'isolated', label: 'Isolated' }
            ];

            const maskLayers = {
                'blur': true,
                'dither': true,
                'halftone': true,
                'bilateral': true,
                'adjust': true,
                'noise': true
            };

            if (maskLayers[section]) {
                items.push({ id: 'mask_luma', label: 'Luma Mask' });
                items.push({ id: 'mask_color', label: 'Color Mask' });
                items.push({ id: 'mask_total', label: 'Total Mask' });
            } else if (section === 'ca') {
                items.push({ id: 'falloff', label: 'Falloff Map' });
            }

            // Calculate dimensions based on aspect ratio
            const aspect = state.width / state.height;
            const thumbHeight = 110; // Fixed vertical space for canvas roughly
            const thumbWidth = thumbHeight * aspect;

            items.forEach(item => {
                const d = document.createElement('div');
                d.className = 'layer-item';
                d.style.minWidth = `${Math.max(80, thumbWidth)}px`;
                d.style.flex = '0 0 auto';

                const key = section + '_' + item.id;
                if (state.activeLayerPreview === key) d.classList.add('active');

                d.onclick = () => {
                    const targetKey = section + '_' + item.id;
                    if (state.activeLayerPreview === targetKey) {
                        state.activeLayerPreview = null;
                        d.classList.remove('active');
                    } else {
                        state.activeLayerPreview = targetKey;
                        document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('active'));
                        d.classList.add('active');
                        UI.overlayOriginal.classList.remove('show');
                    }
                    requestRender();
                };

                d.innerHTML = `
                    <div class="layer-title">${item.label}</div>
                    <canvas class="layer-canvas" id="thumb-${item.id}" width="${Math.round(thumbWidth)}" height="${thumbHeight}"></canvas>
                `;
                grid.appendChild(d);
            });
        }

        /** 
         * Logic for the 'Breakdown' strip.
         * logic: 
         * 1. Renders the currently selected section in 'Isolated' mode (only that effect on base image).
         * 2. Extracts the 'Mask' texture if masking is active.
         * 3. Draws all results to the small preview canvases using 'drawToThumbnail'.
         */
        function updateLayerPreviews() {
            const gl = state.gl;
            if (!state.baseImage) return;

            const section = state.activeSection || 'adjust';

            if (state.lastActiveSectionDOM !== section) {
                setupLayerGridDOM(section);
                state.lastActiveSectionDOM = section;
            }

            if (!state.thumbnailFBO) return;

            // 1. Chain Result
            const chainTex = state.layerTextures[section];
            drawToThumbnail(chainTex, 'thumb-chain');

            const orderIdx = state.renderOrder.indexOf(section);
            const inputTex = (orderIdx > 0) ? state.layerTextures[state.renderOrder[orderIdx - 1]] : state.textures.base;

            const uniforms = {
                u_bright: parseFloat(UI.brightness.value),
                u_cont: parseFloat(UI.contrast.value),
                u_sat: parseFloat(UI.saturationAdj.value) / 100.0,
                u_warmth: parseFloat(UI.warmth.value),
                u_sharp: parseFloat(UI.sharpen.value),
                u_sharpThresh: parseFloat(UI.sharpenThreshold.value),
                u_step: [1.0 / state.renderWidth, 1.0 / state.renderHeight],
                u_hdrTol: parseFloat(UI.hdrTolerance.value),
                u_hdrAmt: parseFloat(UI.hdrAmount.value),
                u_ca_amt: calcCurve(parseFloat(UI.aberrationAmount.value), 300, 300),
                u_ca_blur: calcCurve(parseFloat(UI.aberrationBlur.value), 100, 100.0),
                u_ca_center: [state.caCenter.x, state.caCenter.y],
                u_ca_rad: parseFloat(UI.caRadius.value) / 1000.0,
                u_ca_falloff: parseFloat(UI.caFalloff.value) / 1000.0
            };

            renderSingleLayer(gl, section, inputTex, state.fbos.preview, uniforms, true);
            drawToThumbnail(state.textures.preview, 'thumb-isolated');

            // Special case for active preview overrides
            if (state.activeLayerPreview === section + '_isolated') {
                state.layerTextures[state.activeLayerPreview] = state.textures.preview;
            }

            // 3. Mask Previews (Dedicated path)
            const lumaCanvas = document.getElementById('thumb-mask_luma');
            const colorCanvas = document.getElementById('thumb-mask_color');
            const totalCanvas = document.getElementById('thumb-mask_total');

            if (lumaCanvas || colorCanvas || totalCanvas) {
                renderMaskForSection(section, inputTex);

                if (lumaCanvas) {
                    drawToThumbnail(state.textures.maskLuma, 'thumb-mask_luma', 1); // R channel
                    if (state.activeLayerPreview === section + '_mask_luma') state.layerTextures[state.activeLayerPreview] = state.textures.maskLuma;
                }
                if (colorCanvas) {
                    drawToThumbnail(state.textures.maskColor, 'thumb-mask_color', 0); // Composite is enough if colorMask is simple
                    if (state.activeLayerPreview === section + '_mask_color') state.layerTextures[state.activeLayerPreview] = state.textures.maskColor;
                }
                if (totalCanvas) {
                    drawToThumbnail(state.textures.maskTotal, 'thumb-mask_total', 0);
                    if (state.activeLayerPreview === section + '_mask_total') state.layerTextures[state.activeLayerPreview] = state.textures.maskTotal;
                }
            }

            // Falloff for CA
            const falloffCanvas = document.getElementById('thumb-falloff');
            if (falloffCanvas) {
                renderCAFalloff();
                drawToThumbnail(state.textures.preview, 'thumb-falloff');
                if (state.activeLayerPreview === section + '_falloff') state.layerTextures[state.activeLayerPreview] = state.textures.preview;
            }
        }

        function renderMaskForSection(section, inputTex) {
            const gl = state.gl;
            const w = state.renderWidth;
            const h = state.renderHeight;
            gl.viewport(0, 0, w, h);

            // Ensure we have mask textures if not exists
            if (!state.textures.maskLuma) {
                state.textures.maskLuma = createTexture(gl, null, w, h);
                state.fbos.maskLuma = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskLuma);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, state.textures.maskLuma, 0);

                state.textures.maskColor = createTexture(gl, null, w, h);
                state.fbos.maskColor = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskColor);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, state.textures.maskColor, 0);

                state.textures.maskTotal = createTexture(gl, null, w, h);
                state.fbos.maskTotal = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskTotal);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, state.textures.maskTotal, 0);
            }

            // Get prefix (e.g. 'adj', 'noise', 'blur')
            let pref = section === 'adjust' ? 'adj' : section;

            // Luma Mask
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskLuma);
            gl.useProgram(state.programs.mask);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
            gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_tex'), 0);
            gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useS'), 1);
            gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sth'), parseFloat(UI[pref + 'ShadowThreshold']?.value || UI['shadowThreshold']?.value || 0));
            gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_sfa'), parseFloat(UI[pref + 'ShadowFade']?.value || UI['shadowFade']?.value || 0));
            gl.uniform1i(gl.getUniformLocation(state.programs.mask, 'u_useH'), 1);
            gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hth'), parseFloat(UI[pref + 'HighlightThreshold']?.value || UI['highlightThreshold']?.value || 1));
            gl.uniform1f(gl.getUniformLocation(state.programs.mask, 'u_hfa'), parseFloat(UI[pref + 'HighlightFade']?.value || UI['highlightFade']?.value || 0));
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Color Mask
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskColor);
            const targetColor = UI[pref + 'ExcludeColor']?.value || UI['noiseExcludeColor']?.value || '#000000';
            const rgb = hexToRgb(targetColor);
            gl.useProgram(state.programs.colorMask);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
            gl.uniform1i(gl.getUniformLocation(state.programs.colorMask, 'u_tex'), 0);
            gl.uniform3f(gl.getUniformLocation(state.programs.colorMask, 'u_targetColor'), rgb.r, rgb.g, rgb.b);
            gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_tolerance'), parseFloat(UI[pref + 'ColorTolerance']?.value || UI['noiseColorTolerance']?.value || 0.1) / 100.0);
            gl.uniform1f(gl.getUniformLocation(state.programs.colorMask, 'u_fade'), parseFloat(UI[pref + 'ColorFade']?.value || UI['noiseColorFade']?.value || 0) / 100.0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Total Mask
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskTotal);
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.DST_COLOR, gl.ZERO);

            if (UI[pref + 'LumaMask']?.checked || UI['noiseLumaMask']?.checked) {
                gl.useProgram(state.programs.copy);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.maskLuma);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), 1); // R is combined mask in fs-mask
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            if (UI[pref + 'ColorExclude']?.checked || UI['noiseColorExclude']?.checked) {
                gl.useProgram(state.programs.copy);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.maskColor);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            gl.disable(gl.BLEND);

            if (UI[pref + 'InvertMask']?.checked || UI['noiseInvertMask']?.checked) {
                gl.useProgram(state.programs.invert);
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.preview); // Temporarily use preview FBO for inversion
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.maskTotal);
                gl.uniform1i(gl.getUniformLocation(state.programs.invert, 'u_tex'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                // Copy back
                gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.maskTotal);
                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.textures.preview);
                gl.useProgram(state.programs.copy);
                gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
        }

        function renderCAFalloff() {
            const gl = state.gl;
            const w = state.renderWidth;
            const h = state.renderHeight;
            gl.viewport(0, 0, w, h);

            gl.bindFramebuffer(gl.FRAMEBUFFER, state.fbos.preview);
            gl.useProgram(state.programs.radial);
            gl.uniform2f(gl.getUniformLocation(state.programs.radial, 'u_res'), w, h);
            gl.uniform2f(gl.getUniformLocation(state.programs.radial, 'u_center'), state.caCenter.x, state.caCenter.y);
            gl.uniform1f(gl.getUniformLocation(state.programs.radial, 'u_radius'), parseFloat(UI.caRadius.value) / 1000.0);
            gl.uniform1f(gl.getUniformLocation(state.programs.radial, 'u_falloff'), parseFloat(UI.caFalloff.value) / 1000.0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        /** 
         * Low-level helper to copy a WebGL texture onto a 2D canvas.
         * logic: Uses an intermediate offscreen FBO to read pixels from the GPU into the CPU-bound canvas.
         */
        function drawToThumbnail(tex, canvasId, channel = 0) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !tex) return;
            const gl = state.gl;

            // Use the canvas's own dimensions for sampling
            const dw = canvas.width;
            const dh = canvas.height;

            // We need an FBO that matches the thumbnail canvas size for accuracy?
            // Or we just use a fixed small FBO and let the context scaling handle it.
            // Let's use thumbnailFBO as it's already allocated.
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.thumbnailFBO.fbo);
            gl.viewport(0, 0, state.thumbnailFBO.w, state.thumbnailFBO.h);
            gl.useProgram(state.programs.copy);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_tex'), 0);
            gl.uniform1i(gl.getUniformLocation(state.programs.copy, 'u_channel'), channel);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            const pixels = new Uint8Array(state.thumbnailFBO.w * state.thumbnailFBO.h * 4);
            gl.readPixels(0, 0, state.thumbnailFBO.w, state.thumbnailFBO.h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            const ctx = canvas.getContext('2d', { alpha: false });

            // Optimization: Use an offscreen canvas to scale if thumbnailFBO size doesn't match canvas
            // For now, simple putImageData with scaling or just use the pixels directly.
            // Since thumbnailFBO is 320x180 and canvas might be different, let's use a temp imageData.
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = state.thumbnailFBO.w;
            tempCanvas.height = state.thumbnailFBO.h;
            const tempCtx = tempCanvas.getContext('2d');

            const tw = state.thumbnailFBO.w;
            const th = state.thumbnailFBO.h;
            const scaledData = new Uint8ClampedArray(tw * th * 4);

            for (let y = 0; y < th; y++) {
                const srcY = th - 1 - y;
                const srcOff = srcY * tw * 4;
                const dstOff = y * tw * 4;
                for (let i = 0; i < tw * 4; i++) {
                    scaledData[dstOff + i] = pixels[srcOff + i];
                }
            }
            const fullImgData = new ImageData(scaledData, tw, th);
            tempCtx.putImageData(fullImgData, 0, 0);

            // Draw from temp canvas to final canvas to handle resizing (aspect ratio correct)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, dw, dh);
            ctx.drawImage(tempCanvas, 0, 0, tw, th, 0, 0, dw, dh);
        }
    </script>
    <script type="x-shader/x-fragment" id="fs-final">
#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_res;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    vec4 c = texture(u_tex, v_uv);
    // Standard 1-bit dither to prevent banding on 8-bit output
    float noise = (hash(v_uv * u_res) - 0.5) / 255.0;
    outColor = vec4(c.rgb + noise, c.a);
}
</script>
</body>

</html>