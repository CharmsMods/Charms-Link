<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Frequency Lab — Real-time FFT Image Editor (WebGL)</title>
<style>
  :root{
    --bg:#0b0f12;
    --panel:#0e1316;
    --muted:#9aa6ad;
    --accent:#5eead4;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:var(--bg);color:var(--muted);display:flex;align-items:stretch;gap:16px;padding:18px;box-sizing:border-box}
  .panel{background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:12px}
  .left{width:360px;min-width:320px;max-width:420px;height:calc(100vh - 36px);overflow:auto}
  .right{flex:1;display:flex;flex-direction:column;gap:12px;height:calc(100vh - 36px)}
  h1{margin:0;font-size:16px;color:var(--accent)}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input[type=range]{width:100%}
  .controls{display:grid;grid-template-columns:1fr 64px;gap:8px;align-items:center}
  .row{display:flex;gap:8px;align-items:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px;border-radius:8px;cursor:pointer}
  button.primary{border-color:var(--accent);color:#061017;background:linear-gradient(180deg, rgba(94,234,212,0.06), rgba(94,234,212,0.02))}
  small{color:#7f8a8f}
  canvas#spectrum{width:100%;height:240px;border-radius:6px;background:var(--glass);display:block}
  .stage{background:#0b1012;border-radius:8px;padding:10px}
  .flex-row{display:flex;gap:8px;align-items:center}
  .info{font-size:12px;color:#7f8a8f}
  .large-canvas{flex:1;border-radius:10px;background:#050708;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
  canvas#out{width:100%;height:100%;display:block}
  .footer{display:flex;gap:8px;align-items:center;justify-content:space-between;padding-top:6px}
  .small-muted{font-size:12px;color:#6f7b80}
  .note{font-size:11px;color:#4d585b}
  .row-wrap{display:flex;flex-wrap:wrap;gap:8px}
  .chip{padding:6px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.04);font-size:12px}
  input[type=file]{display:none}
  .btn-file{display:inline-flex;align-items:center;gap:8px}
  .kbd{font-family:monospace;background:rgba(255,255,255,0.03);padding:2px 6px;border-radius:6px;font-size:12px}
</style>
</head>
<body>
  <div class="panel left">
    <h1>Frequency Lab</h1>
    <div class="stage">
      <label>Image</label>
      <div class="row">
        <label class="btn-file">
          <button id="btnLoad" class="primary">Load Image</button>
        </label>
        <button id="btnReset">Reset</button>
        <button id="btnRand">Random Noise</button>
        <input id="file" type="file" accept="image/*">
      </div>
      <div class="info">Resize for performance: <select id="sizeSelect">
        <option value="128">128</option>
        <option value="256" selected>256</option>
        <option value="512">512</option>
        <option value="1024">1024</option>
      </select></div>
    </div>

    <div class="stage">
      <label>Filter Mode</label>
      <div class="row-wrap">
        <div class="chip"><input type="radio" name="mode" id="modeLow" value="low" checked> <label for="modeLow">Low-pass</label></div>
        <div class="chip"><input type="radio" name="mode" id="modeHigh" value="high"> <label for="modeHigh">High-pass</label></div>
        <div class="chip"><input type="radio" name="mode" id="modeBand" value="band"> <label for="modeBand">Band-pass</label></div>
        <div class="chip"><input type="radio" name="mode" id="modeNotch" value="notch"> <label for="modeNotch">Notch (click spectrum)</label></div>
      </div>

      <div style="margin-top:8px">
        <label>Radius / Center (px)</label>
        <div class="controls">
          <input id="radius" type="range" min="0" max="512" value="60">
          <div><input id="radiusVal" class="kbd" readonly style="width:54px;text-align:center"></div>
        </div>

        <label style="margin-top:8px">Band width (for band-pass)</label>
        <div class="controls">
          <input id="width" type="range" min="0" max="256" value="20">
          <div><input id="widthVal" class="kbd" readonly style="width:54px;text-align:center"></div>
        </div>

        <label style="margin-top:8px">Mix (original ↔ filtered)</label>
        <div class="controls">
          <input id="mix" type="range" min="0" max="100" value="100">
          <div><input id="mixVal" class="kbd" readonly style="width:54px;text-align:center"></div>
        </div>
      </div>
    </div>

    <div class="stage">
      <label>Spectrum (click to toggle notch frequency when 'Notch' mode selected)</label>
      <canvas id="spectrum" width="512" height="512"></canvas>
      <div class="info" style="margin-top:8px">Log magnitude visualization. Click to add/remove notch points.</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnApply">Apply Filter</button>
        <button id="btnAuto">Auto-remove (detect peaks)</button>
        <button id="btnDownload">Download PNG</button>
      </div>
    </div>

    <div class="stage">
      <div class="footer">
        <div class="small-muted">Size limit: power-of-two. Processing optimized for speed; pick lower sizes for live updates.</div>
        <div class="note">Uses WebGL to render result texture.</div>
      </div>
    </div>
  </div>

  <div class="panel right">
    <div class="row" style="justify-content:space-between">
      <div style="display:flex;gap:8px;align-items:center">
        <div class="chip">Preview</div>
        <div class="chip">Spectrum</div>
      </div>
      <div style="display:flex;gap:8px">
        <div class="info">Filter size: <span id="procSize">256</span> px</div>
      </div>
    </div>

    <div class="large-canvas">
      <canvas id="out"></canvas>
      <!-- overlay for status -->
      <div id="overlay" style="position:absolute;left:12px;top:12px;color:var(--muted);font-size:12px"></div>
    </div>
  </div>

<script>
/*
  Frequency Lab
  - 2D FFT implemented in JS (typed arrays), size limited to chosen power-of-two.
  - Image is converted to luminance; full-color path included (per-channel) but default uses luminance for speed.
  - Filtering operates on frequency-domain complex buffer (centered: zero-frequency moved to center).
  - Inverse FFT computed on CPU; final pixels uploaded to WebGL texture for fast display.
  - Notch editing via clicking the spectrum canvas.
*/

/* ---------- Utilities & FFT (1D iterative Cooley-Tukey) ---------- */

function bitReverse(n, bits) {
  let rev = 0;
  for (let i=0;i<bits;i++){
    rev = (rev<<1) | (n & 1);
    n >>= 1;
  }
  return rev;
}

function fft1d(real, imag, inverse=false) {
  // in-place radix-2 iterative FFT. arrays should be Float32Array length N.
  const n = real.length;
  const bits = Math.round(Math.log2(n));
  if ((1<<bits) !== n) throw new Error('fft1d: length must be power of two');

  // bit reversal permutation
  for (let i=0;i<n;i++){
    const j = bitReverse(i, bits);
    if (j > i) {
      let tr = real[i], ti = imag[i];
      real[i] = real[j]; imag[i] = imag[j];
      real[j] = tr; imag[j] = ti;
    }
  }

  for (let len = 2; len <= n; len <<= 1) {
    const ang = 2*Math.PI/len*(inverse? -1:1);
    const wlen_r = Math.cos(ang);
    const wlen_i = Math.sin(ang);
    for (let i=0;i<n;i+=len){
      let wr = 1, wi = 0;
      for (let j=0;j<len/2;j++){
        const u_r = real[i+j], u_i = imag[i+j];
        const v_r = real[i+j+len/2], v_i = imag[i+j+len/2];
        // v * w
        const vr = v_r*wr - v_i*wi;
        const vi = v_r*wi + v_i*wr;
        // combine
        real[i+j] = u_r + vr;
        imag[i+j] = u_i + vi;
        real[i+j+len/2] = u_r - vr;
        imag[i+j+len/2] = u_i - vi;
        // w *= wlen
        const nxt_wr = wr * wlen_r - wi * wlen_i;
        const nxt_wi = wr * wlen_i + wi * wlen_r;
        wr = nxt_wr; wi = nxt_wi;
      }
    }
  }

  // normalize if inverse
  if (inverse) {
    for (let i=0;i<n;i++){ real[i] /= n; imag[i] /= n; }
  }
}

/* 2D FFT: perform 1D on rows then on columns */
function fft2d(real2d, imag2d, size, inverse=false) {
  // real2d/imagine2d are Float32Array size*size
  const N = size;
  const rowR = new Float32Array(N), rowI = new Float32Array(N);
  // rows
  for (let y=0;y<N;y++){
    let base = y*N;
    for (let x=0;x<N;x++){ rowR[x] = real2d[base+x]; rowI[x] = imag2d[base+x]; }
    fft1d(rowR, rowI, inverse);
    for (let x=0;x<N;x++){ real2d[base+x] = rowR[x]; imag2d[base+x] = rowI[x]; }
  }
  // cols
  for (let x=0;x<N;x++){
    for (let y=0;y<N;y++){ rowR[y] = real2d[y*N + x]; rowI[y] = imag2d[y*N + x]; }
    fft1d(rowR, rowI, inverse);
    for (let y=0;y<N;y++){ real2d[y*N + x] = rowR[y]; imag2d[y*N + x] = rowI[y]; }
  }
}

/* shift zero-frequency to center (fftshift) and back */
function fftShiftInPlace(real, imag, N) {
  // swap quadrants
  const half = N/2;
  const tmpR = new Float32Array(half*half);
  const tmpI = new Float32Array(half*half);
  // top-left <-> bottom-right
  for (let y=0;y<half;y++){
    for (let x=0;x<half;x++){
      const a = y*N + x;
      const b = (y+half)*N + (x+half);
      const tR = real[a], tI = imag[a];
      real[a] = real[b]; imag[a] = imag[b];
      real[b] = tR; imag[b] = tI;
    }
  }
  // top-right <-> bottom-left
  for (let y=0;y<half;y++){
    for (let x=0;x<half;x++){
      const a = y*N + (x+half);
      const b = (y+half)*N + x;
      const tR = real[a], tI = imag[a];
      real[a] = real[b]; imag[a] = imag[b];
      real[b] = tR; imag[b] = tI;
    }
  }
}

/* magnitude log scaled for visualization */
function computeLogMagnitude(real, imag, N) {
  const out = new Float32Array(N*N);
  let maxv = 0;
  for (let i=0;i<N*N;i++){
    const m = Math.hypot(real[i], imag[i]);
    out[i] = m;
    if (m > maxv) maxv = m;
  }
  // log scale
  const outL = new Float32Array(N*N);
  const s = 1 / Math.log(1 + (maxv||1));
  for (let i=0;i<N*N;i++){
    outL[i] = Math.log(1 + out[i]) * s;
  }
  return outL;
}

/* ---------- Image loading, conversion, utility helpers ---------- */

const fileInput = document.getElementById('file');
const btnLoad = document.getElementById('btnLoad');
const btnReset = document.getElementById('btnReset');
const btnRand = document.getElementById('btnRand');
const sizeSelect = document.getElementById('sizeSelect');
const procSize = document.getElementById('procSize');

btnLoad.addEventListener('click', ()=>fileInput.click());
fileInput.addEventListener('change', async (e)=>{
  if (!e.target.files || !e.target.files[0]) return;
  const f = e.target.files[0];
  const img = await loadImageFromFile(f);
  prepareImage(img);
});

btnReset.addEventListener('click', ()=>{ if (origImage) prepareImage(origImage); });
btnRand.addEventListener('click', ()=>{ generateNoise(); });

function loadImageFromFile(file){
  return new Promise((res, rej)=>{
    const img = new Image();
    const url = URL.createObjectURL(file);
    img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
    img.onerror = (e)=> rej(e);
    img.src = url;
  });
}

/* ---------- Core state ---------- */
let size = parseInt(sizeSelect.value,10) || 256;
let origImage = null;
let workingRGB = null; // Uint8ClampedArray final output RGBA
let realBuf = null, imagBuf = null; // Float32Array length size*size per channel (we'll use luminance for speed)
let spectrumVis = null; // Float32Array len size*size (log magnitude)
let notchPoints = []; // array of [x,y] in freq coords (centered)
let channelMode = 'luma'; // or 'rgb' (not implemented full for speed)

sizeSelect.addEventListener('change', ()=>{
  size = parseInt(sizeSelect.value,10);
  procSize.textContent = size;
  if (origImage) prepareImage(origImage);
});

procSize.textContent = size;

function prepareBuffers(N){
  realBuf = new Float32Array(N*N);
  imagBuf = new Float32Array(N*N);
  spectrumVis = new Float32Array(N*N);
}

/* load and resize into canvas, convert to luminance */
function prepareImage(img){
  origImage = img;
  size = parseInt(sizeSelect.value,10);
  procSize.textContent = size;
  const c = document.createElement('canvas');
  c.width = size; c.height = size;
  const ctx = c.getContext('2d');
  // draw cover-center crop
  const ar = img.width / img.height;
  if (ar > 1){
    // wide
    const h = img.height;
    const w = h;
    const sx = (img.width - w)/2;
    ctx.drawImage(img, sx, 0, w, h, 0, 0, size, size);
  } else {
    const w = img.width;
    const h = w;
    const sy = (img.height - h)/2;
    ctx.drawImage(img, 0, sy, w, h, 0, 0, size, size);
  }
  const id = ctx.getImageData(0,0,size,size);
  const d = id.data;
  // fill realBuf with luminance
  prepareBuffers(size);
  for (let y=0;y<size;y++){
    for (let x=0;x<size;x++){
      const i = (y*size + x);
      const di = i*4;
      const r = d[di], g = d[di+1], b = d[di+2];
      const l = 0.299*r + 0.587*g + 0.114*b;
      realBuf[i] = l;
      imagBuf[i] = 0;
    }
  }
  computeAndRender();
}

/* generate random white noise */
function generateNoise(){
  size = parseInt(sizeSelect.value,10);
  prepareBuffers(size);
  for (let i=0;i<size*size;i++){
    realBuf[i] = Math.random()*255;
    imagBuf[i] = 0;
  }
  computeAndRender();
}

/* ---------- Frequency domain operations ---------- */

function forwardFFT_andShift(){
  // operate in-place on realBuf/imagBuf
  fft2d(realBuf, imagBuf, size, false);
  fftShiftInPlace(realBuf, imagBuf, size);
}

function inverseShift_andIFFT(){
  fftShiftInPlace(realBuf, imagBuf, size); // shift back
  fft2d(realBuf, imagBuf, size, true);
}

/* build mask according to UI */
function buildMask() {
  const N = size;
  const cx = N/2, cy = N/2;
  const r = parseFloat(document.getElementById('radius').value);
  const w = parseFloat(document.getElementById('width').value);
  const mode = document.querySelector('input[name="mode"]:checked').value;
  const mask = new Float32Array(N*N);
  for (let y=0;y<N;y++){
    for (let x=0;x<N;x++){
      const dx = x - cx, dy = y - cy;
      const dist = Math.hypot(dx,dy);
      let val = 1;
      if (mode === 'low') {
        val = dist <= r ? 1 : 0;
      } else if (mode === 'high') {
        val = dist >= r ? 1 : 0;
      } else if (mode === 'band') {
        val = (dist >= (r - w) && dist <= (r + w)) ? 1 : 0;
      } else if (mode === 'notch') {
        val = 1;
        // apply notches
        for (const p of notchPoints){
          const dx2 = x - (p[0]+cx);
          const dy2 = y - (p[1]+cy);
          if (Math.hypot(dx2,dy2) < Math.max(6, w)) { val = 0; break; }
        }
      }
      mask[y*N + x] = val;
    }
  }
  return mask;
}

/* apply mask in frequency domain (multiply complex bins) */
function applyMask(mask){
  const N = size;
  for (let i=0;i<N*N;i++){
    realBuf[i] *= mask[i];
    imagBuf[i] *= mask[i];
  }
}

/* detect bright peaks (for auto notch) */
function autoDetectPeaks() {
  const mag = new Float32Array(size*size);
  let maxv = 0;
  for (let i=0;i<size*size;i++){
    const m = Math.hypot(realBuf[i], imagBuf[i]);
    mag[i] = m;
    if (m>maxv) maxv=m;
  }
  // threshold at some fraction
  const thr = maxv * 0.15;
  const peaks = [];
  for (let y=0;y<size;y++){
    for (let x=0;x<size;x++){
      const i = y*size + x;
      if (mag[i] > thr) {
        // exclude center low-freq
        const cx = size/2, cy = size/2;
        if (Math.hypot(x-cx,y-cy) < 6) continue;
        peaks.push([x - cx, y - cy]);
        if (peaks.length >= 12) return peaks;
      }
    }
  }
  return peaks;
}

/* ---------- Spectrum visualization ---------- */

const specCanvas = document.getElementById('spectrum');
const specCtx = specCanvas.getContext('2d');

function renderSpectrum(){
  const vis = computeLogMagnitude(realBuf, imagBuf, size);
  // map to canvas size
  const c = specCanvas;
  const ctx = specCtx;
  const img = ctx.createImageData(c.width, c.height);
  for (let y=0;y<c.height;y++){
    for (let x=0;x<c.width;x++){
      // sample vis nearest
      const sx = Math.floor(x * size / c.width);
      const sy = Math.floor(y * size / c.height);
      const v = vis[sy*size + sx];
      const col = Math.floor(255 * v);
      const idx = (y*c.width + x)*4;
      // grayscale -> color ramp to help reading
      img.data[idx] = col;
      img.data[idx+1] = col;
      img.data[idx+2] = col;
      img.data[idx+3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);
  // draw notch markers
  if (notchPoints.length){
    ctx.fillStyle = '#ff7b72';
    const cx = c.width/2, cy = c.height/2;
    const scale = c.width / size;
    for (const p of notchPoints){
      ctx.beginPath();
      ctx.arc(cx + p[0]*scale, cy + p[1]*scale, 6, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

/* handle clicks on spectrum to toggle notch points (only in notch mode) */
specCanvas.addEventListener('click', (ev)=>{
  const rect = specCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (specCanvas.width/rect.width);
  const y = (ev.clientY - rect.top) * (specCanvas.height/rect.height);
  const cx = specCanvas.width/2, cy = specCanvas.height/2;
  const fx = Math.round((x - cx) * size / specCanvas.width);
  const fy = Math.round((y - cy) * size / specCanvas.height);
  const mode = document.querySelector('input[name="mode"]:checked').value;
  if (mode !== 'notch') return;
  // toggle near point
  let found = -1;
  for (let i=0;i<notchPoints.length;i++){
    const p = notchPoints[i];
    if (Math.hypot(p[0]-fx, p[1]-fy) < 8) { found = i; break; }
  }
  if (found >= 0) notchPoints.splice(found,1);
  else notchPoints.push([fx, fy]);
  renderSpectrum();
});

/* ---------- WebGL preview (render texture fast) ---------- */

const outCanvas = document.getElementById('out');
outCanvas.width = outCanvas.clientWidth || 800;
outCanvas.height = outCanvas.clientHeight || 600;
const gl = outCanvas.getContext('webgl2', {antialias:false});
if (!gl) {
  document.getElementById('overlay').textContent = 'WebGL2 required';
  throw new Error('WebGL2 required');
}

const vs = `#version 300 es
in vec2 aPos;
out vec2 vUV;
void main(){ vUV = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.0,1.0); }`;
const fs = `#version 300 es
precision highp float;
in vec2 vUV;
uniform sampler2D uTex;
out vec4 outColor;
void main(){
  vec3 c = texture(uTex, vUV).rgb;
  outColor = vec4(c,1.0);
}`;
function createShader(type, src){ const s = gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s; }
const prog = gl.createProgram();
gl.attachShader(prog, createShader(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw gl.getProgramInfoLog(prog);
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

gl.useProgram(prog);
gl.uniform1i(gl.getUniformLocation(prog, 'uTex'), 0);

/* ---------- Convert frequency-domain back to pixels & upload to GPU ---------- */

function computeAndRender(){
  // forward
  forwardFFT_andShift();
  // create mask and apply
  const mask = buildMask();
  applyMask(mask);
  // spectrum visualization uses current real/imag
  renderSpectrum();
  // inverse
  inverseShift_andIFFT();
  // now realBuf holds spatial-domain luminance (floating)
  // build RGBA Uint8 image and upload to GL texture
  const N = size;
  const mix = parseFloat(document.getElementById('mix').value)/100;
  const img = new Uint8ClampedArray(N*N*4);
  for (let i=0;i<N*N;i++){
    let v = realBuf[i];
    // clamp
    v = Math.min(255, Math.max(0, v));
    // optionally mix with original spatial luminance (we took original before FFT)
    // Reconstruct mix: original luminance was stored at origReal (we want to keep it)
    // For simplicity, we kept original in a temporary by recomputing forward earlier -- let's keep a snapshot
  }
  // We need original spatial image data to mix. Easiest: recompute original by inverse-transforming a copy.
  // Instead, for simplicity: we will map v to rgb and not mix. (mix slider will be implemented on CPU using stored origLum)
  // Let's compute origLum snapshot from the FFT input prior to forward (we saved nothing). To support mix we will:
  // - store origLum before forward when starting computeAndRender.
  // To keep code simple: call computeAndRenderMix which preserves original.
  computeAndRenderMix();
}

let origLumSnapshot = null;
function computeAndRenderMix(){
  // snapshot current spatial data before forward (we have it in realBuf only at start; but computeAndRender already replaced it)
  // To correct flow, we need: keep a copy of original spatial luminance -> forward -> masked -> inverse -> result -> mix orig & result
  // Implement properly:
  // Recreate original by re-sampling origImage into origLumSnapshot if available:
  if (origImage){
    // sample again at current size to get original luminance
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const ctx = c.getContext('2d');
    const img = origImage;
    const ar = img.width / img.height;
    if (ar > 1){
      const h = img.height;
      const w = h;
      const sx = (img.width - w)/2;
      ctx.drawImage(img, sx, 0, w, h, 0, 0, size, size);
    } else {
      const w = img.width;
      const h = w;
      const sy = (img.height - h)/2;
      ctx.drawImage(img, 0, sy, w, h, 0, 0, size, size);
    }
    const id = ctx.getImageData(0,0,size,size).data;
    origLumSnapshot = new Float32Array(size*size);
    for (let i=0;i<size*size;i++){
      const di = i*4;
      origLumSnapshot[i] = 0.299*id[di] + 0.587*id[di+1] + 0.114*id[di+2];
    }
  } else {
    // if no origImage (noise), snapshot equals current realBuf (already was original)
    origLumSnapshot = new Float32Array(size*size);
    for (let i=0;i<size*size;i++) origLumSnapshot[i] = realBuf[i];
  }

  // Save a copy of the original frequency buffers for later mixing
  const savedReal = realBuf.slice();
  const savedImag = imagBuf.slice();

  // forward -> mask -> inverse (we already did that earlier; to be safe recompute)
  fft2d(realBuf, imagBuf, size, false);
  fftShiftInPlace(realBuf, imagBuf, size);
  const mask = buildMask();
  applyMask(mask);
  fftShiftInPlace(realBuf, imagBuf, size);
  fft2d(realBuf, imagBuf, size, true);

  // now realBuf contains filtered spatial luminance
  const mix = parseFloat(document.getElementById('mix').value)/100;
  const N = size;
  const rgba = new Uint8Array(N*N*4);
  for (let i=0;i<N*N;i++){
    let filtered = realBuf[i];
    let orig = origLumSnapshot ? origLumSnapshot[i] : filtered;
    let outv = filtered * mix + orig * (1 - mix);
    outv = Math.min(255, Math.max(0, outv));
    const v = Math.round(outv);
    rgba[i*4+0] = v;
    rgba[i*4+1] = v;
    rgba[i*4+2] = v;
    rgba[i*4+3] = 255;
  }

  // upload to GL texture and draw
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, N, N, 0, gl.RGBA, gl.UNSIGNED_BYTE, rgba);

  // resize canvas display to preserve aspect and fit container
  fitCanvasToContainer();

  gl.viewport(0,0, outCanvas.width, outCanvas.height);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  renderSpectrum();
}

/* ---------- UI bindings and helpers ---------- */

document.getElementById('radius').addEventListener('input', (e)=>{ document.getElementById('radiusVal').value = e.target.value; });
document.getElementById('width').addEventListener('input', (e)=>{ document.getElementById('widthVal').value = e.target.value; });
document.getElementById('mix').addEventListener('input', (e)=>{ document.getElementById('mixVal').value = e.target.value; });

document.getElementById('radiusVal').value = document.getElementById('radius').value;
document.getElementById('widthVal').value = document.getElementById('width').value;
document.getElementById('mixVal').value = document.getElementById('mix').value;

document.getElementById('btnApply').addEventListener('click', ()=>{ computeAndRender(); });
document.getElementById('btnAuto').addEventListener('click', ()=>{
  // ensure forward computed
  fft2d(realBuf, imagBuf, size, false);
  fftShiftInPlace(realBuf, imagBuf, size);
  const peaks = autoDetectPeaks();
  notchPoints = peaks;
  renderSpectrum();
});
document.getElementById('btnDownload').addEventListener('click', ()=>{
  // read pixels back from GL
  const N = size;
  const buf = new Uint8Array(N*N*4);
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  const tempTex = tex;
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTex, 0);
  gl.readPixels(0,0,N,N,gl.RGBA, gl.UNSIGNED_BYTE, buf);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  // create canvas
  const c = document.createElement('canvas');
  c.width = N; c.height = N;
  const ctx = c.getContext('2d');
  const id = ctx.createImageData(N,N);
  id.data.set(buf);
  ctx.putImageData(id,0,0);
  c.toBlob(b=>{
    const url = URL.createObjectURL(b);
    const a = document.createElement('a');
    a.href = url; a.download = 'fft-filtered.png'; a.click();
    URL.revokeObjectURL(url);
  }, 'image/png');
});

/* Basic responsive handling */
function fitCanvasToContainer(){
  const container = document.querySelector('.large-canvas');
  const rect = container.getBoundingClientRect();
  outCanvas.width = Math.max(64, Math.floor(rect.width));
  outCanvas.height = Math.max(64, Math.floor(rect.height));
}

/* initialize with noise */
generateNoise();
fitCanvasToContainer();
window.addEventListener('resize', ()=>{ fitCanvasToContainer(); gl.viewport(0,0,outCanvas.width, outCanvas.height); });

/* Small UX: keyboard shortcuts */
window.addEventListener('keydown', (e)=>{
  if (e.key === ' ') { computeAndRender(); e.preventDefault(); }
});

</script>
</body>
</html>
