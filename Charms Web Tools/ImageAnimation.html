<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Sort Animator</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; color:#111; background:#f7f7f8; }
  header { margin-bottom:12px; }
  label { display:inline-block; margin-right:8px; font-weight:600; }
  input[type="range"] { width:200px; vertical-align:middle; }
  canvas { display:block; margin-top:12px; border:1px solid #ddd; background:#000; max-width:100%; height:auto; }
  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .small { font-size:0.9rem; color:#444; }
  button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:#fff; cursor:pointer; }
  button:active { transform:translateY(1px); }
  .status { margin-top:8px; color:#333; }
  .note { margin-top:8px; color:#666; font-size:0.9rem; }
</style>
</head>
<body>
<header>
  <h3>Pixel Sort Animator</h3>
  <div class="controls">
    <label for="file">Choose Image</label>
    <input id="file" type="file" accept="image/*" />
    <label class="small">Duration</label>
    <input id="duration" type="range" min="200" max="8000" value="2000" />
    <span id="durationVal" class="small">2000 ms</span>
    <label class="small">Sampling</label>
    <input id="sampling" type="range" min="1" max="16" value="1" />
    <span id="samplingVal" class="small">1</span>
    <button id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
  </div>
  <div class="status" id="status">No image loaded</div>
  <div class="note">Sampling 1 uses every pixel. Increase sampling to reduce particle count for performance.</div>
</header>

<canvas id="canvas"></canvas>

<script>
/* Pixel Sort Animator
   - No hard-coded image size limits
   - Sampling control to reduce particle count if needed
   - Sort by brightness and animate pixels back to original positions
*/

const fileInput = document.getElementById('file');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const durationRange = document.getElementById('duration');
const durationVal = document.getElementById('durationVal');
const samplingRange = document.getElementById('sampling');
const samplingVal = document.getElementById('samplingVal');
const status = document.getElementById('status');

let img = new Image();
let particles = []; // {sx,sy,tx,ty,r,g,b,a}
let width = 0, height = 0;
let animationId = null;
let startTime = null;
let paused = false;
let pauseTime = 0;
let duration = parseInt(durationRange.value, 10);
let sampling = parseInt(samplingRange.value, 10);
let originalImageData = null;

durationRange.addEventListener('input', () => {
  duration = parseInt(durationRange.value, 10);
  durationVal.textContent = duration + ' ms';
});
samplingRange.addEventListener('input', () => {
  sampling = parseInt(samplingRange.value, 10);
  samplingVal.textContent = sampling;
});

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = () => {
    URL.revokeObjectURL(url);
    setupCanvasForImage(img);
    status.textContent = `Loaded ${f.name} â€” ${img.width} x ${img.height}`;
  };
  img.onerror = () => {
    status.textContent = 'Failed to load image';
  };
  img.src = url;
});

function setupCanvasForImage(image) {
  // Use natural image size for canvas to avoid restricting image size
  width = image.naturalWidth;
  height = image.naturalHeight;
  canvas.width = width;
  canvas.height = height;
  // Draw image to canvas
  ctx.clearRect(0,0,width,height);
  ctx.drawImage(image, 0, 0, width, height);
  // Save original image data
  originalImageData = ctx.getImageData(0,0,width,height);
  // Prepare particles
  prepareParticles();
  // Render initial sorted state
  renderFrame(0); // show sorted start
}

function prepareParticles() {
  particles = [];
  if (!originalImageData) return;
  const data = originalImageData.data;
  // Build array of pixel objects
  // We'll sample every 'sampling' pixels in both x and y
  for (let y = 0; y < height; y += sampling) {
    for (let x = 0; x < width; x += sampling) {
      const idx = (y * width + x) * 4;
      const r = data[idx], g = data[idx+1], b = data[idx+2], a = data[idx+3];
      // compute brightness
      const brightness = 0.299*r + 0.587*g + 0.114*b;
      particles.push({ x, y, r, g, b, a, brightness });
    }
  }
  // Sort copy by brightness
  const sorted = particles.slice().sort((a,b) => a.brightness - b.brightness);
  // Assign start positions as grid positions in the same canvas size
  // We'll map sorted index to grid coordinates using sampling steps
  const cols = Math.ceil(width / sampling);
  // For each sorted pixel, set start positions
  for (let i = 0; i < sorted.length; i++) {
    const sx = (i % cols) * sampling;
    const sy = Math.floor(i / cols) * sampling;
    sorted[i].sx = sx;
    sorted[i].sy = sy;
  }
  // Now map sorted start positions back to original pixels as particles with target positions
  // We'll create final particle list where each particle has start (sx,sy) and target (x,y) and color
  const final = [];
  // We need to pair each original pixel with one sorted start slot.
  // Use the sorted array order to assign start positions to original pixels in the same index order as particles
  // That means particles[i] will get start from sorted[i]
  for (let i = 0; i < particles.length; i++) {
    const orig = particles[i];
    const s = sorted[i];
    final.push({
      sx: s.sx, sy: s.sy,
      tx: orig.x, ty: orig.y,
      r: orig.r, g: orig.g, b: orig.b, a: orig.a
    });
  }
  particles = final;
}

function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

function renderFrame(progress) {
  // progress 0..1
  // Create a blank ImageData and set pixels at interpolated positions
  const out = ctx.createImageData(width, height);
  const outData = out.data;
  // Fill with transparent black
  // For each particle compute current position
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    const t = easeOutCubic(progress);
    const cx = p.sx + (p.tx - p.sx) * t;
    const cy = p.sy + (p.ty - p.sy) * t;
    // Round to nearest pixel
    const rx = Math.round(cx);
    const ry = Math.round(cy);
    if (rx < 0 || rx >= width || ry < 0 || ry >= height) continue;
    const idx = (ry * width + rx) * 4;
    outData[idx] = p.r;
    outData[idx+1] = p.g;
    outData[idx+2] = p.b;
    outData[idx+3] = p.a;
  }
  ctx.putImageData(out, 0, 0);
}

function animateStart() {
  if (!particles || particles.length === 0) {
    status.textContent = 'No image loaded or no particles prepared';
    return;
  }
  cancelAnimationFrame(animationId);
  startTime = performance.now();
  paused = false;
  pauseTime = 0;
  status.textContent = `Animating ${particles.length} pixels`;
  function frame(now) {
    if (paused) {
      animationId = requestAnimationFrame(frame);
      return;
    }
    const elapsed = now - startTime - pauseTime;
    const prog = Math.min(1, elapsed / duration);
    renderFrame(prog);
    if (prog < 1) {
      animationId = requestAnimationFrame(frame);
    } else {
      status.textContent = `Animation complete (${particles.length} pixels)`;
      animationId = null;
    }
  }
  animationId = requestAnimationFrame(frame);
}

startBtn.addEventListener('click', () => {
  if (!originalImageData) {
    status.textContent = 'Please load an image first';
    return;
  }
  // Re-prepare particles in case sampling changed
  prepareParticles();
  // Reset canvas to sorted start state
  renderFrame(0);
  animateStart();
});

pauseBtn.addEventListener('click', () => {
  if (!startTime) return;
  paused = !paused;
  if (paused) {
    pauseBtn.textContent = 'Resume';
    // record pause start
    pauseStart = performance.now();
    status.textContent = 'Paused';
  } else {
    pauseBtn.textContent = 'Pause';
    // accumulate pause time
    pauseTime += performance.now() - (pauseStart || performance.now());
    status.textContent = 'Resumed';
  }
});

resetBtn.addEventListener('click', () => {
  cancelAnimationFrame(animationId);
  animationId = null;
  startTime = null;
  paused = false;
  pauseTime = 0;
  pauseBtn.textContent = 'Pause';
  if (originalImageData) {
    // draw original image
    ctx.putImageData(originalImageData, 0, 0);
    status.textContent = 'Reset to original image';
  } else {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    status.textContent = 'No image loaded';
  }
});

// On load, show a small placeholder
ctx.fillStyle = '#222';
ctx.fillRect(0,0,600,300);
ctx.fillStyle = '#fff';
ctx.font = '16px system-ui, -apple-system, "Segoe UI", Roboto';
ctx.fillText('Choose an image to begin', 12, 24);

</script>
</body>
</html>

