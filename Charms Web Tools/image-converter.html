<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal File Converter (Advanced)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* Custom styles to enforce BORDERLESS, MINIMAL, and B&W */
        /* REMOVED: * { transition: all 1.0s ease-in-out; } */
        
        /* --- EXPLICIT TRANSITIONS FOR SMOOTH MODE SWITCH (1.0s) --- */
        body, .container,
        input[type="checkbox"], 
        .drop-zone, 
        .message-box.info, .message-box.success, .message-box.error,
        .file-list-item, 
        .file-format-select,
        .global-controls-border, #folder-export-controls,
        .btn-primary, .btn-secondary {
            /* Applied the slow transition specifically to the color/border properties */
            transition: background-color 1.0s ease-in-out, color 1.0s ease-in-out, border-color 1.0s ease-in-out, outline-color 1.0s ease-in-out;
        }

        /* Speed up interactions like hover/dragover to keep the site responsive */
        .drop-zone {
            /* Override transition for hover/dragover effects to be quick (0.1s) */
            transition: background-color 0.1s, color 0.1s, border-color 1.0s, outline-color 1.0s; 
        }

        .drop-zone:hover, .btn-primary:hover, .btn-secondary:hover {
            /* Keep hover transition fast */
            transition: transform 0.15s, background-color 0.1s, color 0.1s, outline 0.1s;
        }
        /* ----------------------------------------------------------- */


        /* --- START DARK MODE DEFAULT STYLES (Default Background: Black, Text: White) --- */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; 
            color: #ffffff; 
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 0; 
            margin: 0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 95%; 
            width: 1200px; 
            background-color: #000000; 
            padding: 1rem; 
        }
        
        /* Checkbox styling relies on CSS for strict B&W outlines */
        input[type="checkbox"] {
            outline: 1px solid #ffffff; /* Dark Mode Outline: ffffff */
            border: none;
        }
        
        /* BORDERS and LINES - Strict #FFFFFF in Dark Mode */
        .drop-zone, .file-list-item, .global-controls-border, #folder-export-controls {
            border-color: #ffffff !important;
        }
        
        .drop-zone {
            border: 1px solid #ffffff; 
            background-color: #000000; 
            cursor: pointer;
            padding: 2rem 0; 
            text-align: center;
        }

        /* Drop Zone interaction effects */
        .drop-zone:hover {
            transform: scale(1.01); 
        }

        .drop-zone.dragover {
            background-color: #ffffff !important; 
            color: #000000 !important;
        }

        .message-box.info, .message-box.success, .message-box.error {
            background-color: #000000 !important; 
            color: #ffffff !important; 
            font-weight: bold;
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            text-decoration: underline; 
        }
        
        /* Minimal file list item styling */
        .file-list-item {
            border-bottom: 1px solid #ffffff; 
            opacity: 1; 
            transform: translateX(0);
        }

        /* Button hover styles for B&W - INVERTED for Dark Mode */
        .btn-primary:hover {
            background-color: #000000 !important; 
            color: #ffffff !important;
            outline: 1px solid #ffffff;
            transform: scale(1.05);
        }
        
        .btn-secondary {
            background-color: #000000; 
            color: #ffffff;
            outline: 1px solid #ffffff;
        }
        
        .btn-secondary:hover {
            background-color: #ffffff !important; 
            color: #000000 !important;
            outline: none;
            transform: scale(1.05);
        }
        
        /* Dropdown/Select styling */
        .file-format-select {
            color: #ffffff; 
            background-color: #000000; 
            border: none;
            outline: 1px solid #ffffff; 
            padding: 0.25rem 0.5rem; 
            font-size: 0.75rem; 
        }
        
        /* Global controls border */
        .global-controls-border {
            border-bottom: 1px solid #ffffff; 
            padding-bottom: 0.5rem;
            padding-top: 0.5rem;
        }

        /* Style for the folder export control block */
        #folder-export-controls {
            border-bottom: 1px solid #ffffff; 
            padding-bottom: 0.5rem;
            padding-top: 0.5rem;
        }
        
        /* --- END DARK MODE DEFAULT STYLES --- */


        /* --- START LIGHT MODE (OLD DEFAULT) OVERRIDES (Background: White, Text: Black) --- */
        body.light-mode {
            background-color: #ffffff;
            color: #000000;
        }
        body.light-mode .container {
            background-color: #ffffff;
        }
        
        /* Checkbox styling for strict B&W outlines */
        body.light-mode input[type="checkbox"] {
            outline: 1px solid #000000; /* Light Mode Outline: 000000 */
        }

        /* BORDERS and LINES - Strict #000000 in Light Mode */
        body.light-mode .drop-zone, body.light-mode .file-list-item, body.light-mode .global-controls-border, body.light-mode #folder-export-controls {
             border-color: #000000 !important;
        }
        
        body.light-mode .drop-zone {
            border: 1px solid #000000;
            background-color: #ffffff;
        }
        body.light-mode .drop-zone.dragover {
            background-color: #000000 !important;
            color: #ffffff !important;
        }
        body.light-mode .message-box.info, body.light-mode .message-box.success, body.light-mode .message-box.error {
            background-color: #ffffff !important;
            color: #000000 !important;
        }
        body.light-mode .file-list-item {
            border-bottom: 1px solid #000000;
        }
        body.light-mode .btn-primary:hover {
            background-color: #ffffff !important; 
            color: #000000 !important;
            outline: 1px solid #000000;
        }
        body.light-mode .btn-secondary {
            background-color: #ffffff; 
            color: #000000;
            outline: 1px solid #000000;
        }
        body.light-mode .btn-secondary:hover {
            background-color: #000000 !important; 
            color: #ffffff !important;
            outline: none;
        }
        body.light-mode .file-format-select {
            color: #000000;
            background-color: #ffffff;
            outline: 1px solid #000000;
        }
        body.light-mode .global-controls-border {
            border-bottom: 1px solid #000000; 
        }
        body.light-mode #folder-export-controls {
            border-bottom: 1px solid #000000; 
        }
        /* --- END LIGHT MODE OVERRIDES --- */

    </style>
</head>
<body class="bg-black m-0 p-0 text-white"> 
    <div id="main-content" class="container space-y-4 opacity-0 transition-opacity duration-500 ease-in">
        <header class="text-center">
            <h1 class="text-3xl font-bold mb-0">Multi-File Converter</h1> 
            <p class="text-sm mt-1 mb-2">Drag & drop **files or folders** or **click to select files** to convert.</p>
        </header>

        <div class="flex items-center justify-end space-x-2 pb-2">
            <input type="checkbox" id="mode-toggle-checkbox"> 
            <label for="mode-toggle-checkbox" class="text-sm font-semibold">Light Mode</label>
        </div>
        
        <input type="file" id="hidden-file-input" multiple class="hidden"> 
        <div id="drop-zone" class="drop-zone p-4 text-center cursor-pointer">
            <p class="font-semibold">Click or Drag & Drop Files/Folders Here</p>
            <p class="text-xs">(.jpg, .png, .gif, and any other file types will be preserved)</p>
        </div>

        <div class="flex items-center justify-end space-x-2 pt-2">
            <button id="convert-btn" class="btn-secondary font-semibold p-2 transition duration-150" disabled>
                Convert All Selected
            </button>
            <button id="export-zip-btn" class="btn-primary bg-white text-black font-semibold p-2 transition duration-150" disabled>
                Export ZIP Archive
            </button>
        </div>
        
        <div id="global-controls" class="global-controls-border flex items-center justify-between pt-4 pb-2"> 
            <div class="flex items-center space-x-2 text-sm font-semibold">
                <input type="checkbox" id="select-all-checkbox" disabled>
                <label for="select-all-checkbox">Select/Deselect All Images for Conversion</label>
            </div>
            
            <div class="flex items-center space-x-2 text-sm font-medium">
                <label for="global-format-select">Convert All Images To:</label>
                <select id="global-format-select" class="file-format-select" disabled>
                    </select>
            </div>
        </div>
        
        <div id="folder-export-controls" class="space-y-2 hidden">
            <h3 class="text-sm font-bold pt-1">Folder Export Options:</h3> 
            <div class="flex flex-col space-y-1 text-xs">
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="include-non-image-files" checked> 
                    <label for="include-non-image-files">Include non-image files (PDFs, TXT, etc.) in the final ZIP?</label>
                </div>
                
                <div id="preserve-structure-option" class="flex items-center space-x-2 pl-4 hidden"> 
                    <input type="checkbox" id="preserve-non-image-structure"> 
                    <label for="preserve-non-image-structure">Preserve the folder structure for excluded non-image files?</label>
                </div>
            </div>
        </div>
        <h2 class="text-xl font-bold pt-4 mb-2">Files Added (<span id="file-count">0</span>)</h2> 
        <div id="message-container" class="space-y-1">
            </div>
        <ul id="file-list" class="space-y-1">
            </ul>
        
        <div class="pt-4 flex justify-center">
            <button id="clear-all-btn" class="btn-secondary font-semibold p-2 transition duration-150 text-sm" disabled>
                Clear All Files
            </button>
        </div>
    </div>

    <script>
        // Global variables
        const filesToProcess = []; 
        let conversionRunning = false;
        let isFolderUpload = false;
        let includeNonImageFiles = true; 
        let preserveEmptyNonImageStructure = false;
        
        // Element references
        const mainContent = document.getElementById('main-content');
        const dropZone = document.getElementById('drop-zone');
        const hiddenFileInput = document.getElementById('hidden-file-input');
        const fileList = document.getElementById('file-list');
        const convertBtn = document.getElementById('convert-btn');
        const exportZipBtn = document.getElementById('export-zip-btn');
        const fileCountSpan = document.getElementById('file-count');
        const messageContainer = document.getElementById('message-container');
        const clearAllBtn = document.getElementById('clear-all-btn');
        const selectAllCheckbox = document.getElementById('select-all-checkbox');
        const globalFormatSelect = document.getElementById('global-format-select');
        
        // NEW ELEMENT REFERENCES (Dark Mode Toggle) 
        const modeToggleCheckbox = document.getElementById('mode-toggle-checkbox');
        
        // NEW ELEMENT REFERENCES (Folder Controls)
        const folderExportControls = document.getElementById('folder-export-controls');
        const includeNonImageFilesCheckbox = document.getElementById('include-non-image-files');
        const preserveStructureOptionDiv = document.getElementById('preserve-structure-option');
        const preserveNonImageStructureCheckbox = document.getElementById('preserve-non-image-structure');

        const IMAGE_MIMES = ['image/jpeg', 'image/png', 'image/webp'];
        const IMAGE_MIME_MAP = {
            'image/jpeg': 'jpg',
            'image/png': 'png',
            'image/webp': 'webp'
        };
        
        // --- Download Function ---

        function downloadSingleFile(index) {
            const item = filesToProcess[index];
            if (item && item.convertedBlob) {
                const filename = item.relativePath.split('/').pop();
                
                const url = URL.createObjectURL(item.convertedBlob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename; 
                
                a.click();
                
                URL.revokeObjectURL(url);
                
                showGeneralMessage(`Downloaded file: ${filename}`, 'success');
            } else {
                showGeneralMessage('File not converted or already downloaded.', 'error');
            }
        }

        // --- Global Control Functions ---
        
        function selectAllConversions(checked) {
            filesToProcess.forEach(item => {
                if (item.isImage) {
                    item.shouldConvert = checked;
                    item.conversionStatus = checked ? 'Pending' : 'Skipped';
                    
                    const index = filesToProcess.indexOf(item);
                    const checkbox = document.getElementById(`checkbox-${index}`);
                    const select = document.getElementById(`select-${index}`);
                    const statusText = document.getElementById(`status-text-${index}`);

                    if (checkbox) {
                        checkbox.checked = checked;
                        select.disabled = !checked;
                    }
                    if (statusText) {
                        statusText.textContent = `(${item.conversionStatus})`;
                    }
                }
            });
            updateControls();
        }

        function setAllTargetFormats(mimeType) {
            filesToProcess.forEach(item => {
                if (item.isImage) {
                    item.targetMimeType = mimeType;
                    item.conversionStatus = 'Pending';
                    item.convertedBlob = null;
                    
                    const index = filesToProcess.indexOf(item);
                    const select = document.getElementById(`select-${index}`);
                    const statusText = document.getElementById(`status-text-${index}`);

                    if (select) {
                        select.value = mimeType;
                    }
                    if (statusText) {
                        statusText.textContent = '(Pending)';
                    }
                }
            });
            updateControls();
        }
        
        function populateGlobalFormatSelector() {
            Object.keys(IMAGE_MIME_MAP).forEach(mime => {
                const option = document.createElement('option');
                option.value = mime;
                option.textContent = IMAGE_MIME_MAP[mime].toUpperCase();
                globalFormatSelect.appendChild(option);
            });
            globalFormatSelect.value = 'image/png';
        }

        function updateSelectAllCheckbox() {
            const imageFiles = filesToProcess.filter(f => f.isImage);
            const checkedImages = imageFiles.filter(f => f.shouldConvert);

            if (imageFiles.length > 0) {
                selectAllCheckbox.disabled = false;
                selectAllCheckbox.checked = (checkedImages.length === imageFiles.length);
                selectAllCheckbox.indeterminate = (checkedImages.length > 0 && checkedImages.length < imageFiles.length);
            } else {
                selectAllCheckbox.disabled = true;
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
        }

        // --- Core Functions ---

        function isConvertableImage(mimeType) {
            return mimeType.startsWith('image/');
        }

        function showGeneralMessage(message, type = 'info') {
            const messageBox = document.createElement('div');
            // Message box style updated to match the Dark Mode default
            messageBox.className = `message-box ${type} text-sm bg-black p-1 mb-1`; 
            messageBox.setAttribute('data-message-type', type);
            messageBox.textContent = message;
            
            if (messageContainer.children.length >= 3) {
                messageContainer.removeChild(messageContainer.children[0]);
            }
            messageContainer.appendChild(messageBox);
        }
        
        function updateControls() {
            const hasFiles = filesToProcess.length > 0;
            const hasImages = filesToProcess.some(f => f.isImage);
            
            // Get the current mode for styling buttons dynamically
            const isLightMode = document.body.classList.contains('light-mode');
            const primaryBtnBase = isLightMode ? 'bg-black text-white' : 'bg-white text-black';
            const secondaryBtnBase = isLightMode ? 'bg-white text-black' : 'bg-black text-white';

            fileCountSpan.textContent = filesToProcess.length;
            
            const hasImagesToConvert = filesToProcess.some(f => f.isImage && f.shouldConvert);
            convertBtn.disabled = !hasImagesToConvert || conversionRunning;
            
            const hasConvertedBlobs = filesToProcess.some(f => f.convertedBlob || (f.file && !f.shouldConvert));
            exportZipBtn.disabled = conversionRunning || !hasConvertedBlobs;

            clearAllBtn.disabled = !hasFiles;
            
            // --- Global Control Updates ---
            globalFormatSelect.disabled = !hasImages;
            document.getElementById('global-controls').classList.toggle('opacity-50', !hasImages);
            updateSelectAllCheckbox(); 
            
            // --- Folder Control Visibility Logic ---
            if (isFolderUpload) {
                folderExportControls.classList.remove('hidden');
            } else {
                folderExportControls.classList.add('hidden');
            }
            
            // Show the structure preservation option ONLY if non-image files are being excluded
            if (!includeNonImageFiles) {
                preserveStructureOptionDiv.classList.remove('hidden');
            } else {
                preserveStructureOptionDiv.classList.add('hidden');
            }
            // ------------------------------------------

            // Update button styling (B&W minimal)
            convertBtn.className = `btn-secondary font-semibold p-2 transition duration-150 ${convertBtn.disabled ? 'opacity-50 cursor-not-allowed' : secondaryBtnBase}`;
            exportZipBtn.className = `btn-primary font-semibold p-2 transition duration-150 ${exportZipBtn.disabled ? 'opacity-50 cursor-not-allowed' : primaryBtnBase}`;
            clearAllBtn.className = `btn-secondary font-semibold p-2 transition duration-150 text-sm ${clearAllBtn.disabled ? 'opacity-50 cursor-not-allowed' : secondaryBtnBase}`;
        }

        function addFileEntry(file, relativePath) {
            const isDuplicate = filesToProcess.some(f => f.relativePath === relativePath);
            if (isDuplicate) {
                return;
            }
            
            const isImage = isConvertableImage(file.type);
            const initialTargetMime = isImage ? globalFormatSelect.value : 'N/A';
            const shouldConvertInitially = isImage ? selectAllCheckbox.checked : false;

            filesToProcess.push({
                file: file,
                relativePath: relativePath, 
                isImage: isImage,
                shouldConvert: shouldConvertInitially,
                targetMimeType: initialTargetMime, 
                convertedBlob: null,
                conversionStatus: shouldConvertInitially ? 'Pending' : (isImage ? 'Skipped' : 'N/A'),
                originalName: file.name
            });
            
            // Detect if this file path suggests a folder upload
            if (relativePath && relativePath.includes('/')) {
                isFolderUpload = true;
            }
        }

        function processDirectory(entry) {
            isFolderUpload = true; 
            return new Promise((resolve, reject) => {
                const reader = entry.createReader();
                const entries = [];

                function readEntries() {
                    reader.readEntries(async (results) => {
                        if (!results.length) {
                            resolve(entries);
                        } else {
                            entries.push(...results);
                            await processResults(results);
                            readEntries(); 
                        }
                    }, reject);
                }

                async function processResults(results) {
                    for (const item of results) {
                        if (item.isFile) {
                            await new Promise((fileResolve) => {
                                item.file(f => {
                                    addFileEntry(f, item.fullPath.substring(1)); 
                                    fileResolve();
                                });
                            });
                        } else if (item.isDirectory) {
                            await processDirectory(item);
                        }
                    }
                }

                readEntries();
            });
        }

        function handleFiles(dataTransferItems) {
            isFolderUpload = false;
            
            const items = Array.from(dataTransferItems);
            let totalFilesFound = 0;

            items.forEach(item => {
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    if (entry.isFile) {
                        item.getAsFile(file => {
                            if (file) {
                                addFileEntry(file, file.name); 
                                totalFilesFound++;
                                renderFileList();
                            }
                        });
                    } else if (entry.isDirectory) {
                        showGeneralMessage(`Processing folder: ${entry.name}...`, 'info');
                        processDirectory(entry).then(() => {
                            showGeneralMessage(`Folder processing complete: ${entry.name}`, 'success');
                            renderFileList();
                        }).catch(error => {
                            showGeneralMessage(`Error reading folder: ${error.message}`, 'error');
                            updateControls();
                        });
                    }
                } else if (item.kind === 'file') {
                     item.getAsFile(file => {
                        if (file) {
                             const path = file.webkitRelativePath || file.name;
                             addFileEntry(file, path); 
                             totalFilesFound++;
                             renderFileList();
                        }
                     });
                }
            });
            
            if (totalFilesFound > 0) {
                 renderFileList();
            }
        }

        function renderFileList() {
            const existingFilePaths = Array.from(fileList.children).map(li => li.getAttribute('data-relative-path'));
            
            fileList.innerHTML = '';
            
            // Get the current mode for styling status text dynamically
            const isLightMode = document.body.classList.contains('light-mode');
            const primaryBtnBase = isLightMode ? 'bg-black text-white' : 'bg-white text-black';
            const secondaryBtnBase = isLightMode ? 'bg-white text-black' : 'bg-black text-white';

            filesToProcess.forEach((item, index) => {
                const listItem = document.createElement('li');
                listItem.id = `file-item-${index}`;
                listItem.setAttribute('data-relative-path', item.relativePath);

                // listItem inherits color and background from body/container
                listItem.className = 'file-list-item grid grid-cols-12 gap-2 items-center text-sm transition duration-150'; 

                const isNew = !existingFilePaths.includes(item.relativePath);
                if (isNew) {
                    listItem.classList.add('file-list-enter'); 
                }

                // --- 1. File Path (Col 1-7) ---
                const pathDisplay = document.createElement('div');
                pathDisplay.className = 'col-span-7 font-medium overflow-hidden whitespace-nowrap text-ellipsis';
                pathDisplay.textContent = item.relativePath;

                // --- 2. Format Selector (Col 8-10) ---
                const formatControl = document.createElement('div');
                formatControl.className = 'col-span-3 flex items-center justify-end space-x-2';
                
                if (item.isImage) {
                    const select = document.createElement('select');
                    select.id = `select-${index}`;
                    select.className = 'file-format-select';
                    select.style.minWidth = '80px'; 

                    Object.keys(IMAGE_MIME_MAP).forEach(mime => {
                        const option = document.createElement('option');
                        option.value = mime;
                        option.textContent = IMAGE_MIME_MAP[mime].toUpperCase();
                        select.appendChild(option);
                    });
                    
                    select.value = item.targetMimeType;
                    select.disabled = !item.shouldConvert; 

                    select.addEventListener('change', (e) => {
                        item.targetMimeType = e.target.value;
                        item.conversionStatus = 'Pending'; 
                        item.convertedBlob = null;
                        document.getElementById(`status-text-${index}`).textContent = '(Pending)';
                        updateControls();
                    });
                    
                    // Toggle checkbox for conversion
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'flex items-center space-x-1';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = item.shouldConvert;
                    checkbox.id = `checkbox-${index}`;
                    checkbox.addEventListener('change', (e) => {
                        item.shouldConvert = e.target.checked;
                        select.disabled = !item.shouldConvert;
                        if (!item.shouldConvert) {
                           item.conversionStatus = 'Skipped';
                           item.convertedBlob = null;
                        } else {
                           item.conversionStatus = 'Pending';
                        }
                        document.getElementById(`status-text-${index}`).textContent = `(${item.conversionStatus})`;
                        updateControls();
                    });
                    const label = document.createElement('label');
                    label.htmlFor = `checkbox-${index}`;
                    label.textContent = 'Convert';
                    label.className = 'text-xs';

                    formatControl.appendChild(checkboxDiv);
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    formatControl.appendChild(select);
                } else {
                    formatControl.textContent = 'File will be preserved';
                    formatControl.className = 'col-span-3 text-xs italic text-right';
                }
                
                // --- 3. Status and Remove/Download (Col 11-12) ---
                const statusAndRemove = document.createElement('div');
                statusAndRemove.className = 'col-span-2 flex items-center justify-end space-x-1';

                // Status Text
                const statusText = document.createElement('span');
                statusText.id = `status-text-${index}`;
                statusText.className = 'text-xs'; // Let color inherit
                statusText.textContent = `(${item.conversionStatus})`;
                
                // Add conditional status style
                if (item.conversionStatus === 'Success' || item.conversionStatus === 'Error') {
                    statusText.classList.add('font-bold');
                }
                if (item.conversionStatus === 'Error') {
                    statusText.classList.add('underline');
                }

                // Download Button (Only visible if NOT a folder upload AND successful conversion)
                if (!isFolderUpload && item.conversionStatus === 'Success' && item.isImage) {
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download';
                    downloadBtn.className = `btn-primary ${primaryBtnBase} text-xs p-1`; 
                    downloadBtn.onclick = () => downloadSingleFile(index);
                    statusAndRemove.appendChild(downloadBtn);
                }

                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.className = `btn-secondary ${secondaryBtnBase} text-xs p-1 ml-4`; 
                removeBtn.onclick = () => removeFile(index);

                statusAndRemove.appendChild(statusText);
                statusAndRemove.appendChild(removeBtn);


                // Assemble the list item
                listItem.appendChild(pathDisplay);
                listItem.appendChild(formatControl);
                listItem.appendChild(statusAndRemove);
                fileList.appendChild(listItem);
                
                // Animate entrance
                if (isNew) {
                    setTimeout(() => {
                        listItem.classList.remove('file-list-enter');
                    }, 50);
                }
            });
            updateControls();
        }

        function removeFile(index) {
            const listItem = document.getElementById(`file-item-${index}`);
            if (listItem) {
                listItem.classList.add('opacity-0', 'scale-y-0', 'h-0', 'my-0', 'py-0');
                
                setTimeout(() => {
                    const filePath = filesToProcess[index]?.relativePath || 'file';
                    filesToProcess.splice(index, 1);
                    
                    isFolderUpload = filesToProcess.some(f => f.relativePath.includes('/'));

                    showGeneralMessage(`Removed file: ${filePath}`, 'info');
                    renderFileList();
                }, 400); 
            } else {
                filesToProcess.splice(index, 1);
                isFolderUpload = filesToProcess.some(f => f.relativePath.includes('/'));
                renderFileList();
            }
        }

        function convertFile(file, targetMimeType) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create Blob during conversion.'));
                        }
                    }, targetMimeType, 0.92);
                };
                img.onerror = (e) => {
                    reject(new Error('Failed to load image for conversion.'));
                };
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    reject(new Error('Failed to read file.'));
                };
                reader.readAsDataURL(file);
            });
        }

        // --- Event Handlers for NEW Controls (Folder/Mode) ---
        
        // ADDED DARK/LIGHT MODE TOGGLE HANDLER
        modeToggleCheckbox.addEventListener('change', (e) => {
            const isLightMode = e.target.checked;
            if (isLightMode) {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
            // Re-render controls to apply new button/list item styles
            renderFileList(); 
            updateControls(); 
            
            // FIXED: Removed class-updating logic, now handled by CSS
            document.querySelector('label[for="mode-toggle-checkbox"]').classList.toggle('text-black', isLightMode);
            document.querySelector('label[for="mode-toggle-checkbox"]').classList.toggle('text-white', !isLightMode);
        });


        includeNonImageFilesCheckbox.addEventListener('change', (e) => {
            includeNonImageFiles = e.target.checked;
            updateControls(); // Updates visibility of the secondary checkbox
        });

        preserveNonImageStructureCheckbox.addEventListener('change', (e) => {
            preserveEmptyNonImageStructure = e.target.checked;
        });
        
        // --- Other Event Handlers (Unchanged) ---
        
        selectAllCheckbox.addEventListener('change', (e) => {
            selectAllConversions(e.target.checked);
        });
        
        globalFormatSelect.addEventListener('change', (e) => {
            setAllTargetFormats(e.target.value);
        });


        convertBtn.addEventListener('click', async () => {
            if (conversionRunning) return;

            conversionRunning = true;
            updateControls();
            
            const filesToConvert = filesToProcess.filter(f => f.isImage && f.shouldConvert);
            if (filesToConvert.length === 0) {
                 showGeneralMessage('No images selected for conversion.', 'info');
                 conversionRunning = false;
                 updateControls();
                 return;
            }

            showGeneralMessage(`Starting conversion of ${filesToConvert.length} images...`, 'info');

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < filesToProcess.length; i++) {
                const item = filesToProcess[i];
                const statusElement = document.getElementById(`status-text-${i}`);
                
                if (!item.isImage || !item.shouldConvert) {
                    item.conversionStatus = item.isImage ? 'Skipped' : 'N/A'; 
                    continue; 
                }
                
                item.conversionStatus = 'Converting...';
                statusElement.textContent = '(Converting...)';
                
                const targetExtension = IMAGE_MIME_MAP[item.targetMimeType];
                
                try {
                    const convertedBlob = await convertFile(item.file, item.targetMimeType);
                    
                    item.convertedBlob = convertedBlob;
                    
                    item.relativePath = item.relativePath.replace(/\.[^/.]+$/, "") + '.' + targetExtension;
                    
                    item.conversionStatus = 'Success';
                    successCount++;
                    
                    renderFileList(); 

                } catch (error) {
                    item.conversionStatus = 'Error';
                    item.convertedBlob = null;
                    errorCount++;
                    
                    showGeneralMessage(`Conversion failed for ${item.relativePath}: ${error.message}`, 'error');
                }
            }

            conversionRunning = false;
            updateControls(); 
            showGeneralMessage(`Conversion complete: ${successCount} successful, ${errorCount} failed.`, 'success');
        });

        /**
         * MODIFIED: Creates a ZIP file respecting the new folder export controls.
         */
        exportZipBtn.addEventListener('click', () => {
            const zip = new JSZip();
            const filesToZip = filesToProcess;

            if (filesToZip.length === 0) {
                showGeneralMessage('No files added to the list to export.', 'error');
                return;
            }

            showGeneralMessage('Preparing ZIP file with controlled content and structure...', 'info');

            let filesAddedCount = 0;
            const foldersWithContent = new Set();
            const foldersFromExcludedNonImages = new Set();
            
            // Helper to get parent directory path (e.g., 'path/to/file.txt' -> 'path/to')
            function getParentDirectory(relativePath) {
                const parts = relativePath.split('/');
                if (parts.length > 1) {
                    return parts.slice(0, -1).join('/');
                }
                return ''; // Root directory
            }

            // Helper to add parent directories to a set (e.g., 'a/b/c' -> 'a', 'a/b', 'a/b/c')
            function addParentPaths(relativePath, set) {
                let currentPath = '';
                relativePath.split('/').slice(0, -1).forEach(part => {
                    if (currentPath.length > 0) {
                        currentPath += '/' + part;
                    } else {
                        currentPath = part;
                    }
                    set.add(currentPath);
                });
            }


            filesToZip.forEach(item => {
                let fileBlob = item.file; 
                let pathInZip = item.relativePath;
                let shouldIncludeFile = false;
                
                // 1. Determine inclusion logic
                if (item.isImage) {
                    // Images are always included. Use converted blob if available, otherwise original file.
                    fileBlob = item.convertedBlob || item.file; 
                    shouldIncludeFile = true;
                } else if (!item.isImage) {
                    // Non-images are included only if the toggle is checked.
                    if (includeNonImageFiles) {
                        shouldIncludeFile = true;
                    }
                }
                
                // 2. Add files and track folders with content
                if (shouldIncludeFile) {
                    if (item.isImage && item.shouldConvert && !item.convertedBlob) {
                        showGeneralMessage(`Skipping failed conversion for: ${item.relativePath}`, 'info');
                        return; // Skip this item entirely
                    }
                    
                    zip.file(pathInZip, fileBlob);
                    filesAddedCount++;
                    addParentPaths(pathInZip, foldersWithContent);
                } 
                
                // 3. Track folders that contained EXCLUDED non-images
                if (!item.isImage && !shouldIncludeFile) {
                    addParentPaths(pathInZip, foldersFromExcludedNonImages);
                }
            });

            // 4. Preserve empty structure if requested
            if (isFolderUpload && !includeNonImageFiles && preserveEmptyNonImageStructure) {
                foldersFromExcludedNonImages.forEach(folderPath => {
                    // Only create the folder if it does NOT contain any included files/images
                    if (!foldersWithContent.has(folderPath)) {
                         // The .folder() method is used to explicitly create a directory entry
                        zip.folder(folderPath); 
                    }
                });
            }


            zip.generateAsync({ type: 'blob' })
                .then(content => {
                    if (content.size > 0 || filesAddedCount > 0) {
                        saveAs(content, isFolderUpload ? 'processed_archive.zip' : 'converted_files.zip');
                        showGeneralMessage(`Successfully created ZIP archive with ${filesAddedCount} files.`, 'success');
                    } else {
                        showGeneralMessage('No files or folders were successfully added to the ZIP.', 'error');
                    }
                })
                .catch(error => {
                    showGeneralMessage(`An error occurred during file processing for ZIP: ${error.message}`, 'error');
                });
        });

        clearAllBtn.addEventListener('click', () => {
            if (conversionRunning) {
                showGeneralMessage('Cannot clear files while conversion is running.', 'error');
                return;
            }
            filesToProcess.length = 0;
            isFolderUpload = false;
            // Reset the new controls to their default state
            includeNonImageFiles = true;
            includeNonImageFilesCheckbox.checked = true;
            preserveEmptyNonImageStructure = false;
            preserveNonImageStructureCheckbox.checked = false;
            
            messageContainer.innerHTML = '';
            
            Array.from(fileList.children).forEach(li => {
                li.classList.add('opacity-0', 'scale-y-0', 'h-0', 'my-0', 'py-0');
            });

            setTimeout(() => {
                renderFileList();
                showGeneralMessage('File list cleared.', 'info');
            }, 400);
        });


        // Drag and Drop Event Listeners 
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('dragover');
            e.dataTransfer.dropEffect = 'copy';
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('dragover');
            
            if (e.dataTransfer.items.length > 0) {
                filesToProcess.length = 0;
                fileList.innerHTML = '';
                handleFiles(e.dataTransfer.items);
            }
        });

        // Click to Upload functionality
        dropZone.addEventListener('click', () => {
            hiddenFileInput.click();
        });

        hiddenFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                filesToProcess.length = 0;
                fileList.innerHTML = '';
                isFolderUpload = false; 

                Array.from(e.target.files).forEach(file => {
                     const path = file.webkitRelativePath || file.name;
                     addFileEntry(file, path);
                });
                renderFileList();
                e.target.value = ''; 
            }
        });

        // Initial setup and page load animation
        populateGlobalFormatSelector();
        updateControls();
        mainContent.classList.remove('opacity-0');
    </script>
</body>
</html>
