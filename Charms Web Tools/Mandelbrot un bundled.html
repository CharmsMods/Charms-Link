<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>64-Bit GPU Mandelbrot</title>
    <style>
        :root { --bg: #030303; --panel: #111111; --accent: #00ffcc; --text: #ffffff; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: var(--bg); font-family: 'Consolas', monospace; color: var(--text); }
        
        #ui { position: absolute; top: 20px; left: 20px; width: 280px; background: var(--panel); padding: 20px; border: 1px solid #333; box-shadow: 0 0 30px rgba(0,0,0,1); z-index: 10; border-radius: 2px; }
        h2 { margin: 0 0 15px 0; font-size: 0.9rem; color: var(--accent); letter-spacing: 2px; border-bottom: 1px solid #222; padding-bottom: 10px; }
        
        .row { margin-bottom: 15px; }
        label { display: flex; justify-content: space-between; font-size: 0.65rem; color: #888; margin-bottom: 4px; text-transform: uppercase; }
        input[type="range"] { width: 100%; cursor: crosshair; accent-color: var(--accent); }
        input[type="number"] { width: 48%; background: #000; border: 1px solid #444; color: var(--accent); padding: 5px; font-family: inherit; }
        
        button { width: 100%; padding: 12px; background: transparent; border: 1px solid var(--accent); color: var(--accent); font-weight: bold; cursor: pointer; transition: 0.2s; margin-top: 10px; }
        button:hover { background: var(--accent); color: #000; }
        
        #stats { font-size: 0.6rem; color: #444; margin-top: 15px; line-height: 1.6; }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="ui">
    <h2>â–£ PRECISION_EXPANSION_v2</h2>
    
    <div class="row">
        <label>Detail (Iter) <span id="v-iter">256</span></label>
        <input type="range" id="iter" min="64" max="3000" value="256">
    </div>

    <div class="row">
        <label>Color Shift <span id="v-hue">190</span></label>
        <input type="range" id="hue" min="0" max="360" value="190">
    </div>

    <div class="row">
        <label>Brightness <span id="v-bright">1.0</span></label>
        <input type="range" id="bright" min="0.1" max="5.0" step="0.1" value="1.0">
    </div>

    <div class="row" style="display:flex; justify-content: space-between;">
        <input type="number" id="expW" value="1920">
        <input type="number" id="expH" value="1080">
    </div>

    <button onclick="exportImage()">ðŸ“· RENDER 64-BIT PNG</button>

    <div id="stats">
        MODE: EMULATED_FLOAT64<br>
        ZOOM: <span id="s-zoom">1.0</span><br>
        POS_X: <span id="s-x">0</span>
    </div>
</div>

<canvas id="glCanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 pos;
    void main() { gl_Position = vec4(pos, 0.0, 1.0); }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision highp float;
    uniform vec2 u_res;
    uniform vec2 u_offH, u_offL; // High and Low parts of offset
    uniform vec2 u_zoomH, u_zoomL;
    uniform float u_hue, u_iter, u_bright;

    // --- Double-Single Math Functions ---
    vec2 ds_set(float a) { return vec2(a, 0.0); }
    
    vec2 ds_add(vec2 d1, vec2 d2) {
        float t1 = d1.x + d2.x;
        float e = t1 - d1.x;
        float t2 = ((d2.x - e) + (d1.x - (t1 - e))) + d1.y + d2.y;
        float s1 = t1 + t2;
        float s2 = t2 - (s1 - t1);
        return vec2(s1, s2);
    }

    vec2 ds_mul(vec2 d1, vec2 d2) {
        float c11 = d1.x * d2.x;
        float c12 = d1.x * d2.y;
        float c21 = d1.y * d2.x;
        float t1 = c11;
        float t2 = c12 + c21;
        float s1 = t1 + t2;
        float s2 = t2 - (s1 - t1);
        return vec2(s1, s2);
    }

    vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    void main() {
        float ratio = u_res.x / u_res.y;
        vec2 uv = (gl_FragCoord.xy / u_res.xy) - 0.5;
        uv.x *= ratio;

        // Map UV to 64-bit space
        vec2 cx = ds_add(ds_mul(ds_set(uv.x), ds_add(u_zoomH, u_zoomL)), u_offH);
        vec2 cy = ds_add(ds_mul(ds_set(uv.y), ds_add(u_zoomH, u_zoomL)), u_offL);

        vec2 zx = vec2(0.0), zy = vec2(0.0);
        float iter = 0.0;

        for (float i = 0.0; i < 5000.0; i++) {
            if (i >= u_iter) break;
            
            // z = z^2 + c in DS precision
            vec2 zx2 = ds_mul(zx, zx);
            vec2 zy2 = ds_mul(zy, zy);
            vec2 new_zx = ds_add(ds_add(zx2, ds_mul(zy2, ds_set(-1.0))), cx);
            vec2 new_zy = ds_add(ds_mul(ds_mul(zx, zy), ds_set(2.0)), cy);
            
            zx = new_zx; zy = new_zy;
            if (zx.x*zx.x + zy.x*zy.x > 8.0) break;
            iter++;
        }

        if (iter == u_iter) {
            gl_FragColor = vec4(0,0,0,1);
        } else {
            float sn = iter - log2(log2(zx.x*zx.x + zy.x*zy.x)) + 4.0;
            vec3 col = hsv2rgb(vec3(fract(u_hue/360.0 + sn*0.02), 0.8, u_bright * (iter/u_iter * 5.0)));
            gl_FragColor = vec4(col, 1.0);
        }
    }
</script>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });

    let zoom = 4.0, offX = -0.5, offY = 0;

    // Helper to split a JS number into High and Low 32-bit floats
    function split(n) {
        let h = Math.fround(n);
        let l = Math.fround(n - h);
        return [h, l];
    }

    const createShader = (t, s) => {
        const sh = gl.createShader(t);
        gl.shaderSource(sh, s);
        gl.compileShader(sh);
        return sh;
    };

    const prog = gl.createProgram();
    gl.attachShader(prog, createShader(gl.VERTEX_SHADER, document.getElementById('vs').text));
    gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, document.getElementById('fs').text));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
    const pLoc = gl.getAttribLocation(prog, "pos");
    gl.enableVertexAttribArray(pLoc);
    gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);

    const u = {
        res: gl.getUniformLocation(prog, "u_res"),
        offH: gl.getUniformLocation(prog, "u_offH"),
        offL: gl.getUniformLocation(prog, "u_offL"),
        zoomH: gl.getUniformLocation(prog, "u_zoomH"),
        zoomL: gl.getUniformLocation(prog, "u_zoomL"),
        hue: gl.getUniformLocation(prog, "u_hue"),
        iter: gl.getUniformLocation(prog, "u_iter"),
        bright: gl.getUniformLocation(prog, "u_bright")
    };

    function render() {
        gl.viewport(0, 0, canvas.width, canvas.height);
        const [xh, xl] = split(offX);
        const [yh, yl] = split(offY);
        const [zh, zl] = split(zoom);

        // Safely get input values with defaults
        const getSafeValue = (id, defaultValue) => {
            const el = document.getElementById(id);
            return el ? el.value : defaultValue;
        };

        gl.uniform2f(u.res, canvas.width, canvas.height);
        gl.uniform2f(u.offH, xh, xl);
        gl.uniform2f(u.offL, yh, yl);
        gl.uniform2f(u.zoomH, zh, zl);
        gl.uniform1f(u.hue, parseFloat(getSafeValue('hue', 190)));
        gl.uniform1f(u.iter, parseFloat(getSafeValue('iter', 256)));
        gl.uniform1f(u.bright, parseFloat(getSafeValue('bright', 1.0)));
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Only update UI if elements exist
        const updateIfExists = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.innerText = value;
        };

        updateIfExists('v-iter', getSafeValue('iter', 256));
        updateIfExists('s-zoom', (1/zoom).toExponential(3));
        updateIfExists('s-x', offX.toFixed(10));
    }

    window.addEventListener('wheel', e => {
        zoom *= e.deltaY > 0 ? 1.1 : 0.9;
        render();
    }, {passive:true});

    let drag = false, lx, ly;
    window.onmousedown = e => { if(e.target === canvas){ drag = true; lx = e.clientX; ly = e.clientY; }};
    window.onmouseup = () => drag = false;
    window.onmousemove = e => {
        if(drag) {
            const r = canvas.width / canvas.height;
            offX -= ((e.clientX - lx) / canvas.width) * zoom * r;
            offY += ((e.clientY - ly) / canvas.height) * zoom;
            lx = e.clientX; ly = e.clientY;
            render();
        }
    };

    function exportImage() {
        // Save current state
        const originalWidth = canvas.width;
        const originalHeight = canvas.height;
        const originalIter = document.getElementById('iter').value;
        
        // For export, use a much higher base iteration count
        const baseExportIter = 10000; // Base iterations for export
        
        // Calculate resolution scale factor
        const scale = Math.max(
            parseInt(document.getElementById('expW').value) / originalWidth,
            parseInt(document.getElementById('expH').value) / originalHeight
        );
        
        // Use higher iterations for export, with a minimum of 20000 and up to 50000 based on zoom
        const zoomFactor = Math.max(1, Math.log10(1/zoom));
        const adjustedIter = Math.min(
            baseExportIter * (1 + zoomFactor * 0.5), // Scale with zoom level
            50000 // Absolute maximum to prevent freezing
        );
        
        // Show a message since this might take a while
        const status = document.getElementById('stats');
        const originalStatus = status.innerHTML;
        status.innerHTML = `PREPARING EXPORT...`;
        
        // Use setTimeout to ensure UI updates before heavy rendering
        setTimeout(() => {
            // Set the iteration count and update display
            document.getElementById('iter').value = Math.round(adjustedIter);
            document.getElementById('v-iter').textContent = Math.round(adjustedIter);
            
            // Update status
            status.innerHTML = `RENDERING ${Math.round(adjustedIter).toLocaleString()} ITERATIONS...`;
            
            // Force a reflow to ensure the status updates
            canvas.offsetHeight;
            
            // Set new dimensions
            const w = parseInt(document.getElementById('expW').value);
            const h = parseInt(document.getElementById('expH').value);
            canvas.width = w;
            canvas.height = h;
            
            // Render with adjusted settings
            render();
            
            // Use requestAnimationFrame to ensure render is complete
            requestAnimationFrame(() => {
                // Small delay to ensure render is complete
                setTimeout(() => {
                    // Create and trigger download
                    const a = document.createElement('a');
                    a.download = `fractal_64bit_${w}x${h}_iter${Math.round(adjustedIter)}_${Date.now()}.png`;
                    
                    // Force a new canvas for the export to ensure we get the rendered content
                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = w;
                    exportCanvas.height = h;
                    const ctx = exportCanvas.getContext('2d');
                    ctx.drawImage(canvas, 0, 0);
                    
                    // Convert to data URL and trigger download
                    a.href = exportCanvas.toDataURL('image/png', 1.0);
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    // Restore original state
                    canvas.width = originalWidth;
                    canvas.height = originalHeight;
                    document.getElementById('iter').value = originalIter;
                    document.getElementById('v-iter').textContent = originalIter;
                    status.innerHTML = originalStatus;
                    render();
                }, 100); // Small delay to ensure render is complete
            });
        }, 100); // Initial delay to ensure UI updates
    }

    const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); };
    window.onresize = resize;
    document.querySelectorAll('input').forEach(i => i.oninput = render);
    resize();
</script>
</body>
</html>