<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minimal DNG 3D LUT Editor</title>
  <style>
    :root {
      --bg: #121212;
      --bg-panel: #1e1e1e;
      --fg: #f5f5f5;
      --accent: #4fc3f7;
      --accent-hover: #29b6f6;
      --border: #333;
      --radius: 8px;
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 12px;
      --space-lg: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #212121 0, #121212 100%);
      color: var(--fg);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 500;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: var(--space-md) var(--space-lg);
      gap: var(--space-lg);
      overflow: hidden;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-md);
      align-items: center;
      background: var(--bg-panel);
      padding: var(--space-md);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    label {
      font-size: 13px;
      opacity: 0.9;
    }

    input[type="file"] {
      font-size: 12px;
      color: var(--fg);
    }

    input[type="range"] {
      accent-color: var(--accent);
      cursor: pointer;
    }

    .range-value {
      min-width: 32px;
      font-variant-numeric: tabular-nums;
      font-size: 12px;
    }

    button {
      background: var(--accent);
      border: none;
      color: #000;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.15s ease, transform 0.05s ease;
    }

    button:hover {
      background: var(--accent-hover);
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      transform: none;
    }

    .status {
      font-size: 12px;
      opacity: 0.8;
      max-width: 400px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .status.error {
      color: #ff8a80;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      background: #000;
      border-radius: var(--radius);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }

    .placeholder {
      position: absolute;
      font-size: 13px;
      opacity: 0.5;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <header>
    <h1>Minimal DNG 3D LUT Editor</h1>
  </header>

  <main>
    <div class="toolbar">
      <div class="toolbar-group">
        <label for="dngInput">DNG</label>
        <input id="dngInput" type="file" accept=".dng,.DNG" />
      </div>

      <div class="toolbar-group">
        <label for="lutInput">LUT (.cube)</label>
        <input id="lutInput" type="file" accept=".cube,.CUBE" />
      </div>

      <div class="toolbar-group">
        <label for="strengthInput">LUT strength</label>
        <input id="strengthInput" type="range" min="0" max="100" value="100" />
        <span id="strengthValue" class="range-value">100%</span>
      </div>

      <div class="toolbar-group">
        <button id="exportBtn" disabled>Export PNG</button>
      </div>

      <div class="toolbar-group">
        <span id="status" class="status">Ready.</span>
      </div>
    </div>

    <div class="canvas-container">
      <span id="placeholder" class="placeholder">Open a DNG to begin.</span>
      <canvas id="canvas"></canvas>
    </div>
  </main>

  <script type="module">
    // ----------------------------------------------------------------------
    // Imports & global state
    // ----------------------------------------------------------------------
    import LibRaw from "https://cdn.jsdelivr.net/npm/libraw-wasm@1.1.2/dist/index.js";

    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl2", { preserveDrawingBuffer: true });

    const dngInput = document.getElementById("dngInput");
    const lutInput = document.getElementById("lutInput");
    const strengthInput = document.getElementById("strengthInput");
    const strengthValue = document.getElementById("strengthValue");
    const exportBtn = document.getElementById("exportBtn");
    const statusEl = document.getElementById("status");
    const placeholderEl = document.getElementById("placeholder");

    let raw = null;
    let imageTexture = null;
    let lut3DTexture = null;
    let lutSize = 0;
    let lutMin = 0.0;
    let lutMax = 1.0;

    let originalRGBBytes = null; // Uint8Array RGB
    let imageWidth = 0;
    let imageHeight = 0;

    let dngFileLoaded = false;
    let lutFileLoaded = false;

    // ----------------------------------------------------------------------
    // Helper: status messages
    // ----------------------------------------------------------------------
    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.classList.toggle("error", isError);
    }

    // ----------------------------------------------------------------------
    // WebGL boilerplate (simple 2D full-screen quad)
    // ----------------------------------------------------------------------
    const vertexShaderSource = `#version 300 es
      in vec2 a_position;
      in vec2 a_texCoord;

      out vec2 v_texCoord;

      void main() {
        gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    const fragmentShaderSource = `#version 300 es
      // Explicit precision statements to fix driver quirks
      precision highp float;
      precision highp sampler2D;
      precision highp sampler3D;

      uniform sampler2D u_image;
      uniform sampler3D u_lut3D;
      uniform float u_strength;
      uniform float u_lutMin;
      uniform float u_lutMax;
      uniform bool u_hasLut;

      in vec2 v_texCoord;
      out vec4 outColor;

      vec3 applyLut(vec3 rgb) {
        // Map [u_lutMin, u_lutMax] -> [0, 1]
        vec3 domain = vec3(u_lutMax - u_lutMin);
        vec3 t = clamp((rgb - vec3(u_lutMin)) / (domain + 1e-6), 0.0, 1.0);
        // Sample 3D texture; GL_LINEAR gives trilinear interpolation.
        vec3 graded = texture(u_lut3D, t).rgb;
        return graded;
      }

      void main() {
        vec3 src = texture(u_image, v_texCoord).rgb;
        vec3 dst = src;
        if (u_hasLut && u_strength > 0.0) {
          vec3 graded = applyLut(src);
          dst = mix(src, graded, u_strength);
        }
        outColor = vec4(dst, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error("Shader compile error: " + info);
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(prog);
        gl.deleteProgram(prog);
        throw new Error("Program link error: " + info);
      }
      return prog;
    }

    let program;
    let positionBuffer;
    let texCoordBuffer;

    let u_imageLoc;
    let u_lut3DLoc;
    let u_strengthLoc;
    let u_lutMinLoc;
    let u_lutMaxLoc;
    let u_hasLutLoc;

    function initWebGL() {
      if (!gl) {
        throw new Error("WebGL2 not supported.");
      }
      program = createProgram(gl, vertexShaderSource, fragmentShaderSource);

      const positionLoc = gl.getAttribLocation(program, "a_position");
      const texCoordLoc = gl.getAttribLocation(program, "a_texCoord");

      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]),
        gl.STATIC_DRAW
      );

      texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]),
        gl.STATIC_DRAW
      );

      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      gl.enableVertexAttribArray(positionLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(texCoordLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

      gl.bindVertexArray(null);

      program.vao = vao;

      u_imageLoc = gl.getUniformLocation(program, "u_image");
      u_lut3DLoc = gl.getUniformLocation(program, "u_lut3D");
      u_strengthLoc = gl.getUniformLocation(program, "u_strength");
      u_lutMinLoc = gl.getUniformLocation(program, "u_lutMin");
      u_lutMaxLoc = gl.getUniformLocation(program, "u_lutMax");
      u_hasLutLoc = gl.getUniformLocation(program, "u_hasLut");
    }

    function uploadRGBTexture(gl, width, height, data) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGB8,
        width,
        height,
        0,
        gl.RGB,
        gl.UNSIGNED_BYTE,
        data
      );
      return tex;
    }

    function updateCanvasSize() {
      if (!imageWidth || !imageHeight) return;

      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.parentElement.getBoundingClientRect();

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render() {
      if (!imageWidth || !imageHeight) return;

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.bindVertexArray(program.vao);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, imageTexture);
      gl.uniform1i(u_imageLoc, 0);

      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_3D, lut3DTexture);
      gl.uniform1i(u_lut3DLoc, 1);

      const strength = parseInt(strengthInput.value, 10) / 100;
      gl.uniform1f(u_strengthLoc, strength);

      gl.uniform1f(u_lutMinLoc, lutMin);
      gl.uniform1f(u_lutMaxLoc, lutMax);

      const hasLut = lutFileLoaded && lutSize > 0 && lut3DTexture;
      gl.uniform1i(u_hasLutLoc, hasLut ? 1 : 0);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    }

    // ----------------------------------------------------------------------
    // 3D LUT handling (.cube)
    // ----------------------------------------------------------------------
    async function parseCubeLUT(file) {
      const text = await file.text();
      const lines = text.split(/\r?\n/).map((s) => s.trim());

      let size = 33;
      let min = 0.0;
      let max = 1.0;
      const data = [];

      const titleMatch = lines.find((l) => l.startsWith("TITLE"));
      const title = titleMatch ? titleMatch.substring(5).trim() : file.name;

      const sizeMatch = lines.find((l) => l.toUpperCase().startsWith("LUT_3D_SIZE"));
      if (sizeMatch) {
        const parts = sizeMatch.split(/\s+/);
        if (parts.length >= 2) {
          const parsed = parseInt(parts[1], 10);
          if (!Number.isNaN(parsed) && parsed > 0) {
            size = parsed;
          }
        }
      }

      const minMatch = lines.find((l) => l.toUpperCase().startsWith("LUT_3D_INPUT_MIN"));
      if (minMatch) {
        const parts = minMatch.split(/\s+/);
        if (parts.length >= 2) {
          const v = parseFloat(parts[1]);
          if (!Number.isNaN(v)) {
            min = v;
          }
        }
      }

      const maxMatch = lines.find((l) => l.toUpperCase().startsWith("LUT_3D_INPUT_MAX"));
      if (maxMatch) {
        const parts = maxMatch.split(/\s+/);
        if (parts.length >= 2) {
          const v = parseFloat(parts[1]);
          if (!Number.isNaN(v)) {
            max = v;
          }
        }
      }

      for (const line of lines) {
        if (!line || line.startsWith("#")) continue;
        const parts = line.split(/\s+/).map((s) => parseFloat(s));
        if (parts.length >= 3 && !Number.isNaN(parts[0])) {
          data.push(parts[0], parts[1], parts[2]);
        }
      }

      const expected = size * size * size * 3;
      if (data.length < expected) {
        throw new Error(
          `CUBE LUT data is incomplete (expected ${expected} values, got ${data.length}).`
        );
      }

      return {
        title,
        size,
        min,
        max,
        data: new Float32Array(data.slice(0, expected)),
      };
    }

    function createLUT3DTexture(gl, lut) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_3D, tex);

      const { size, data, min, max } = lut;

      gl.texImage3D(
        gl.TEXTURE_3D,
        0,
        gl.RGB32F,
        size,
        size,
        size,
        0,
        gl.RGB,
        gl.FLOAT,
        data
      );

      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);

      return { tex, size, min, max };
    }

    // ----------------------------------------------------------------------
    // RAW/DNG handling via libraw-wasm
    // ----------------------------------------------------------------------
    async function loadDNG(file) {
      setStatus("Loading DNG...");
      try {
        const buffer = await file.arrayBuffer();
        const bytes = new Uint8Array(buffer);

        if (!raw) {
          raw = new LibRaw();
        }

        const settings = {
          outputColor: 1,
          outputBps: 8,
          userQual: 3,
          halfSize: false,
          useCameraWb: true,
        };

        await raw.open(bytes, settings);
        const imageData = await raw.imageData();
        const meta = await raw.metadata(true);
        const width =
          meta.width ||
          meta.imageWidth ||
          (meta.rawData && meta.rawData.width) ||
          0;
        const height =
          meta.height ||
          meta.imageHeight ||
          (meta.rawData && meta.rawData.height) ||
          0;

        if (!width || !height) {
          throw new Error("Could not determine DNG dimensions from metadata.");
        }

        if (imageData.length !== width * height * 3) {
          console.warn(
            "DNG pixel data size does not match W*H*3; rendering may be incorrect."
          );
        }

        originalRGBBytes = imageData;
        imageWidth = width;
        imageHeight = height;

        dngFileLoaded = true;
        setStatus(`Loaded DNG: ${file.name} (${width}Ã—${height}).`);
        placeholderEl.hidden = true;

        updateCanvasSize();

        if (imageTexture) {
          gl.deleteTexture(imageTexture);
        }
        imageTexture = uploadRGBTexture(gl, imageWidth, imageHeight, originalRGBBytes);

        render();

        exportBtn.disabled = false;
      } catch (e) {
        console.error(e);
        setStatus("Failed to load DNG: " + e.message, true);
        dngFileLoaded = false;
        exportBtn.disabled = true;
      }
    }

    // ----------------------------------------------------------------------
    // LUT file handling
    // ----------------------------------------------------------------------
    async function loadLUT(file) {
      setStatus("Loading LUT...");
      try {
        const lut = await parseCubeLUT(file);

        const lutObj = createLUT3DTexture(gl, lut);
        if (lut3DTexture) {
          gl.deleteTexture(lut3DTexture);
        }
        lut3DTexture = lutObj.tex;
        lutSize = lutObj.size;
        lutMin = lutObj.min;
        lutMax = lutObj.max;

        lutFileLoaded = true;
        setStatus(`Loaded LUT: ${lut.title} (${lut.size}^3).`);

        render();
      } catch (e) {
        console.error(e);
        setStatus("Failed to load LUT: " + e.message, true);
        lutFileLoaded = false;
      }
    }

    // ----------------------------------------------------------------------
    // Export PNG (full resolution)
    // ----------------------------------------------------------------------
    function exportPNG() {
      if (!imageWidth || !imageHeight || !originalRGBBytes) {
        setStatus("Nothing to export.", true);
        return;
      }

      setStatus("Exporting PNG...");

      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = imageWidth;
      exportCanvas.height = imageHeight;
      const ctx = exportCanvas.getContext("2d");

      const imgData = ctx.createImageData(imageWidth, imageHeight);
      const dst = imgData.data;
      const src = originalRGBBytes;

      for (let i = 0, j = 0; i < src.length; i += 3, j += 4) {
        dst[j] = src[i];
        dst[j + 1] = src[i + 1];
        dst[j + 2] = src[i + 2];
        dst[j + 3] = 255;
      }
      ctx.putImageData(imgData, 0, 0);

      const link = document.createElement("a");
      link.download = "dng-lut-export.png";
      link.href = exportCanvas.toDataURL("image/png");
      link.click();

      setStatus("Export complete.");
    }

    // ----------------------------------------------------------------------
    // UI events
    // ----------------------------------------------------------------------
    dngInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await loadDNG(file);
    });

    lutInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await loadLUT(file);
    });

    strengthInput.addEventListener("input", () => {
      const v = strengthInput.value;
      strengthValue.textContent = v + "%";
      if (dngFileLoaded) {
        render();
      }
    });

    exportBtn.addEventListener("click", exportPNG);

    window.addEventListener("resize", () => {
      updateCanvasSize();
      if (dngFileLoaded) {
        render();
      }
    });

    // ----------------------------------------------------------------------
    // Init
    // ----------------------------------------------------------------------
    (async function init() {
      try {
        initWebGL();
        setStatus("Ready. Open a DNG to begin.");
      } catch (e) {
        console.error(e);
        setStatus("WebGL2 initialization failed: " + e.message, true);
      }
    })();
  </script>
</body>
</html>