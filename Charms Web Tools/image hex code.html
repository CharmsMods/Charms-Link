<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monochrome Image Color Picker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /*
      ====================================
      | üñºÔ∏è High-Contrast Monochrome Styles |
      ====================================
    */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    :root {
      --text-color: #ffffff; /* Pure White */
      --background-color: #000000; /* Pure Black */
      --border-color: #ffffff; /* Pure White */
      --primary-color-bg: #ffffff; /* White for main buttons */
      --primary-color-text: #000000; /* Black for text on main buttons */
      --hover-bg: rgba(255, 255, 255, 0.1); /* Subtle white hover */
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      /* Animation key: Use transition for smooth UI changes */
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth transition */
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .container {
      width: 100%;
      max-width: 800px;
      text-align: center;
    }
    
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    
    /* Upload Area */
    .upload-area {
      margin: 2rem 0;
      padding: 2rem;
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      position: relative;
    }
    
    .upload-area:hover {
      background: var(--hover-bg);
      border-color: var(--text-color);
    }
    
    #upload {
      display: none;
    }
    
    .upload-label {
      display: block;
      background-color: var(--primary-color-bg);
      color: var(--primary-color-text);
      padding: 0.75rem 2rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      /* Monochromatic shadow */
      box-shadow: 0 4px 10px rgba(255, 255, 255, 0.4); 
    }
    
    .upload-label:hover {
      background-color: #cccccc; /* Slightly darker white on hover */
      color: var(--primary-color-text);
    }

    /* Message Box */
    .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--primary-color-bg);
        color: var(--primary-color-text);
        padding: 15px 30px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        z-index: 1000;
        display: none;
        animation: fadeInDown 0.3s ease-out;
    }
    
    #canvas {
      width: 100%;
      height: auto;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      cursor: crosshair;
      margin: 0 auto;
      display: block;
      max-height: 60vh;
      max-width: 100%;
      /* Monochromatic subtle glow */
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.15); 
    }
    
    .color-info {
      margin: 2rem 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    /* Color Info Pop-in Animation */
    @keyframes popIn {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .color-info.animate-results {
      animation: popIn 0.4s ease-out;
    }
    
    .color-values {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }
    
    #hexValue, #rgbValue {
      font-size: 1.3rem;
      font-weight: 600;
      font-family: 'Fira Code', monospace; 
      letter-spacing: 1px;
      padding: 5px 10px;
      border-radius: 4px;
      background: #111111; /* Slightly off-black background for code values */
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }
    
    #preview {
      width: 90px;
      height: 90px;
      border: 4px solid var(--text-color);
      border-radius: 50%; 
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      transform: scale(1);
    }
    
    /* Copy Button Pulse Animation */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    #copyBtn {
      background: var(--primary-color-bg);
      color: var(--primary-color-text);
      border: none;
      padding: 0.75rem 2rem;
      font-size: 1rem;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 1rem;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(255, 255, 255, 0.4);
    }
    
    #copyBtn.pulsing {
      animation: pulse 0.6s ease-out 1;
    }

    .instructions {
      margin: 1rem 0;
      color: var(--text-color);
      opacity: 0.7;
      font-size: 0.9rem;
      line-height: 1.6;
      height: 1.5rem;
      display: none;
    }

    /* Console Log Area - Inverted for readability */
    .log-area {
        margin-top: 2rem;
        width: 100%;
        max-width: 800px;
        text-align: left;
        padding: 1rem;
        background: var(--primary-color-bg); /* White background */
        color: var(--primary-color-text); /* Black text */
        border: 1px solid var(--primary-color-text);
        border-radius: 8px;
        font-family: 'Fira Code', monospace;
        font-size: 0.85rem;
        max-height: 250px;
        overflow-y: auto;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
    }

    .log-entry {
        padding: 2px 0;
        border-bottom: 1px dashed #cccccc; /* Light gray separator */
    }

    .log-entry:last-child {
        border-bottom: none;
    }

    .log-timestamp {
        color: #444444; /* Darker gray timestamp */
        margin-right: 10px;
    }

    /* Use BOLD and ITALIC for log types instead of color */
    .log-type-INFO { font-style: italic; } 
    .log-type-ERROR { font-weight: bold; } 
    .log-type-SUCCESS { font-weight: 600; } 
    .log-type-PIXEL { font-style: italic; opacity: 0.8; }
    
    /* Utility keyframe for message box */
    @keyframes fadeInDown {
      0% { opacity: 0; transform: translate(-50%, -100%); }
      100% { opacity: 1; transform: translate(-50%, -50%); }
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 1.5rem;
      }
      .upload-area {
        padding: 1.5rem;
      }
      #hexValue, #rgbValue {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Color Picker </h1>
    
    <div class="upload-area">
      <label class="upload-label" for="upload">
        Upload Image
        <input type="file" id="upload" accept="image/*">
      </label>
      <p style="margin-top: 10px; color: var(--text-color); opacity: 0.8;">or Drag & Drop a file here</p>
    </div>
    
    <div class="instructions" id="instructions">
      Click anywhere on the image to pick a color
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="color-info" id="colorInfo">
      <div id="preview"></div>
      <div class="color-values">
        <div id="hexValue">#------</div>
        <div id="rgbValue">RGB(---, ---, ---)</div>
      </div>
      <button id="copyBtn">Copy HEX Color</button>
    </div>

    <!-- The new Console Log Area -->
    <div class="log-area">
        <div class="log-entry log-type-INFO">
            <span class="log-timestamp">[00:00:00]</span>
            <span class="log-message">SYSTEM: Awaiting user action. Theme: Monochrome.</span>
        </div>
    </div>
  </div>

  <!-- The Modal for custom messages -->
  <div class="message-box" id="messageBox"></div>

  <script>
    // --- UTILITIES ---
    const logArea = document.querySelector('.log-area');
    const colorInfo = document.getElementById('colorInfo');

    /**
     * Logs an action to the console area.
     * @param {string} message The message to log.
     * @param {string} type The type of log (INFO, ERROR, SUCCESS, PIXEL).
     */
    function logAction(message, type = 'INFO') {
        const entry = document.createElement('div');
        const now = new Date();
        const timeStr = now.toLocaleTimeString('en-US', { hour12: false, second: '2-digit', minute: '2-digit' });
        
        entry.className = `log-entry log-type-${type.toUpperCase()}`;
        entry.innerHTML = `
            <span class="log-timestamp">[${timeStr}]</span>
            <span class="log-message">${type.toUpperCase()}: ${message}</span>
        `;
        
        logArea.appendChild(entry);
        // Auto-scroll to the bottom for the latest log
        logArea.scrollTop = logArea.scrollHeight;
    }

    function showMessage(text, duration = 3000) {
        const box = document.getElementById('messageBox');
        box.textContent = text;
        box.style.display = 'block';
        logAction(`NOTIFICATION: Showing message: "${text}"`, 'INFO');
        setTimeout(() => {
            box.style.display = 'none';
        }, duration);
    }

    // --- MAIN LOGIC (NO CHANGE REQUIRED HERE, IT'S ALL JS) ---
    const upload = document.getElementById('upload');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hexValue = document.getElementById('hexValue');
    const rgbValue = document.getElementById('rgbValue');
    const preview = document.getElementById('preview');
    const copyBtn = document.getElementById('copyBtn');
    const instructions = document.getElementById('instructions');

    let currentHex = "";
    let currentRgb = "";
    let isImageLoaded = false;
    let originalImage = null;

    function resizeCanvas() {
        if (!originalImage) return;

        logAction('RESIZE: Recalculating canvas display dimensions.', 'INFO');

        const img = originalImage;
        const containerWidth = Math.min(window.innerWidth - 40, 800);
        const containerHeight = Math.min(window.innerHeight * 0.6, 600);
        
        const imgAspectRatio = img.width / img.height;
        const containerAspectRatio = containerWidth / containerHeight;
        
        let displayWidth, displayHeight;
        
        if (imgAspectRatio > containerAspectRatio) {
            displayWidth = containerWidth;
            displayHeight = containerWidth / imgAspectRatio;
        } else {
            displayHeight = containerHeight;
            displayWidth = containerHeight * imgAspectRatio;
        }
        
        // Use a transition (via CSS) for smooth resizing
        canvas.style.width = `${displayWidth}px`;
        canvas.style.height = `${displayHeight}px`;

        logAction(`RESIZE: Set display size to ${Math.round(displayWidth)}x${Math.round(displayHeight)}px.`, 'INFO');
    }


    // Handle file upload
    upload.addEventListener('change', function(e) {
      logAction('UPLOAD: File input changed. Processing file...', 'INFO');
      const file = e.target.files[0];
      if (!file) {
        logAction('UPLOAD: No file selected.', 'ERROR');
        return;
      }

      const img = new Image();
      img.onload = function() {
        logAction(`IMAGE: Image loaded successfully (MIME: ${file.type}).`, 'SUCCESS');
        originalImage = img;

        // Set the internal drawing buffer size
        canvas.width = img.width;
        canvas.height = img.height;
        logAction(`CANVAS: Drawing buffer size set to ${img.width}x${img.height}.`, 'PIXEL');

        // Draw the image
        ctx.drawImage(img, 0, 0);
        logAction('CANVAS: Image drawn onto the canvas context.', 'PIXEL');
        
        isImageLoaded = true;
        
        resizeCanvas();

        instructions.style.display = 'block';
        showMessage('Image loaded! Click to pick a color.', 2000);
      };
      
      img.onerror = function() {
        logAction("IMAGE: Error loading image.", 'ERROR');
        showMessage("Error loading image. Please try another file.");
      };
      
      img.src = URL.createObjectURL(file);
      logAction(`UPLOAD: Starting image load from URL: ${img.src.substring(0, 30)}...`, 'INFO');
    });

    // Handle color picking
    canvas.addEventListener('click', function(e) {
      if (!isImageLoaded) {
        logAction('CLICK: Click ignored, no image is currently loaded.', 'INFO');
        showMessage("Please upload an image first!", 1500);
        return;
      }

      // 1. Get client rect for display scaling
      const rect = canvas.getBoundingClientRect();
      
      // 2. Calculate coordinates
      const clickXInDisplay = e.clientX - rect.left;
      const clickYInDisplay = e.clientY - rect.top;

      // 3. Scale to actual canvas buffer size
      const x = Math.floor(clickXInDisplay * (canvas.width / rect.width));
      const y = Math.floor(clickYInDisplay * (canvas.height / rect.height));

      logAction(`PICK: Clicked at display (${Math.round(clickXInDisplay)}, ${Math.round(clickYInDisplay)}).`, 'INFO');
      logAction(`PICK: Scaling to buffer coordinates (${x}, ${y}).`, 'PIXEL');
      
      // 4. Get pixel data
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      const r = pixel[0];
      const g = pixel[1];
      const b = pixel[2];
      
      // 5. Conversion (The Math Part!)
      const toHex = (c) => c.toString(16).padStart(2, '0');
      const hex = '#' + toHex(r) + toHex(g) + toHex(b).toUpperCase();
      const rgb = `RGB(${r}, ${g}, ${b})`;
      
      currentHex = hex;
      currentRgb = rgb;

      logAction(`PICK: Color captured! R:${r} G:${g} B:${b} (${hex}).`, 'SUCCESS');
      
      // 6. Update display & Animate
      hexValue.textContent = hex;
      rgbValue.textContent = rgb;
      
      // Animate the preview color change
      preview.style.backgroundColor = hex;
      preview.style.transform = 'scale(1.1)';
      setTimeout(() => preview.style.transform = 'scale(1)', 100);

      // Trigger pop-in animation for results section
      colorInfo.classList.add('animate-results');
      // Remove class after animation to allow re-triggering
      setTimeout(() => colorInfo.classList.remove('animate-results'), 450);

      copyBtn.textContent = 'Copy HEX Color';
    });

    // Handle copy to clipboard
    copyBtn.addEventListener('click', function() {
      if (!currentHex) {
        logAction('COPY: Copy failed. No color selected.', 'ERROR');
        showMessage("Please pick a color first!", 1500);
        return;
      }
      
      const textToCopy = currentHex; // Copying just HEX is generally preferred
      logAction(`COPY: Attempting to copy HEX value ${textToCopy} to clipboard.`, 'INFO');

      const tempInput = document.createElement('textarea');
      tempInput.value = textToCopy;
      document.body.appendChild(tempInput);
      tempInput.select();
      
      try {
        const successful = document.execCommand('copy');
        if (successful) {
            logAction(`COPY: Successfully copied ${textToCopy}.`, 'SUCCESS');
            // Trigger pulse animation
            copyBtn.classList.add('pulsing');
            setTimeout(() => copyBtn.classList.remove('pulsing'), 600);

            // Give user feedback
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied! ‚úÖ';
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 2000);
        } else {
            logAction('COPY: Failed to copy using execCommand.', 'ERROR');
        }
      } catch (err) {
        logAction('COPY: Error during copy operation.', 'ERROR');
      } finally {
        document.body.removeChild(tempInput);
      }
    });

    // Handle window resize to maintain aspect ratio
    window.addEventListener('resize', resizeCanvas);
    logAction('SYSTEM: Window resize listener initialized.', 'INFO');


    // Drag and drop support with logging
    const dropArea = document.querySelector('.upload-area');
    
    ['dragenter', 'dragover'].forEach(eventName => {
      dropArea.addEventListener(eventName, preventDefaults, false);
      dropArea.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, unhighlight, false);
    });

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    function highlight() {
      // White with black background for drag over
      dropArea.style.background = 'rgba(255, 255, 255, 0.1)'; 
      dropArea.style.borderColor = '#ffffff';
      logAction('DRAG: Drag over detected, highlighting drop zone.', 'INFO');
    }
    
    function unhighlight() {
      dropArea.style.background = '';
      dropArea.style.borderColor = '#ffffff';
      logAction('DRAG: Drag leave or drop, unhighlighting drop zone.', 'INFO');
    }
    
    dropArea.addEventListener('drop', handleDrop, false);
    
    function handleDrop(e) {
      logAction('DROP: File dropped, initiating upload process.', 'INFO');
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        upload.files = files;
        const event = new Event('change');
        upload.dispatchEvent(event);
      } else {
        logAction('DROP: No files found in drop event.', 'ERROR');
      }
    }
    logAction('SYSTEM: Drag & Drop handlers initialized.', 'INFO');
  </script>
</body>
</html>
