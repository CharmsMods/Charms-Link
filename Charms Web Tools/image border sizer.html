<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Border Sizer (B&W Edition)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /*
        * Strict Monochrome Palette:
        * Background: #000000 (Black)
        * Text/Borders/Elements: #ffffff (White)
        */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
        
        :root {
            /* All colors must be #000000 or #ffffff */
            --text-color: #ffffff;
            --box-bg-color: rgba(255, 255, 255, 0.05); /* Very dark semi-transparent white on black background */
            --border-color: #ffffff;
            --highlight-color: #ffffff;
            --button-primary-bg: #ffffff;
            --button-primary-text: #000000;
            --button-secondary-bg: #000000;
            --button-secondary-text: #ffffff;
        }

        /* Added transition to ALL elements for overall smoothness */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            transition: all 0.35s ease-out; /* Smoother, slightly longer transition */
        }

        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #000000;
            color: var(--text-color);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            text-align: center;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 1.5rem;
            font-weight: 700;
            color: var(--text-color);
            letter-spacing: -0.5px;
        }

        .description {
            color: #ffffff; /* White text for high contrast */
            opacity: 0.8;
            margin-bottom: 2rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        /* Message Box styling */
        #message-box {
            color: var(--highlight-color);
            margin-top: 1rem;
            height: 1.5rem; /* Reserve space for CLS prevention */
            font-weight: 500;
            font-size: 1rem;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2px; /* Minimal padding for a tight border */
            margin-bottom: 2rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--box-bg-color);
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); /* Subtle glow effect */
        }

        canvas {
            max-width: 100%;
            max-height: 60vh;
            border: 1px solid var(--border-color);
            cursor: crosshair;
            margin: 0 auto;
            display: block;
            background-color: #000000; /* Black background for canvas placeholder */
            border-radius: 6px;
            width: 300px; 
            height: 150px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            max-width: 700px;
            margin: 0 auto 2rem;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--box-bg-color);
        }

        .control-group {
            text-align: left;
        }

        .control-group h3 {
            font-size: 1.05rem;
            margin-bottom: 0.75rem;
            color: var(--text-color);
            font-weight: 600;
        }
        
        /* --- SLIDER ANIMATIONS --- */
        input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            height: 8px; /* Slightly thicker track */
            background: #ffffff; /* White track */
            opacity: 0.2;
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]:focus {
            opacity: 0.4;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            border: 3px solid #000000;
            cursor: grab;
            box-shadow: 0 0 0 1px #ffffff;
            transition: all 0.2s ease; /* Animation on thumb */
        }
        
        input[type="range"]::-webkit-slider-thumb:active {
            width: 20px;
            height: 20px;
            cursor: grabbing;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .color-info-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .color-display-row {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .color-value-box {
            display: flex;
            align-items: center;
            flex-grow: 1;
            background: #000000;
            border: 1px solid #ffffff;
            padding: 0.5rem;
            border-radius: 4px;
            justify-content: space-between;
        }
        
        .color-value-text {
            font-family: 'Courier New', monospace;
            font-weight: 500;
            color: white;
            padding-right: 1rem;
        }

        /* --- COPY BUTTON ANIMATIONS --- */
        .copy-button {
            background: #ffffff;
            color: #000000;
            border: 1px solid #ffffff;
            padding: 0.25rem 0.75rem;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .copy-button:hover {
            background: #000000;
            color: #ffffff;
        }
        
        .copy-button:active {
            transform: scale(0.95);
        }
        
        .color-picker-input {
            width: 40px; 
            height: 40px; 
            border: 2px solid var(--border-color); 
            border-radius: 8px; 
            cursor: pointer;
            padding: 0; 
            background: none; 
            overflow: hidden;
        }
        
        .export-controls {
            grid-column: 1 / -1; /* Span full width */
            margin-top: 1rem;
            padding-top: 1.5rem;
            border-top: 1px solid #ffffff;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .export-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        /* --- GENERAL BUTTON ANIMATIONS --- */
        .btn-base {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(255, 255, 255, 0.1);
        }
        
        .export-buttons button {
            flex-grow: 1;
            max-width: 150px;
            border: 1px solid #ffffff; /* Secondary button style */
        }
        
        .export-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #000000;
            color: #ffffff;
        }
        
        /* Primary button: White background, Black text */
        #export-jpeg {
            background: var(--button-primary-bg);
            color: var(--button-primary-text);
            border: 1px solid var(--button-primary-bg);
        }
        #export-jpeg:hover:not(:disabled) {
            background: #000000;
            color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }

        /* Secondary button: Black background, White text */
        #export-png {
            background: var(--button-secondary-bg);
            color: var(--button-secondary-text);
        }
        #export-png:hover:not(:disabled) {
            background: #ffffff;
            color: #000000;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }

        /* --- UPLOAD AREA ANIMATIONS --- */
        .upload-area {
            margin: 1rem 0 2rem;
            padding: 1.5rem;
            border: 2px dashed #ffffff;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 1rem;
            transition: all 0.3s ease-in-out;
        }

        .upload-area:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }
        
        .upload-area-highlight { /* Used for Drag/Drop hover state */
             background: rgba(255, 255, 255, 0.15) !important;
             border-color: #ffffff !important;
             transform: translateY(-2px);
        }

        .upload-label {
            display: block;
            background-color: #ffffff;
            color: #000000;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            border: 1px solid #ffffff;
        }

        .upload-label:hover {
            background-color: #000000;
            color: #ffffff;
            box-shadow: 0 0 5px #ffffff;
        }
        
        /* Responsive Grid for controls */
        @media (max-width: 600px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>Image Border Sizer</h1>
        <p class="description">Add customizable borders to your images and export in various formats.</p>

        <div class="upload-area" id="upload-area">
            <label class="upload-label" for="image-upload">
                <span style="font-size: 1.2rem;"></span> Upload Image
                <input type="file" id="image-upload" accept="image/*" style="display: none;">
            </label>
            <p style="opacity: 0.7;">or drag and drop an image here</p>
        </div>

        <div class="canvas-container">
            <canvas id="image-canvas"></canvas>
        </div>

        <div class="controls">
            <!-- Border Thickness -->
            <div class="control-group">
                <h3>Border Thickness</h3>
                <div class="slider-container">
                    <input type="range" id="border-slider" min="0" max="5000" value="50">
                    <span id="thickness-value">50px</span>
                </div>
            </div>

            <!-- Border Color & Values -->
            <div class="control-group">
                <h3>Border Color</h3>
                <div class="color-info-group">
                    <div class="color-display-row">
                        <!-- Color picker is functional, but user is constrained to B/W here. 
                             Keeping the picker allows for visual feedback, but we snap the value. -->
                        <input type="color" id="color-picker" value="#000000" class="color-picker-input">
                        <div class="color-value-box">
                            <span id="selected-color-hex" class="color-value-text">#000000</span>
                            <button class="copy-button btn-base" data-copy-target="selected-color-hex">Copy</button>
                        </div>
                    </div>
                    <div class="color-display-row justify-end">
                         <div class="color-value-box">
                            <span id="selected-color-rgb" class="color-value-text">RGB(0, 0, 0)</span>
                            <button class="copy-button btn-base" data-copy-target="selected-color-rgb">Copy</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Export Controls -->
            <div class="export-controls">
                <h3>Export Settings</h3>
                <div class="control-group">
                    <div class="slider-container">
                        <label for="quality-slider" class="text-sm">JPEG Quality (100% is best)</label>
                        <input type="range" id="quality-slider" min="10" max="100" value="95">
                        <span id="quality-value">95%</span>
                    </div>
                </div>
                
                <div class="export-buttons">
                    <button id="export-png" class="btn-base" disabled>Export PNG</button>
                    <button id="export-jpeg" class="btn-base" disabled>Export JPEG</button>
                </div>
            </div>
        </div>

        <p id="message-box" class="description">Upload an image to start editing.</p>
    </div>

    <script>
        // --- Global State and Elements ---
        const canvas = document.getElementById('image-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const uploadInput = document.getElementById('image-upload');
        const borderSlider = document.getElementById('border-slider');
        const thicknessValue = document.getElementById('thickness-value');
        const colorPicker = document.getElementById('color-picker');
        const colorHex = document.getElementById('selected-color-hex');
        const colorRgb = document.getElementById('selected-color-rgb');
        const exportPngButton = document.getElementById('export-png');
        const exportJpegButton = document.getElementById('export-jpeg');
        const qualitySlider = document.getElementById('quality-slider');
        const qualityValue = document.getElementById('quality-value');
        const messageBox = document.getElementById('message-box');
        const uploadArea = document.getElementById('upload-area');
        
        let originalImage = null;
        let borderThickness = parseInt(borderSlider.value, 10);
        let borderColor = colorPicker.value;
        let currentRgb = { r: 0, g: 0, b: 0 };
        let jpegQuality = parseInt(qualitySlider.value, 10) / 100;

        // --- Utility Functions ---

        /**
         * Converts an RGBA color array (0-255) to a hexadecimal string.
         * @param {number} r, g, b - Color values (0-255).
         * @returns {string} Hex color string (#RRGGBB).
         */
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }

        /**
         * Converts an RGB object to an RGB string.
         * @param {{r: number, g: number, b: number}} rgbObj - RGB color object.
         * @returns {string} RGB string (e.g., "RGB(255, 0, 0)").
         */
        function rgbToString(rgbObj) {
            return `RGB(${rgbObj.r}, ${rgbObj.g}, ${rgbObj.b})`;
        }

        /**
         * Converts a hex string to an RGB object.
         * @param {string} hex - Hex color string (#RRGGBB).
         * @returns {{r: number, g: number, b: number}} RGB object.
         */
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        }
        
        /**
         * Handles copying text to the clipboard using execCommand (reliable in iframes).
         * @param {string} text - The text content to copy.
         */
        function copyText(text, buttonElement) {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            
            try {
                document.execCommand('copy');
                const originalText = buttonElement.textContent;
                buttonElement.textContent = 'COPIED!';
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                }, 1500);
            } catch (err) {
                messageBox.textContent = 'Copy failed. Try manually selecting the text.';
            } finally {
                document.body.removeChild(tempInput);
            }
        }


        // --- Core Drawing & Update Functions ---

        /**
         * Core drawing function: draws the image and the border.
         * This function is called whenever the color or thickness changes.
         */
        function drawWithBorder() {
            if (!originalImage) return;

            const w = originalImage.width;
            const h = originalImage.height;
            const t = borderThickness;

            // Calculate new canvas size to accommodate the border externally
            const newWidth = w + 2 * t;
            const newHeight = h + 2 * t;

            // Update canvas dimensions (internal pixels)
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Draw the border (fills the entire new canvas)
            ctx.fillStyle = borderColor;
            ctx.fillRect(0, 0, newWidth, newHeight);

            // Draw the original image, offset by the border thickness
            ctx.drawImage(originalImage, t, t, w, h);
        }

        /**
         * Forces the color to either black or white, based on which it is closer to.
         * This maintains the monochrome constraint while allowing color picking/input.
         * @param {string} hex - The input color in hex format (#RRGGBB).
         * @returns {string} Either '#000000' or '#FFFFFF'.
         */
        function snapToMonochrome(hex) {
            const rgb = hexToRgb(hex);
            // Simple luminosity check: average R, G, B
            const avg = (rgb.r + rgb.g + rgb.b) / 3;
            return avg > 127 ? '#FFFFFF' : '#000000';
        }

        /**
         * Updates the border color and related UI elements (HEX and RGB).
         * @param {string} color - The new color in hex format (#RRGGBB).
         */
        function updateBorderColor(color) {
            // Apply monochrome constraint
            const monochromeColor = snapToMonochrome(color);
            
            borderColor = monochromeColor;
            currentRgb = hexToRgb(monochromeColor);
            
            // Update UI elements
            colorHex.textContent = monochromeColor.toUpperCase();
            colorRgb.textContent = rgbToString(currentRgb);
            colorPicker.value = monochromeColor; // Ensure the native picker reflects the new color
            
            drawWithBorder();
        }


        // --- Event Handlers ---

        function setupImageUpload() {
            uploadInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // Clear any lingering highlight class from drag/drop
                uploadArea.classList.remove('upload-area-highlight');

                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        exportPngButton.disabled = false;
                        exportJpegButton.disabled = false;
                        
                        // Set the canvas CSS display size for responsive view
                        const aspectRatio = img.width / img.height;
                        canvas.style.height = `${canvas.offsetWidth / aspectRatio}px`;

                        drawWithBorder(); // Initial draw
                        messageBox.textContent = 'Image loaded! Click on the image to sample a color for the border.';
                    };
                    img.onerror = () => {
                        messageBox.textContent = 'Error loading image.';
                    }
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function setupControls() {
            // Border Slider
            borderSlider.addEventListener('input', (e) => {
                borderThickness = parseInt(e.target.value, 10);
                thicknessValue.textContent = `${borderThickness}px`;
                drawWithBorder(); // Real-time update
            });

            // Color Picker Input
            colorPicker.addEventListener('input', (e) => {
                updateBorderColor(e.target.value);
                messageBox.textContent = `Border color set to ${borderColor.toUpperCase()}`;
            });

            // Quality Slider
            qualitySlider.addEventListener('input', (e) => {
                jpegQuality = parseInt(e.target.value, 10) / 100;
                qualityValue.textContent = `${e.target.value}%`;
                messageBox.textContent = `JPEG Quality set to ${e.target.value}%`;
            });
            
            // Copy Buttons
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const targetId = e.target.getAttribute('data-copy-target');
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        copyText(targetElement.textContent, e.target);
                    }
                });
            });
        }

        function setupCanvasInteraction() {
            // Mouse click to pick color
            canvas.addEventListener('click', handleColorPick);
            // Touch tap to pick color
            canvas.addEventListener('touchend', handleColorPick);

            // Prevent unwanted drag/context menu
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function handleColorPick(e) {
            if (!originalImage) return;
            
            // Get correct coordinates from touch or mouse event
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);

            if (clientX === undefined || clientY === undefined) return;

            const rect = canvas.getBoundingClientRect();
            
            // Scaling logic: Map CSS display coordinates to Canvas internal drawing buffer coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((clientX - rect.left) * scaleX);
            const y = Math.floor((clientY - rect.top) * scaleY);
            
            // Get the pixel data at the clicked position
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            
            // Convert to hex (pixel[3] is alpha, ignoring it)
            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
            
            // Update color (this will snap to B/W due to updateBorderColor)
            updateBorderColor(hex);
            
            messageBox.textContent = `Color sampled. Border set to ${borderColor.toUpperCase()}.`;
        }
        
        function setupExportButtons() {
            // PNG Export (Lossless)
            exportPngButton.addEventListener('click', () => {
                if (!originalImage) return;
                exportImage('image/png', 1.0, 'png');
            });

            // JPEG Export (Compressed, Quality Controlled)
            exportJpegButton.addEventListener('click', () => {
                if (!originalImage) return;
                exportImage('image/jpeg', jpegQuality, 'jpg');
            });
        }
        
        /**
         * Handles the actual image export.
         * @param {string} mimeType - 'image/png' or 'image/jpeg'.
         * @param {number} quality - Quality level (0.0 to 1.0) for JPEG. Ignored for PNG.
         * @param {string} extension - File extension ('png' or 'jpg').
         */
        function exportImage(mimeType, quality, extension) {
            try {
                const link = document.createElement('a');
                link.download = `bordered-image-monochrome-${Date.now()}.${extension}`;
                
                // canvas.toDataURL requires the MIME type and quality (for JPEG)
                link.href = canvas.toDataURL(mimeType, quality);

                // Simulate a click on the link to trigger the download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                messageBox.textContent = `Image exported successfully as ${extension.toUpperCase()}!`;
            } catch (error) {
                messageBox.textContent = 'Export failed. Check console for details.';
                console.error('Export Error:', error);
            }
        }

        function setupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, highlight, false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, unhighlight, false);
            });
            uploadArea.addEventListener('drop', handleDrop, false);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            function highlight() {
                uploadArea.classList.add('upload-area-highlight');
            }
            function unhighlight() {
                uploadArea.classList.remove('upload-area-highlight');
            }
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    uploadInput.files = files;
                    const event = new Event('change');
                    uploadInput.dispatchEvent(event);
                }
            }
        }
        
        function drawInitialPlaceholder() {
            // Initial appearance reset
            canvas.width = 300;
            canvas.height = 150;
            ctx.fillStyle = '#000000'; 
            ctx.fillRect(0, 0, 300, 150);
            ctx.font = '16px Inter';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('Upload an image to start editing.', 150, 75);
        }

        // --- Initialization ---
        function init() {
            drawInitialPlaceholder();
            setupImageUpload();
            setupControls();
            setupCanvasInteraction();
            setupExportButtons();
            setupDragAndDrop();
        }

        // Start everything when the window is ready
        window.onload = init;

    </script>
</body>
</html>
