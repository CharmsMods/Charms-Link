<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Color Fader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Grayscale Theme - Using only #000000, #FFFFFF, and shades in between */

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #000000 !important;
            color: #ffffff !important;
            min-height: 100vh;
        }

        /* Canvas styling */
        .canvas-container {
            background: #000000;
            border-radius: 0.75rem;
            padding: 1rem;
            border: 2px solid #ffffff;
        }

        canvas {
            background-color: #ffffff;
            max-width: 100%;
            max-height: 75vh;
            width: auto;
            height: auto;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            margin: 0 auto;
        }

        /* File input styling */
        input[type="file"] {
            display: none;
        }

        .custom-file-upload {
            display: inline-flex;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: #666666;
            color: #ffffff;
            border: 2px solid #999999;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            font-size: 0.875rem;
        }

        .custom-file-upload:hover {
            background: #555555;
            border-color: #888888;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        /* Action buttons */
        .action-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        .bg-gray-600 {
            background-color: #666666;
        }

        .hover\:bg-gray-700:hover {
            background-color: #555555;
        }

        /* Control sections */
        .control-section {
            margin-bottom: 0.5rem;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Toggle switches */
        .toggle-container {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .toggle-input {
            appearance: none;
            width: 2.5rem;
            height: 1.25rem;
            background-color: #000000;
            border-radius: 0.625rem;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 0.75rem;
            border: 2px solid #ffffff;
        }

        .toggle-input:checked {
            background-color: #cccccc;
            border-color: #999999;
        }

        .toggle-input.disabled {
            background-color: #000000;
            border-color: #ffffff;
            cursor: not-allowed;
            opacity: 0.3;
        }

        .toggle-input.disabled:checked {
            background-color: #000000;
            border-color: #ffffff;
        }

        .toggle-container.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .toggle-input::before {
            content: '';
            position: absolute;
            width: 0.875rem;
            height: 0.875rem;
            border-radius: 50%;
            background-color: white;
            top: 50%;
            left: 0.125rem;
            transform: translateY(-50%);
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-input:checked::before {
            transform: translateY(-50%) translateX(1.25rem);
        }

        .toggle-input.disabled::before {
            background-color: #ffffff;
            opacity: 0.5;
        }

        .toggle-label {
            font-size: 0.875rem;
            color: #ffffff;
            font-weight: 500;
        }

        /* Custom sliders */
        .slider-container {
            margin-top: 0.5rem;
        }

        .custom-slider {
            width: 100%;
            height: 0.375rem;
            border-radius: 0.1875rem;
            background: #ffffff;
            outline: none;
            appearance: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .custom-slider::-webkit-slider-thumb {
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            background: #cccccc;
            cursor: pointer;
            border: 2px solid #000000;
            box-shadow: 0 2px 6px rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .custom-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.5);
        }

        .custom-slider::-moz-range-thumb {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            background: #cccccc;
            cursor: pointer;
            border: 2px solid #000000;
            box-shadow: 0 2px 6px rgba(255, 255, 255, 0.3);
        }

        /* Color picker */
        .color-picker {
            width: 2.5rem;
            height: 2rem;
            border: 2px solid #ffffff;
            border-radius: 0.375rem;
            cursor: pointer;
            background: none;
            transition: border-color 0.3s ease;
        }

        .color-picker:hover {
            border-color: #cccccc;
        }

        /* Copy buttons */
        .copy-btn {
            padding: 0.25rem 0.5rem;
            background: #000000;
            color: #cccccc;
            border: 1px solid #ffffff;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: #ffffff;
            border-color: #cccccc;
            color: #000000;
        }

        /* Message styling */
        #message-box {
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #message-box.bg-green-100 {
            background: rgba(255, 255, 255, 0.1);
            border-color: #ffffff;
            color: #ffffff;
        }

        #message-box.bg-red-100 {
            background: rgba(0, 0, 0, 0.1);
            border-color: #ffffff;
            color: #ffffff;
        }

        #message-box.bg-blue-100 {
            background: rgba(128, 128, 128, 0.1);
            border-color: #ffffff;
            color: #ffffff;
        }

        /* Responsive adjustments */
        @media (max-width: 1280px) {
            .canvas-container {
                margin-bottom: 2rem;
            }
        }

        @media (max-width: 640px) {
            .custom-file-upload {
                width: 100%;
                justify-content: center;
                margin-bottom: 1rem;
            }

            .action-btn {
                flex: 1;
            }
        }

        /* New styles for refactored UI */
        .accordion-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 0;
        }

        .accordion.active .accordion-content {
            max-height: 1000px;
        }

        .shape-controls {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 0;
        }

        .shape-controls.active {
            max-height: 2000px;
        }

        .arrow {
            transition: transform 0.3s ease;
        }

        .accordion.active .arrow {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="message-box" class="fixed top-4 left-4 z-50 hidden p-4 text-sm rounded-lg shadow-lg max-w-sm" role="alert">
        <span class="font-medium" id="message-text"></span>
    </div>

    <div id="performance-warning" class="fixed top-4 right-4 z-50 hidden p-4 text-sm rounded-lg shadow-lg max-w-sm bg-gray-800 border border-gray-600 text-gray-200" role="alert">
        <div class="flex items-start">
            <div class="flex-shrink-0">
                <svg class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                </svg>
            </div>
            <div class="ml-3">
                <h3 class="text-sm font-medium">Performance Mode</h3>
                <p class="mt-1 text-xs">Real-time preview disabled due to slow processing. Use the Preview button to see changes, or re-enable real-time mode if desired.</p>
                <button id="dismiss-warning" class="mt-2 text-xs text-gray-400 hover:text-gray-300 underline">Dismiss</button>
            </div>
        </div>
    </div>

    <header class="bg-black border-b border-white py-6">
        <div class="container mx-auto px-6">
            <h1 class="text-3xl font-bold text-center text-white">Image Color Fader</h1>
        </div>
    </header>

    <div class="container mx-auto px-6 py-8 max-w-7xl">
        <!-- Canvas above -->
        <div class="bg-black rounded-lg p-6 border border-white mb-8">
            <div class="flex flex-col sm:flex-row items-center justify-between mb-6 gap-4">
                <label for="imageUpload" class="custom-file-upload">
                    Upload Image
                </label>
                <input type="file" id="imageUpload" accept="image/*">

                <div class="flex gap-3 flex-wrap">
                    <button id="previewButton" class="action-btn bg-gray-600 hover:bg-gray-700 hidden">
                        Preview
                    </button>
                    <button id="resetButton" class="action-btn bg-gray-600 hover:bg-gray-700">
                        Reset
                    </button>
                    <button id="applyButton" class="action-btn bg-gray-600 hover:bg-gray-700">
                        Apply
                    </button>
                    <button id="downloadButton" class="action-btn bg-gray-600 hover:bg-gray-700">
                        Download
                    </button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="imageCanvas" class="w-full h-auto"></canvas>
            </div>
        </div>

        <!-- Controls below in grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <div class="bg-black rounded-lg p-6 border border-white">
                <h2 class="text-xl font-semibold text-white mb-6">Color Tools</h2>

                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Preview <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <label class="toggle-container">
                            <input type="checkbox" id="realtimePreviewToggle" class="toggle-input" checked>
                            <span class="toggle-label">Real-time Preview</span>
                        </label>
                        <p class="text-xs text-white opacity-70 mt-2">Updates preview as you adjust settings</p>
                    </div>
                </div>

                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Selected Color <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <div class="flex items-center space-x-3 mb-3">
                            <div id="colorSwatch" class="w-12 h-12 border-2 border-white rounded-lg shadow-sm" style="background-color: #ffffff;"></div>
                            <div class="flex-1">
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-sm text-white">Hex: <span id="hexDisplay" class="text-white font-mono">#FFFFFF</span></span>
                                    <button id="copyHexButton" class="copy-btn" title="Copy hex value">Copy</button>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm text-white">RGB: <span id="rgbDisplay" class="text-white font-mono">rgb(255, 255, 255)</span></span>
                                    <button id="copyRgbButton" class="copy-btn" title="Copy RGB value">Copy</button>
                                </div>
                                <div class="mt-2">
                                    <span class="text-sm text-white">Resolution: <span id="resolutionDisplay" class="text-white font-mono">No image</span></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Selection Mode <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <div class="space-y-3">
                            <label class="toggle-container">
                                <input type="checkbox" id="areaSelectionToggle" class="toggle-input">
                                <span class="toggle-label">Area Selection (Flood Fill)</span>
                            </label>
                            <p class="text-xs text-white opacity-70 mt-2">Target only the connected area you click on.</p>
                        </div>
                    </div>
                </div>
                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Mode <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <div class="space-y-3">
                            <label class="toggle-container">
                                <input type="checkbox" id="colorReplacementToggle" class="toggle-input">
                                <span class="toggle-label">Replace with Color</span>
                            </label>
                            <div id="colorPickerContainer" class="hidden pl-6">
                                <div class="flex items-center space-x-3">
                                    <input type="color" id="replacementColorPicker" value="#ff0000" class="color-picker">
                                    <span class="text-sm text-white">Color: <span id="replacementColorDisplay" class="text-white font-mono">#FF0000</span></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Opacity <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <div class="slider-container">
                            <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="0" class="custom-slider">
                            <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                <span>0%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Tolerance <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <label class="toggle-container">
                            <input type="checkbox" id="toleranceToggle" class="toggle-input" checked>
                            <span class="toggle-label">Enable Tolerance Mode</span>
                        </label>
                        <div id="toleranceSliderContainer" class="mt-3 pl-6">
                            <div class="slider-container">
                                <label class="text-sm text-white mb-2 block">Strength</label>
                                <input type="range" id="toleranceStrengthSlider" min="0" max="100" step="1" value="20" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>Low</span>
                                    <span>High</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Selection <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <label class="toggle-container">
                            <input type="checkbox" id="invertSelectionToggle" class="toggle-input">
                            <span class="toggle-label">Invert Selection</span>
                        </label>
                         <p class="text-xs text-white opacity-70 mt-2">Applies effect to all colors EXCEPT the selection.</p>
                    </div>
                </div>

                <div class="accordion control-section">
                    <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                        Edge Smoothing <span class="arrow">▼</span>
                    </h3>
                    <div class="accordion-content">
                        <label class="toggle-container">
                            <input type="checkbox" id="antiAliasingToggle" class="toggle-input" checked>
                            <span class="toggle-label">Enable Edge Smoothing</span>
                        </label>
                        <div id="smoothingSliderContainer" class="mt-3 pl-6">
                            <div class="slider-container">
                                <label class="text-sm text-white mb-2 block">Factor</label>
                                <input type="range" id="smoothingFactorSlider" min="0.1" max="1.0" step="0.05" value="1.0" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>Sharp</span>
                                    <span>Smooth</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bg-black rounded-lg p-6 border border-white">
                <h2 class="text-xl font-semibold text-white mb-6">Shape Tools</h2>
                <label class="toggle-container mb-4">
                    <input type="checkbox" id="shapeModeToggle" class="toggle-input">
                    <span class="toggle-label">Enable Shape Replace Mode</span>
                </label>
                <p class="text-xs text-white opacity-70 mt-2 mb-4">Replace or erase parts of the image with a shape. In this mode, clicks pick replacement color.</p>

                <div id="shapeControls" class="shape-controls">
                    <div class="accordion control-section">
                        <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                            Shape Type <span class="arrow">▼</span>
                        </h3>
                        <div class="accordion-content">
                            <select id="shapeTypeSelect" class="bg-black border border-white text-white p-2 rounded-lg w-full">
                                <option value="rectangle">Rectangle</option>
                                <option value="ellipse">Ellipse</option>
                            </select>
                        </div>
                    </div>

                    <div class="accordion control-section">
                        <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                            Position (Center) <span class="arrow">▼</span>
                        </h3>
                        <div class="accordion-content">
                            <div class="slider-container mb-4">
                                <label class="text-sm text-white mb-2 block">X</label>
                                <input type="range" id="shapeXSlider" min="0" max="0" step="1" value="0" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>0</span>
                                    <span id="shapeXMax">0</span>
                                </div>
                            </div>
                            <div class="slider-container">
                                <label class="text-sm text-white mb-2 block">Y</label>
                                <input type="range" id="shapeYSlider" min="0" max="0" step="1" value="0" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>0</span>
                                    <span id="shapeYMax">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="accordion control-section">
                        <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                            Dimensions <span class="arrow">▼</span>
                        </h3>
                        <div class="accordion-content">
                            <div class="slider-container mb-4">
                                <label class="text-sm text-white mb-2 block">Width</label>
                                <input type="range" id="shapeWidthSlider" min="10" max="8000" step="1" value="50" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>10</span>
                                    <span>8000</span>
                                </div>
                            </div>
                            <div class="slider-container">
                                <label class="text-sm text-white mb-2 block">Height</label>
                                <input type="range" id="shapeHeightSlider" min="10" max="8000" step="1" value="50" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>10</span>
                                    <span>8000</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="accordion control-section">
                        <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                            Falloff Fade <span class="arrow">▼</span>
                        </h3>
                        <div class="accordion-content">
                            <div class="slider-container">
                                <input type="range" id="falloffSlider" min="0" max="200" step="1" value="0" class="custom-slider">
                                <div class="flex justify-between text-xs text-white opacity-70 mt-1">
                                    <span>Hard</span>
                                    <span>Soft</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="accordion control-section">
                        <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                            Replacement <span class="arrow">▼</span>
                        </h3>
                        <div class="accordion-content">
                            <label class="toggle-container">
                                <input type="checkbox" id="shapeEraseToggle" class="toggle-input">
                                <span class="toggle-label">Erase (Transparent)</span>
                            </label>
                            <div id="shapeColorPickerContainer" class="mt-3 pl-6">
                                <div class="flex items-center space-x-3">
                                    <input type="color" id="shapeReplacementColorPicker" value="#ff0000" class="color-picker">
                                    <span class="text-sm text-white">Color: <span id="shapeReplacementColorDisplay" class="text-white font-mono">#FF0000</span></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="accordion control-section">
                        <h3 class="accordion-header control-title cursor-pointer flex justify-between items-center">
                            Shape Preview <span class="arrow">▼</span>
                        </h3>
                        <div class="accordion-content">
                            <label class="toggle-container">
                                <input type="checkbox" id="shapeRealtimeToggle" class="toggle-input" checked>
                                <span class="toggle-label">Real-time Shape Preview</span>
                            </label>
                            <p class="text-xs text-white opacity-70 mt-2">Updates on every slider move (may be slow for large shapes).</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Image Color Fader - Updated JavaScript

        // DOM elements...
        const imageUpload = document.getElementById('imageUpload');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d', { willReadFrequently: true });
        const opacitySlider = document.getElementById('opacitySlider');
        const toleranceToggle = document.getElementById('toleranceToggle');
        const toleranceSliderContainer = document.getElementById('toleranceSliderContainer');
        const toleranceStrengthSlider = document.getElementById('toleranceStrengthSlider');
        const invertSelectionToggle = document.getElementById('invertSelectionToggle');
        const antiAliasingToggle = document.getElementById('antiAliasingToggle');
        const smoothingSliderContainer = document.getElementById('smoothingSliderContainer');
        const smoothingFactorSlider = document.getElementById('smoothingFactorSlider');
        const hexDisplay = document.getElementById('hexDisplay');
        const rgbDisplay = document.getElementById('rgbDisplay');
        const resolutionDisplay = document.getElementById('resolutionDisplay');
        const colorSwatch = document.getElementById('colorSwatch');
        const resetButton = document.getElementById('resetButton');
        const downloadButton = document.getElementById('downloadButton');
        const applyButton = document.getElementById('applyButton');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const copyHexButton = document.getElementById('copyHexButton');
        const copyRgbButton = document.getElementById('copyRgbButton');
        const colorReplacementToggle = document.getElementById('colorReplacementToggle');
        const colorPickerContainer = document.getElementById('colorPickerContainer');
        const replacementColorPicker = document.getElementById('replacementColorPicker');
        const replacementColorDisplay = document.getElementById('replacementColorDisplay');
        const realtimePreviewToggle = document.getElementById('realtimePreviewToggle');
        const previewButton = document.getElementById('previewButton');
        const performanceWarning = document.getElementById('performance-warning');
        const dismissWarning = document.getElementById('dismiss-warning');
        const areaSelectionToggle = document.getElementById('areaSelectionToggle');

        // Shape elements
        const shapeModeToggle = document.getElementById('shapeModeToggle');
        const shapeControls = document.getElementById('shapeControls');
        const shapeTypeSelect = document.getElementById('shapeTypeSelect');
        const shapeXSlider = document.getElementById('shapeXSlider');
        const shapeYSlider = document.getElementById('shapeYSlider');
        const shapeWidthSlider = document.getElementById('shapeWidthSlider');
        const shapeHeightSlider = document.getElementById('shapeHeightSlider');
        const falloffSlider = document.getElementById('falloffSlider');
        const shapeEraseToggle = document.getElementById('shapeEraseToggle');
        const shapeColorPickerContainer = document.getElementById('shapeColorPickerContainer');
        const shapeReplacementColorPicker = document.getElementById('shapeReplacementColorPicker');
        const shapeReplacementColorDisplay = document.getElementById('shapeReplacementColorDisplay');
        const shapeRealtimeToggle = document.getElementById('shapeRealtimeToggle');
        const shapeXMax = document.getElementById('shapeXMax');
        const shapeYMax = document.getElementById('shapeYMax');

        // Globals...
        let originalImage = new Image();
        let originalImageData = null;
        let selectedColor = null;
        let selectedAreaPixels = new Set();
        let isAreaSelectionMode = false;
        let isRealtimePreviewEnabled = true;
        let isShapeModeEnabled = false;
        let isShapeRealtimeEnabled = true;
        let performanceCheckCount = 0;
        let totalProcessingTime = 0;
        let isPerformanceModeActive = false;

        let shapeCenterX = 0;
        let shapeCenterY = 0;
        let shapeWidth = 50;
        let shapeHeight = 50;
        let falloff = 0;
        let shapeType = 'rectangle';
        let isShapeErase = false;
        let shapeReplacementColor = { r: 255, g: 0, b: 0 };

        // Utilities...
        function showMessage(message, type) {
            messageBox.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-blue-100', 'text-blue-800');
            messageText.textContent = message;

            if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-800');
            } else {
                messageBox.classList.add('bg-blue-100', 'text-blue-800');
            }

            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000);
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function colorDistance(color1, color2) {
            const dr = color1.r - color2.r;
            const dg = color1.g - color2.g;
            const db = color1.b - color2.b;
            const rWeight = 0.3;
            const gWeight = 0.59;
            const bWeight = 0.11;
            return Math.sqrt(rWeight * dr * dr + gWeight * dg * dg + bWeight * db * db);
        }

        function applyOpacityGamma(opacity) {
            return Math.pow(opacity, 2.2);
        }

        function smoothInterpolation(t, smoothingFactor) {
            t = Math.max(0, Math.min(1, t));
            if (smoothingFactor <= 0.3) {
                return (1 - Math.cos(t * Math.PI)) / 2;
            } else if (smoothingFactor <= 0.7) {
                return t * t * (3 - 2 * t);
            } else {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
        }

        function runFloodFill(startX, startY, targetColor, toleranceRadius) {
            if (!originalImageData) return;
            selectedAreaPixels.clear();
            const width = originalImageData.width;
            const height = originalImageData.height;
            const visited = new Array(width * height).fill(false);
            const queue = [{ x: startX, y: startY }];
            const getIndex = (x, y) => y * width + x;
            const getColorAtIndex = (index) => {
                const data = originalImageData.data;
                return { r: data[index * 4], g: data[index * 4 + 1], b: data[index * 4 + 2] };
            };
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                const index = getIndex(x, y);
                if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) continue;
                const currentColor = getColorAtIndex(index);
                const distance = colorDistance(targetColor, currentColor);
                if (distance <= toleranceRadius) {
                    visited[index] = true;
                    selectedAreaPixels.add(`${x},${y}`);
                    queue.push({ x: x + 1, y: y });
                    queue.push({ x: x - 1, y: y });
                    queue.push({ x: x, y: y + 1 });
                    queue.push({ x: x, y: y - 1 });
                }
            }
        }

        function applyShapeReplacement(imageData) {
            if (!isShapeModeEnabled) return imageData;

            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const halfWidth = shapeWidth / 2;
            const halfHeight = shapeHeight / 2;
            const minX = Math.max(0, Math.floor(shapeCenterX - halfWidth - falloff));
            const maxX = Math.min(width - 1, Math.ceil(shapeCenterX + halfWidth + falloff));
            const minY = Math.max(0, Math.floor(shapeCenterY - halfHeight - falloff));
            const maxY = Math.min(height - 1, Math.ceil(shapeCenterY + halfHeight + falloff));

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const i = (y * width + x) * 4;
                    let effectFactor = 0;

                    let dx = (x - shapeCenterX) / halfWidth;
                    let dy = (y - shapeCenterY) / halfHeight;

                    let dist;
                    if (shapeType === 'rectangle') {
                        dist = Math.max(Math.abs(dx), Math.abs(dy));
                    } else {
                        dist = Math.sqrt(dx * dx + dy * dy);
                    }

                    if (dist <= 1) {
                        effectFactor = 1;
                    } else if (falloff > 0 && dist <= 1 + (falloff / Math.min(halfWidth, halfHeight))) {
                        const fadeProgress = (dist - 1) / (falloff / Math.min(halfWidth, halfHeight));
                        effectFactor = 1 - smoothInterpolation(fadeProgress, 0.5);
                    }

                    if (effectFactor > 0) {
                        if (isShapeErase) {
                            data[i + 3] = Math.round(data[i + 3] * (1 - effectFactor));
                        } else {
                            data[i] = Math.round(data[i] + (shapeReplacementColor.r - data[i]) * effectFactor);
                            data[i + 1] = Math.round(data[i + 1] + (shapeReplacementColor.g - data[i + 1]) * effectFactor);
                            data[i + 2] = Math.round(data[i + 2] + (shapeReplacementColor.b - data[i + 2]) * effectFactor);
                        }
                    }
                }
            }

            return imageData;
        }

        function applyFilter(forceUpdate = false) {
            if (!isRealtimePreviewEnabled && !forceUpdate) return;

            const startTime = performance.now();
            if (!originalImageData) {
                if (originalImage.src) {
                    ctx.drawImage(originalImage, 0, 0);
                }
                return;
            }

            let imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );

            imageData = applyShapeReplacement(imageData);

            if (selectedColor) {
                const data = imageData.data;
                const sliderVal = parseFloat(opacitySlider.value);
                const isToleranceMode = toleranceToggle.checked;
                const isInverted = invertSelectionToggle.checked;
                const currentToleranceRadius = parseFloat(toleranceStrengthSlider.value);
                const isColorReplacement = colorReplacementToggle.checked;
                const replacementColor = isColorReplacement ? hexToRgb(replacementColorPicker.value) : null;
                const isAntiAliasing = antiAliasingToggle.checked;
                isAreaSelectionMode = areaSelectionToggle.checked;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const originalAlpha = originalImageData.data[i + 3];

                    let effectFactor = 0;

                    if (isAreaSelectionMode) {
                        const x = (i / 4) % imageData.width;
                        const y = Math.floor((i / 4) / imageData.width);
                        const pixelKey = `${x},${y}`;
                        const isSelectedPixel = selectedAreaPixels.has(pixelKey);

                        if (isSelectedPixel) {
                            if (isAntiAliasing && isToleranceMode && currentToleranceRadius > 0) {
                                const currentPixelColor = { r, g, b };
                                const distance = colorDistance(selectedColor, currentPixelColor);
                                if (distance <= currentToleranceRadius) {
                                    const smoothingFactor = parseFloat(smoothingFactorSlider.value);
                                    const fadeZone = currentToleranceRadius * smoothingFactor;
                                    const coreZone = currentToleranceRadius - fadeZone;
                                    if (distance <= coreZone) {
                                        effectFactor = isInverted ? 0 : 1;
                                    } else {
                                        const fadeProgress = (distance - coreZone) / fadeZone;
                                        const smoothProgress = smoothInterpolation(fadeProgress, smoothingFactor);
                                        effectFactor = isInverted ? smoothProgress : (1 - smoothProgress);
                                    }
                                } else {
                                    effectFactor = isInverted ? 0 : 1;
                                }
                            } else {
                                effectFactor = isInverted ? 0 : 1;
                            }
                        } else {
                            effectFactor = isInverted ? 1 : 0;
                        }
                    } else {
                        const currentPixelColor = { r, g, b };
                        const distance = isToleranceMode 
                            ? colorDistance(selectedColor, currentPixelColor) 
                            : (r === selectedColor.r && g === selectedColor.g && b === selectedColor.b ? 0 : Infinity);
                        if (isToleranceMode) {
                            if (distance <= currentToleranceRadius) {
                                if (isAntiAliasing && currentToleranceRadius > 0) {
                                    const smoothingFactor = parseFloat(smoothingFactorSlider.value);
                                    const fadeZone = currentToleranceRadius * smoothingFactor;
                                    const coreZone = currentToleranceRadius - fadeZone;
                                    if (distance <= coreZone) {
                                        effectFactor = isInverted ? 0 : 1;
                                    } else {
                                        const fadeProgress = (distance - coreZone) / fadeZone;
                                        const smoothProgress = smoothInterpolation(fadeProgress, smoothingFactor);
                                        effectFactor = isInverted ? smoothProgress : (1 - smoothProgress);
                                    }
                                } else {
                                    effectFactor = isInverted ? 0 : 1;
                                }
                            } else {
                                effectFactor = isInverted ? 1 : 0;
                            }
                        } else {
                            effectFactor = (distance === 0) ? (isInverted ? 0 : 1) : (isInverted ? 1 : 0);
                        }
                    }

                    if (effectFactor > 0) {
                        if (isColorReplacement) {
                            data[i] = Math.round(r + (replacementColor.r - r) * effectFactor);
                            data[i + 1] = Math.round(g + (replacementColor.g - g) * effectFactor);
                            data[i + 2] = Math.round(b + (replacementColor.b - b) * effectFactor);
                            data[i + 3] = originalAlpha;
                        } else {
                            const correctedOpacity = applyOpacityGamma(sliderVal);
                            data[i + 3] = originalAlpha * (1 - (correctedOpacity * effectFactor));
                        }
                    } else {
                        data[i + 3] = originalAlpha;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            const endTime = performance.now();
            const processingTime = endTime - startTime;

            if (isRealtimePreviewEnabled && !forceUpdate) {
                performanceCheckCount++;
                totalProcessingTime += processingTime;
                if (processingTime > 750) {
                    showPerformanceWarning();
                } else if (performanceCheckCount >= 2) {
                    const averageTime = totalProcessingTime / performanceCheckCount;
                    if (averageTime > 750) {
                        showPerformanceWarning();
                    }
                    performanceCheckCount = 0;
                    totalProcessingTime = 0;
                }
            }
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                originalImage = new Image();
                originalImage.onload = function () {
                    imageCanvas.width = originalImage.width;
                    imageCanvas.height = originalImage.height;
                    resolutionDisplay.textContent = `${originalImage.width} × ${originalImage.height}`;
                    ctx.drawImage(originalImage, 0, 0);
                    originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                    showMessage('Image loaded successfully! Click on the image to pick a color or enable Shape Mode.', 'success');

                    selectedColor = null;
                    opacitySlider.value = 0;
                    toleranceToggle.checked = true;
                    toleranceSliderContainer.classList.remove('hidden');
                    toleranceStrengthSlider.value = 20;
                    invertSelectionToggle.checked = false;
                    antiAliasingToggle.checked = true;
                    smoothingSliderContainer.classList.remove('hidden');
                    smoothingFactorSlider.value = 1.0;
                    colorReplacementToggle.checked = false;
                    colorPickerContainer.classList.add('hidden');
                    replacementColorPicker.value = '#ff0000';
                    replacementColorDisplay.textContent = '#FF0000';
                    areaSelectionToggle.checked = false;
                    selectedAreaPixels.clear();
                    hexDisplay.textContent = '#FFFFFF';
                    rgbDisplay.textContent = 'rgb(255, 255, 255)';
                    colorSwatch.style.backgroundColor = '#FFFFFF';

                    isShapeModeEnabled = false;
                    shapeModeToggle.checked = false;
                    shapeControls.classList.remove('active');
                    shapeTypeSelect.value = 'rectangle';
                    shapeXSlider.max = originalImage.width;
                    shapeXSlider.value = originalImage.width / 2;
                    shapeYSlider.max = originalImage.height;
                    shapeYSlider.value = originalImage.height / 2;
                    shapeXMax.textContent = originalImage.width;
                    shapeYMax.textContent = originalImage.height;
                    shapeWidthSlider.value = 50;
                    shapeHeightSlider.value = 50;
                    falloffSlider.value = 0;
                    shapeEraseToggle.checked = false;
                    shapeReplacementColorPicker.value = '#ff0000';
                    shapeReplacementColorDisplay.textContent = '#FF0000';
                    shapeRealtimeToggle.checked = true;

                    isRealtimePreviewEnabled = true;
                    realtimePreviewToggle.checked = true;
                    realtimePreviewToggle.classList.remove('disabled');
                    realtimePreviewToggle.parentElement.classList.remove('disabled');
                    previewButton.classList.add('hidden');
                    hidePerformanceWarning();
                    performanceCheckCount = 0;
                    totalProcessingTime = 0;
                    isPerformanceModeActive = false;

                    updateShapeState();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Updated pickColor to handle shape mode
        function pickColor(event) {
            if (!originalImageData) {
                showMessage('Please upload an image first.', 'info');
                return;
            }

            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const x = Math.floor((event.clientX - rect.left) * scaleX);
            const y = Math.floor((event.clientY - rect.top) * scaleY);

            const pixel = ctx.getImageData(x, y, 1, 1).data;
            const pickedColor = { r: pixel[0], g: pixel[1], b: pixel[2] };

            if (isShapeModeEnabled) {
                // In shape mode, click picks replacement color for shape
                shapeReplacementColor = pickedColor;
                const hex = rgbToHex(pickedColor.r, pickedColor.g, pickedColor.b);
                shapeReplacementColorPicker.value = hex;
                shapeReplacementColorDisplay.textContent = hex.toUpperCase();
                showMessage('Replacement color picked for shape!', 'info');
                applyFilter(true);
            } else {
                // Normal mode
                selectedColor = pickedColor;
                hexDisplay.textContent = rgbToHex(selectedColor.r, selectedColor.g, selectedColor.b);
                rgbDisplay.textContent = `rgb(${selectedColor.r}, ${selectedColor.g}, ${selectedColor.b})`;
                colorSwatch.style.backgroundColor = `rgb(${selectedColor.r}, ${selectedColor.g}, ${selectedColor.b})`;

                isAreaSelectionMode = areaSelectionToggle.checked;

                if (isAreaSelectionMode) {
                    const currentToleranceRadius = parseFloat(toleranceStrengthSlider.value);
                    runFloodFill(x, y, selectedColor, currentToleranceRadius);
                    showMessage('Area picked! Adjust settings to see the effect.', 'info');
                } else {
                    selectedAreaPixels.clear();
                    showMessage('Color picked! Adjust settings.', 'info');
                }

                applyFilter(true);
            }
        }

        function showPerformanceWarning() {
            if (!isPerformanceModeActive) {
                isPerformanceModeActive = true;
                performanceWarning.classList.remove('hidden');
                isRealtimePreviewEnabled = false;
                realtimePreviewToggle.checked = false;
                realtimePreviewToggle.classList.add('disabled');
                realtimePreviewToggle.parentElement.classList.add('disabled');
                previewButton.classList.remove('hidden');
                showMessage('Real-time preview disabled due to performance', 'info');
            }
        }

        function hidePerformanceWarning() {
            performanceWarning.classList.add('hidden');
        }

        function toggleRealtimePreview(enabled) {
            isRealtimePreviewEnabled = enabled;
            if (enabled) {
                previewButton.classList.add('hidden');
                realtimePreviewToggle.classList.remove('disabled');
                realtimePreviewToggle.parentElement.classList.remove('disabled');
                performanceCheckCount = 0;
                totalProcessingTime = 0;
                isPerformanceModeActive = false;
            } else {
                previewButton.classList.remove('hidden');
            }
        }

        function updateShapeState(force = false) {
            shapeCenterX = parseFloat(shapeXSlider.value);
            shapeCenterY = parseFloat(shapeYSlider.value);
            shapeWidth = parseFloat(shapeWidthSlider.value);
            shapeHeight = parseFloat(shapeHeightSlider.value);
            falloff = parseFloat(falloffSlider.value);
            shapeType = shapeTypeSelect.value;
            isShapeErase = shapeEraseToggle.checked;
            shapeReplacementColor = hexToRgb(shapeReplacementColorPicker.value);

            if (isShapeModeEnabled && (isShapeRealtimeEnabled || force)) {
                applyFilter();
            }
        }

        function resetImage() {
            if (originalImage.src) {
                ctx.drawImage(originalImage, 0, 0);
                originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);

                selectedColor = null;
                opacitySlider.value = 0;
                toleranceToggle.checked = true;
                toleranceSliderContainer.classList.remove('hidden');
                toleranceStrengthSlider.value = 20;
                invertSelectionToggle.checked = false;
                antiAliasingToggle.checked = true;
                smoothingSliderContainer.classList.remove('hidden');
                smoothingFactorSlider.value = 1.0;
                colorReplacementToggle.checked = false;
                colorPickerContainer.classList.add('hidden');
                replacementColorPicker.value = '#ff0000';
                replacementColorDisplay.textContent = '#FF0000';
                areaSelectionToggle.checked = false;
                selectedAreaPixels.clear();
                hexDisplay.textContent = '#FFFFFF';
                rgbDisplay.textContent = 'rgb(255, 255, 255)';
                colorSwatch.style.backgroundColor = '#FFFFFF';

                isShapeModeEnabled = false;
                shapeModeToggle.checked = false;
                shapeControls.classList.remove('active');
                shapeTypeSelect.value = 'rectangle';
                shapeXSlider.value = imageCanvas.width / 2;
                shapeYSlider.value = imageCanvas.height / 2;
                shapeWidthSlider.value = 50;
                shapeHeightSlider.value = 50;
                falloffSlider.value = 0;
                shapeEraseToggle.checked = false;
                shapeReplacementColorPicker.value = '#ff0000';
                shapeReplacementColorDisplay.textContent = '#FF0000';
                shapeRealtimeToggle.checked = true;

                isRealtimePreviewEnabled = true;
                realtimePreviewToggle.checked = true;
                realtimePreviewToggle.classList.remove('disabled');
                realtimePreviewToggle.parentElement.classList.remove('disabled');
                previewButton.classList.add('hidden');
                hidePerformanceWarning();
                performanceCheckCount = 0;
                totalProcessingTime = 0;
                isPerformanceModeActive = false;

                showMessage('Image reset to original state.', 'info');
            } else {
                showMessage('No image loaded to reset.', 'info');
            }
        }

        function applyChanges() {
            if (!originalImageData) {
                showMessage('Please upload an image first.', 'info');
                return;
            }

            originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);

            selectedColor = null;
            opacitySlider.value = 0;
            toleranceToggle.checked = true;
            toleranceSliderContainer.classList.remove('hidden');
            toleranceStrengthSlider.value = 20;
            invertSelectionToggle.checked = false;
            antiAliasingToggle.checked = true;
            smoothingSliderContainer.classList.remove('hidden');
            smoothingFactorSlider.value = 1.0;
            colorReplacementToggle.checked = false;
            colorPickerContainer.classList.add('hidden');
            replacementColorPicker.value = '#ff0000';
            replacementColorDisplay.textContent = '#FF0000';
            areaSelectionToggle.checked = false;
            selectedAreaPixels.clear();
            hexDisplay.textContent = '#FFFFFF';
            rgbDisplay.textContent = 'rgb(255, 255, 255)';
            colorSwatch.style.backgroundColor = '#FFFFFF';

            isShapeModeEnabled = false;
            shapeModeToggle.checked = false;
            shapeControls.classList.remove('active');
            shapeTypeSelect.value = 'rectangle';
            shapeXSlider.value = imageCanvas.width / 2;
            shapeYSlider.value = imageCanvas.height / 2;
            shapeWidthSlider.value = 50;
            shapeHeightSlider.value = 50;
            falloffSlider.value = 0;
            shapeEraseToggle.checked = false;
            shapeReplacementColorPicker.value = '#ff0000';
            shapeReplacementColorDisplay.textContent = '#FF0000';
            shapeRealtimeToggle.checked = true;

            isRealtimePreviewEnabled = true;
            realtimePreviewToggle.checked = true;
            realtimePreviewToggle.classList.remove('disabled');
            realtimePreviewToggle.parentElement.classList.remove('disabled');
            previewButton.classList.add('hidden');
            hidePerformanceWarning();
            performanceCheckCount = 0;
            totalProcessingTime = 0;
            isPerformanceModeActive = false;

            showMessage('Changes applied! Ready for new edits.', 'success');
        }

        function downloadImage() {
            if (!originalImageData) {
                showMessage('Please upload and edit an image first.', 'info');
                return;
            }
            const dataURL = imageCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'edited-image.png';
            a.click();
            showMessage('Image downloaded!', 'success');
        }

        async function copyToClipboard(text, type) {
            try {
                await navigator.clipboard.writeText(text);
                showMessage(`${type} copied!`, 'success');
            } catch (err) {
                showMessage('Copy failed.', 'error');
            }
        }

        // Event listeners
        imageUpload.addEventListener('change', loadImage);
        imageCanvas.addEventListener('click', pickColor);
        opacitySlider.addEventListener('input', () => { if (isRealtimePreviewEnabled) applyFilter(); });
        toleranceToggle.addEventListener('change', () => {
            toleranceSliderContainer.classList.toggle('hidden', !toleranceToggle.checked);
            if (isRealtimePreviewEnabled) applyFilter();
        });
        toleranceStrengthSlider.addEventListener('input', () => { if (isRealtimePreviewEnabled) applyFilter(); });
        invertSelectionToggle.addEventListener('change', () => { if (isRealtimePreviewEnabled) applyFilter(); });
        antiAliasingToggle.addEventListener('change', () => {
            smoothingSliderContainer.classList.toggle('hidden', !antiAliasingToggle.checked);
            if (isRealtimePreviewEnabled) applyFilter();
        });
        smoothingFactorSlider.addEventListener('input', () => { if (isRealtimePreviewEnabled) applyFilter(); });
        resetButton.addEventListener('click', resetImage);
        downloadButton.addEventListener('click', downloadImage);
        applyButton.addEventListener('click', applyChanges);
        copyHexButton.addEventListener('click', () => copyToClipboard(hexDisplay.textContent, 'Hex'));
        copyRgbButton.addEventListener('click', () => copyToClipboard(rgbDisplay.textContent, 'RGB'));
        colorReplacementToggle.addEventListener('change', () => {
            colorPickerContainer.classList.toggle('hidden', !colorReplacementToggle.checked);
            if (isRealtimePreviewEnabled) applyFilter();
        });
        replacementColorPicker.addEventListener('input', () => {
            replacementColorDisplay.textContent = replacementColorPicker.value.toUpperCase();
            if (isRealtimePreviewEnabled) applyFilter();
        });
        realtimePreviewToggle.addEventListener('change', () => toggleRealtimePreview(realtimePreviewToggle.checked));
        previewButton.addEventListener('click', () => applyFilter(true));
        dismissWarning.addEventListener('click', hidePerformanceWarning);
        areaSelectionToggle.addEventListener('change', () => {
            if (isRealtimePreviewEnabled) applyFilter();
        });

        shapeModeToggle.addEventListener('change', () => {
            isShapeModeEnabled = shapeModeToggle.checked;
            shapeControls.classList.toggle('active', shapeModeToggle.checked);
            if (isShapeModeEnabled) {
                showMessage('Shape Mode enabled. Click image to pick replacement color.', 'info');
            } else {
                showMessage('Shape Mode disabled.', 'info');
            }
            applyFilter();
        });

        shapeTypeSelect.addEventListener('change', () => updateShapeState());
        shapeEraseToggle.addEventListener('change', () => updateShapeState());
        shapeReplacementColorPicker.addEventListener('input', () => {
            shapeReplacementColorDisplay.textContent = shapeReplacementColorPicker.value.toUpperCase();
            updateShapeState();
        });
        shapeRealtimeToggle.addEventListener('change', () => {
            isShapeRealtimeEnabled = shapeRealtimeToggle.checked;
        });

        const shapeSliders = [shapeXSlider, shapeYSlider, shapeWidthSlider, shapeHeightSlider, falloffSlider];
        shapeSliders.forEach(slider => {
            slider.addEventListener('input', () => {
                if (isShapeRealtimeEnabled) updateShapeState();
            });
            slider.addEventListener('mouseup', () => {
                if (!isShapeRealtimeEnabled) updateShapeState(true);
            });
        });

        // Accordion functionality
        const accordionHeaders = document.querySelectorAll('.accordion-header');
        accordionHeaders.forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('active');
            });
        });

        // Initial
        window.onload = () => {
            imageCanvas.width = 600;
            imageCanvas.height = 400;
            ctx.fillStyle = '#e2e8f0';
            ctx.fillRect(0, 0, 600, 400);
            ctx.font = '24px Inter';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#64748b';
            ctx.fillText('Upload an image to get started', 300, 200);
        };
    </script>
</body>
</html>