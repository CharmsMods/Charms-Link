<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Digital Grain Studio</title>
<style>
    /* ---- Theme / Layout ---- */
    :root{
        --bg:#000; --fg:#fff; --panel-max:420px;
    }
    html,body{height:100%; margin:0;}
    body {
        background:var(--bg);
        color:var(--fg);
        font-family:monospace;
        padding:20px;
        display:flex; gap:20px;
        box-sizing:border-box;
        align-items:flex-start;
        min-height:100vh;
    }
    .container{display:flex; gap:20px; width:100%;}
    .controls-panel{flex:1; min-width:260px; max-width:var(--panel-max); padding:10px; box-sizing:border-box;}
    .preview-panel{flex:2; padding:10px; box-sizing:border-box; min-width:320px; display:flex; flex-direction:column; gap:8px;}

    h1,h3{margin:0 0 12px 0; text-align:center;}
    .small-note{font-size:12px; opacity:0.9; text-align:center; margin-top:6px;}

    fieldset{border:1px solid var(--fg); padding:8px; margin-bottom:12px;}
    legend{padding:0 6px;}
    .control-row{display:flex; gap:10px; align-items:center; margin-bottom:8px;}
    /* Make label fixed-width to avoid overlap with controls */
    .control-row label{flex:0 0 140px; font-weight:bold; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    /* ranges take remaining space */
    input[type="range"]{flex:1; min-width:0;}
    /* number boxes compact */
    .control-value{width:80px; padding:2px 6px; text-align:right; background:var(--bg); color:var(--fg); border:1px solid var(--fg); box-sizing:border-box; font-family:monospace; flex:0 0 80px;}
    /* select should expand if needed, but not overlap the label */
    select.control-value{flex:1; min-width:120px; padding:4px 6px; box-sizing:border-box;}

    button{background:var(--bg); color:var(--fg); border:1px solid var(--fg); padding:8px; cursor:pointer; width:100%; box-sizing:border-box; font-family:monospace;}
    button:hover:not(:disabled){background:#222;}

    /* Preview container: we will measure available space and scale CSS size of canvas to fit */
    .preview-top{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .preview-container{position:relative; border:1px solid var(--fg); background:#070707; align-self:stretch; overflow:hidden; display:flex; align-items:center; justify-content:center;}
    /* The canvases hold full pixel buffer; we'll control CSS size to fit area
       Make canvases absolutely positioned and centered so they always overlay exactly */
    canvas{
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%,-50%);
        display:block;
        max-width:none;
        max-height:none;
        image-rendering:auto;
        /* default styles for stacking */
    }
    #originalCanvas { transition: opacity 500ms; z-index:2; pointer-events:none; opacity:0; }
    #noiseCanvas    { z-index:1; pointer-events:auto; }

    /* overlay canvas used during blend-mode crossfade */
    .overlay-canvas { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); display:block; max-width:none; max-height:none; image-rendering:auto; z-index:3; pointer-events:none; opacity:0; transition: opacity 100ms linear; }

    /* Modal */
    .modal-overlay{
        position:fixed; inset:0; background:rgba(0,0,0,0.85);
        display:flex; align-items:center; justify-content:center;
        opacity:0; pointer-events:none; transition:opacity 0.4s ease; z-index:1000;
    }
    .modal-overlay.show{opacity:1; pointer-events:auto;}
    .modal{
        background:#111; border:1px solid var(--fg); border-radius:8px; max-width:720px; width:calc(100% - 40px);
        max-height:80vh; overflow:auto; padding:20px 24px; transform:scale(0.95); transition:transform 0.35s ease;
    }
    .modal-overlay.show .modal{transform:scale(1);}
    .modal h2{text-align:center; margin-top:0;}
    .modal h3{margin:16px 0 6px 0; border-bottom:1px solid #333;}
    .modal p, .modal li{line-height:1.5;}

    /* Remove spinner arrows for number inputs (cross-browser) */
    /* Chrome, Safari, Edge, Opera */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }
    /* Firefox */
    input[type=number] {
        -moz-appearance: textfield;
    }

    /* Small screens: stack */
    @media (max-width:900px){
        body{padding:12px;}
        .container{flex-direction:column;}
        .controls-panel{max-width:none; width:100%;}
        .preview-panel{width:100%;}
        .control-row label{flex:0 0 110px;}
    }
</style>
</head>
<body>
<div class="container">
    <div class="controls-panel">
        <h1>Digital Grain Studio</h1>
        <p class="small-note">Upload an image to start. Controls update live unless performance prompts manual render.</p>

        <!-- File input (no filename display) -->
        <div style="margin-bottom:12px;">
            <label for="imageUpload" style="display:block; font-weight:bold; margin-bottom:6px;">Image Upload</label>
            <input id="imageUpload" type="file" accept="image/*" style="width:100%; background:transparent; color:inherit; border:1px solid var(--fg); padding:8px; box-sizing:border-box;">
        </div>

        <fieldset>
            <legend>Noise Basics</legend>
            <div class="control-row">
                <label for="strength">Noise Strength (σ)</label>
                <input id="strength" type="range" min="0" max="150" step="0.01" value="50">
            </div>
            <div class="control-row">
                <label></label>
                <input id="strengthValue" class="control-value" type="number" min="0" max="150" step="0.01" value="50.00">
            </div>

            <div class="control-row">
                <label for="colorNoiseToggle">Color Noise</label>
                <input id="colorNoiseToggle" type="checkbox" aria-label="Color Noise toggle" style="transform:scale(1.2);">
            </div>
        </fieldset>

        <fieldset>
            <legend>Noise Shape & Blur</legend>

            <div class="control-row">
                <label for="noiseSize">Noise Size</label>
                <!-- slider exposes a large virtual range; mapping functions handle zooming -->
                <input id="noiseSize" type="range" min="0" max="1000" step="0.01" value="4">
            </div>
            <div class="control-row">
                <label></label>
                <input id="noiseSizeValue" class="control-value" type="number" min="1" max="200" step="0.01" value="4.00">
            </div>

            <div style="height:6px"></div>

            <div class="control-row">
                <label for="blurriness">Blurriness (px)</label>
                <input id="blurriness" type="range" min="0" max="1000" step="0.01" value="160">
            </div>
            <div class="control-row">
                <label></label>
                <input id="blurrinessValue" class="control-value" type="number" min="0" max="5" step="0.01" value="2.00">
            </div>
        </fieldset>

        <fieldset>
            <legend>Blend & Visibility</legend>

            <div class="control-row">
                <label for="blendMode">Blend Mode</label>
                <select id="blendMode" class="control-value">
                    <option value="source-over">Normal</option>
                    <option value="overlay" selected>Overlay</option>
                    <option value="screen">Screen</option>
                    <option value="multiply">Multiply</option>
                    <option value="lighter">Add</option>
                    <option value="difference">Subtract</option>
                </select>
            </div>

            <div class="control-row">
                <label for="opacity">Noise Opacity</label>
                <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.25">
            </div>
            <div class="control-row">
                <label></label>
                <input id="opacityValue" class="control-value" type="number" min="0" max="1" step="0.01" value="0.25">
            </div>
        </fieldset>

        <div style="display:flex; gap:8px;">
            <button id="helpBtn">Help / Manual</button>
            <button id="downloadImage" disabled>Download Image</button>
        </div>
    </div>

    <div class="preview-panel">
        <div class="preview-top">
            <h3 style="margin:0;">Image Preview (hover to reveal original)</h3>
            <div style="font-size:12px; opacity:0.9; align-self:center;"></div>
        </div>

        <div id="previewArea" class="preview-container" style="height:calc(100vh - 220px);">
            <!-- canvases hold full-resolution image. CSS size will be computed to fit previewArea -->
            <canvas id="noiseCanvas"></canvas>
            <canvas id="originalCanvas"></canvas>
            <!-- overlay canvas will be created dynamically when scrolling -->
        </div>

        <!-- tip removed as requested -->
    </div>
</div>

<!-- Manual Popup -->
<div class="modal-overlay" id="manualModal" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="manualTitle">
    <h2 id="manualTitle">Digital Grain Studio — Manual</h2>

    <h3>Quick Overview</h3>
    <p>Layer a custom noise texture over an image. The noise is generated separately, optionally blurred, then composited with your chosen blend mode and opacity. Can scale the grain from ultra-fine to chunky.</p>

    <h3>Controls</h3>
    <ul>
      <li><b>Noise Strength (σ):</b> controls the standard deviation of the Gaussian noise — crank it for stronger contrast in the grain.</li>
      <li><b>Color Noise:</b> when enabled, each RGB channel receives independent noise (color speckles); when off, noise is grayscale.</li>
      <li><b>Noise Size:</b> controls the apparent size of grains. The slider provides extreme low-end precision; the numeric box shows the effective size (1.00 → 200.00).</li>
      <li><b>Blurriness:</b> Gaussian blur applied to the noise layer only.</li>
      <li><b>Blend Mode:</b> how the blurred noise merges with the original (see reference below).</li>
      <li><b>Noise Opacity:</b> final transparency of the noise layer before compositing.</li>
    </ul>

    <h3>Blend Mode Reference</h3>
    <ul>
      <li><b>Normal:</b> the noise simply sits on top (replaces where applied).</li>
      <li><b>Overlay:</b> contrast-preserving; lights brighten, darks deepen — classic film-grain feel.</li>
      <li><b>Screen:</b> lightens — good for softening and glow-like grain.</li>
      <li><b>Multiply:</b> darkens — useful for gritty or moody looks.</li>
      <li><b>Add (lighter):</b> adds pixel values (brightens strongly) — can blow highlights, use sparingly.</li>
      <li><b>Subtract (difference):</b> creates inverted / high-contrast effects — more experimental.</li>
    </ul>

    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button id="closeManual">Close</button>
    </div>
  </div>
</div>

<script>
/* -------------------------
   Elements & state
   ------------------------- */
const fileInput = document.getElementById('imageUpload');
const originalCanvas = document.getElementById('originalCanvas');
const noiseCanvas = document.getElementById('noiseCanvas');
const ctxOriginal = originalCanvas.getContext('2d');
const ctxNoise = noiseCanvas.getContext('2d');

const strengthRange = document.getElementById('strength');
const strengthNumber = document.getElementById('strengthValue');

const noiseSizeRange = document.getElementById('noiseSize');
const noiseSizeNumber = document.getElementById('noiseSizeValue');

const blurrinessRange = document.getElementById('blurriness');
const blurrinessNumber = document.getElementById('blurrinessValue');

const colorNoiseToggle = document.getElementById('colorNoiseToggle');
const blendModeSelect = document.getElementById('blendMode');
const opacityRange = document.getElementById('opacity');
const opacityNumber = document.getElementById('opacityValue');

const downloadBtn = document.getElementById('downloadImage');
const previewArea = document.getElementById('previewArea');

const helpBtn = document.getElementById('helpBtn');
const manualModal = document.getElementById('manualModal');
const closeManual = document.getElementById('closeManual');

let originalImageData = null;

/* -------------------------
   Utility: Gaussian (Box-Muller)
   ------------------------- */
function gaussianRandom(mean=0,std=1){
    let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
    return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v) * std + mean;
}

/* -------------------------
   Slider mapping for noiseSize and blur
   ------------------------- */
const MAX_NOISE_SIZE = 200.0;
const MAX_BLUR = 5.0;
const SLIDER_MAX = 1000.0;
const ZOOM_EXPONENT = 3.0;

function noiseSizeFromSlider(s){
    const t = Math.pow(s / SLIDER_MAX, ZOOM_EXPONENT);
    return 1.0 + (MAX_NOISE_SIZE - 1.0) * t;
}
function sliderFromNoiseSize(size){
    const t = (Math.max(1.0, Math.min(MAX_NOISE_SIZE, size)) - 1.0) / (MAX_NOISE_SIZE - 1.0);
    return SLIDER_MAX * Math.pow(t, 1.0 / ZOOM_EXPONENT);
}

function blurFromSlider(s){
    const t = Math.pow(s / SLIDER_MAX, ZOOM_EXPONENT);
    return MAX_BLUR * t;
}
function sliderFromBlur(blur){
    const t = Math.max(0.0, Math.min(MAX_BLUR, blur)) / MAX_BLUR;
    return SLIDER_MAX * Math.pow(t, 1.0 / ZOOM_EXPONENT);
}

/* -------------------------
   Preview sizing: compute CSS size for canvases to fit previewArea
   Keep canvases centered and identical in size/position
   ------------------------- */
function fitCanvasesToPreview(){
    if(!originalImageData) return;
    const w = originalCanvas.width;
    const h = originalCanvas.height;
    const areaRect = previewArea.getBoundingClientRect();
    const padding = 8;
    const maxW = Math.max(32, areaRect.width - padding);
    const maxH = Math.max(32, areaRect.height - padding);

    const scale = Math.min(maxW / w, maxH / h, 1);
    const cssW = Math.round(w * scale);
    const cssH = Math.round(h * scale);

    // apply identical CSS sizing and center transform (CSS already sets centering)
    [originalCanvas, noiseCanvas].forEach(c => {
        c.style.width = cssW + 'px';
        c.style.height = cssH + 'px';
        c.style.left = '50%';
        c.style.top = '50%';
        c.style.transform = 'translate(-50%,-50%)';
    });

    // Also set previewArea min-height so smaller tall images don't collapse UI
    previewArea.style.minHeight = Math.min(maxH, cssH) + 'px';
}

/* -------------------------
   Helper: Generate noise bitmap (returns a canvas sized to w x h with the blurred noise)
   This duplicates the noise-generation part of applyGaussianNoise but isolates it for reuse
   ------------------------- */
function generateNoiseFullCanvas(w, h, params){
    const { std, isColor, blurSlider, noiseSlider } = params;
    const blurPx = blurFromSlider(blurSlider);
    const noiseSize = noiseSizeFromSlider(noiseSlider);

    const smallW = Math.max(1, Math.round(w / noiseSize));
    const smallH = Math.max(1, Math.round(h / noiseSize));

    const smallCanvas = document.createElement('canvas');
    smallCanvas.width = smallW; smallCanvas.height = smallH;
    const sCtx = smallCanvas.getContext('2d');
    const smallImg = sCtx.createImageData(smallW, smallH);
    const sd = smallImg.data;

    for(let y=0;y<smallH;y++){
        for(let x=0;x<smallW;x++){
            const i = (y*smallW + x)*4;
            if(isColor){
                sd[i]   = Math.max(0, Math.min(255, Math.round(128 + gaussianRandom(0, std))));
                sd[i+1] = Math.max(0, Math.min(255, Math.round(128 + gaussianRandom(0, std))));
                sd[i+2] = Math.max(0, Math.min(255, Math.round(128 + gaussianRandom(0, std))));
            } else {
                const v = Math.max(0, Math.min(255, Math.round(128 + gaussianRandom(0, std))));
                sd[i] = sd[i+1] = sd[i+2] = v;
            }
            sd[i+3] = 255;
        }
    }
    sCtx.putImageData(smallImg, 0, 0);

    const noiseFull = document.createElement('canvas');
    noiseFull.width = w; noiseFull.height = h;
    const nfCtx = noiseFull.getContext('2d');
    nfCtx.imageSmoothingEnabled = true;

    if(blurPx > 0){
        nfCtx.filter = `blur(${blurPx}px)`;
        nfCtx.drawImage(smallCanvas, 0, 0, w, h);
        nfCtx.filter = 'none';
    } else {
        nfCtx.drawImage(smallCanvas, 0, 0, w, h);
    }

    return noiseFull;
}

/* -------------------------
   Main noise pipeline (unchanged; kept for normal live updates)
   ------------------------- */
function applyGaussianNoise(){
    if(!originalImageData) return;
    const w = originalCanvas.width;
    const h = originalCanvas.height;

    const std = parseFloat(strengthNumber.value) || 0.0;
    const blurSlider = parseFloat(blurrinessRange.value) || 0.0;
    const blurPx = blurFromSlider(blurSlider);
    const isColor = colorNoiseToggle.checked;
    const blend = blendModeSelect.value || 'source-over';
    const opacity = parseFloat(opacityNumber.value) || 0.0;
    const noiseSlider = parseFloat(noiseSizeRange.value) || 1.0;
    const noiseSize = noiseSizeFromSlider(noiseSlider);

    const noiseFull = generateNoiseFullCanvas(w, h, {
        std, isColor, blurSlider, noiseSlider
    });

    // composite: draw original then blend noise over it on noiseCanvas
    ctxNoise.clearRect(0,0,w,h);
    ctxNoise.globalCompositeOperation = 'source-over';
    ctxNoise.drawImage(originalCanvas, 0, 0, w, h);

    ctxNoise.globalAlpha = opacity;
    ctxNoise.globalCompositeOperation = blend;
    ctxNoise.drawImage(noiseFull, 0, 0, w, h);

    // reset
    ctxNoise.globalAlpha = 1.0;
    ctxNoise.globalCompositeOperation = 'source-over';

    // allow download
    downloadBtn.disabled = false;

    // redraw fit (in case image size changed)
    fitCanvasesToPreview();
}

/* -------------------------
   Loading image -> set canvas pixel buffers -> initial render -> fit
   ------------------------- */
function loadImageToCanvases(img){
    const w = img.naturalWidth || img.width;
    const h = img.naturalHeight || img.height;

    originalCanvas.width = noiseCanvas.width = w;
    originalCanvas.height = noiseCanvas.height = h;

    ctxOriginal.clearRect(0,0,w,h);
    ctxOriginal.drawImage(img, 0, 0, w, h);
    originalImageData = ctxOriginal.getImageData(0,0,w,h);

    ctxNoise.clearRect(0,0,w,h);
    ctxNoise.drawImage(originalCanvas, 0, 0, w, h);

    fitCanvasesToPreview();
    applyGaussianNoise();
}

/* -------------------------
   Event bindings and synchronization
   ------------------------- */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

// Strength
strengthRange.addEventListener('input', ()=> {
    strengthNumber.value = parseFloat(strengthRange.value).toFixed(2);
    applyGaussianNoise();
});
strengthNumber.addEventListener('change', ()=> {
    let v = parseFloat(strengthNumber.value); if(isNaN(v)) v=0;
    v = clamp(v, 0, 150);
    strengthNumber.value = v.toFixed(2);
    strengthRange.value = v;
    applyGaussianNoise();
});

// Noise Size (slider <-> number with mapping)
function syncNoiseSizeFromSlider(){
    const slider = parseFloat(noiseSizeRange.value);
    const size = noiseSizeFromSlider(slider);
    noiseSizeNumber.value = size.toFixed(2);
}
noiseSizeRange.addEventListener('input', ()=> {
    syncNoiseSizeFromSlider();
    applyGaussianNoise();
});
noiseSizeNumber.addEventListener('change', ()=> {
    let v = parseFloat(noiseSizeNumber.value); if(isNaN(v)) v = 1.0;
    v = clamp(v, 1.0, MAX_NOISE_SIZE);
    noiseSizeNumber.value = v.toFixed(2);
    noiseSizeRange.value = sliderFromNoiseSize(v).toFixed(2);
    applyGaussianNoise();
});

// Blurriness mapping
function syncBlurFromSlider(){
    const slider = parseFloat(blurrinessRange.value);
    const blur = blurFromSlider(slider);
    blurrinessNumber.value = blur.toFixed(2);
}
blurrinessRange.addEventListener('input', ()=> {
    syncBlurFromSlider();
    applyGaussianNoise();
});
blurrinessNumber.addEventListener('change', ()=> {
    let v = parseFloat(blurrinessNumber.value); if(isNaN(v)) v = 0;
    v = clamp(v, 0.0, MAX_BLUR);
    blurrinessNumber.value = v.toFixed(2);
    blurrinessRange.value = sliderFromBlur(v).toFixed(2);
    applyGaussianNoise();
});

// Opacity
opacityRange.addEventListener('input', ()=> {
    opacityNumber.value = parseFloat(opacityRange.value).toFixed(2);
    applyGaussianNoise();
});
opacityNumber.addEventListener('change', ()=> {
    let v = parseFloat(opacityNumber.value); if(isNaN(v)) v = 0;
    v = clamp(v, 0, 1);
    opacityNumber.value = v.toFixed(2);
    opacityRange.value = v;
    applyGaussianNoise();
});

// Other controls
colorNoiseToggle.addEventListener('change', applyGaussianNoise);
blendModeSelect.addEventListener('change', applyGaussianNoise);

/* -------------------------
   File input handling
   ------------------------- */
fileInput.addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => loadImageToCanvases(img);
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
});

/* -------------------------
   Hover & Scroll reveal behaviour (NEW)
   - Scroll while hovering cycles blend modes
   - Each change crossfades (100ms)
   - After 2s of no scroll while still hovering show original image again
   - Leaving preview shows edited image (original opacity 0)
   ------------------------- */

const previewContainer = previewArea;

// Blend modes in same order as select
const blendModes = Array.from(blendModeSelect.options).map(o => o.value);
let currentBlendIndex = blendModes.indexOf(blendModeSelect.value || 'overlay');
if(currentBlendIndex === -1) currentBlendIndex = 0;

// state
let scrollInactivityTimer = null;
let overlayCanvas = null;
let activeTransition = null; // used to cancel overlapping transitions
let scrollModeActive = false;  // true when user scrolled recently and we are in "previewing blends" mode

// helpers
function clearScrollInactivityTimer(){
    if(scrollInactivityTimer) { clearTimeout(scrollInactivityTimer); scrollInactivityTimer = null; }
}
function scheduleRevertToOriginal(){
    clearScrollInactivityTimer();
    scrollInactivityTimer = setTimeout(()=> {
        // only revert if still hovering
        if(isPointerOverPreview){
            scrollModeActive = false;
            // fade original back in (originalCanvas has CSS transition 500ms already)
            originalCanvas.style.opacity = '1';
            // remove any overlay that might linger
            removeOverlayCanvasImmediate();
        }
        scrollInactivityTimer = null;
    }, 2000);
}
function removeOverlayCanvasImmediate(){
    if(overlayCanvas && overlayCanvas.parentElement){
        overlayCanvas.parentElement.removeChild(overlayCanvas);
    }
    overlayCanvas = null;
    activeTransition = null;
}

// returns promise resolved after transition complete (100ms)
function crossfadeToBlend(mode){
    return new Promise((resolve) => {
        if(!originalImageData) { resolve(); return; }
        const w = originalCanvas.width, h = originalCanvas.height;
        // Generate noiseFull using current UI param values but override blend to `mode`
        const std = parseFloat(strengthNumber.value) || 0.0;
        const blurSlider = parseFloat(blurrinessRange.value) || 0.0;
        const isColor = colorNoiseToggle.checked;
        const opacity = parseFloat(opacityNumber.value) || 0.0;
        const noiseSlider = parseFloat(noiseSizeRange.value) || 1.0;

        const noiseFull = generateNoiseFullCanvas(w, h, {
            std, isColor, blurSlider, noiseSlider
        });

        // Build overlay canvas that has the composed result for this blend mode
        const ov = document.createElement('canvas');
        ov.width = w; ov.height = h;
        ov.className = 'overlay-canvas';
        // match CSS sizing so it lines up
        ov.style.width = noiseCanvas.style.width;
        ov.style.height = noiseCanvas.style.height;
        ov.style.left = noiseCanvas.style.left;
        ov.style.top = noiseCanvas.style.top;
        ov.style.transform = noiseCanvas.style.transform;
        ov.style.opacity = '0';

        const ovCtx = ov.getContext('2d');
        ovCtx.clearRect(0,0,w,h);
        ovCtx.globalCompositeOperation = 'source-over';
        ovCtx.drawImage(originalCanvas, 0, 0, w, h);

        ovCtx.globalAlpha = opacity;
        ovCtx.globalCompositeOperation = mode;
        ovCtx.drawImage(noiseFull, 0, 0, w, h);

        // reset
        ovCtx.globalAlpha = 1.0;
        ovCtx.globalCompositeOperation = 'source-over';

        // remove previous overlay if present and not yet removed (we'll replace)
        if(overlayCanvas && overlayCanvas.parentElement){
            overlayCanvas.parentElement.removeChild(overlayCanvas);
            overlayCanvas = null;
        }
        overlayCanvas = ov;

        // append and trigger the fade-in
        previewArea.appendChild(overlayCanvas);

        // force reflow
        void overlayCanvas.offsetWidth;

        // make sure original image isn't visible while previewing blends
        originalCanvas.style.opacity = '0';

        // cancel previous transition if still running
        if(activeTransition && activeTransition.cancel) activeTransition.cancel();

        let cancelled = false;
        activeTransition = {
            cancel: ()=> { cancelled = true; }
        };

        // start fade-in
        overlayCanvas.style.opacity = '1';

        // after fade completes (100ms) copy overlay pixels into noiseCanvas to become the new baseline,
        // then remove overlay.
        const t = setTimeout(()=> {
            if(cancelled){
                // cleanup and bail
                if(overlayCanvas && overlayCanvas.parentElement) overlayCanvas.parentElement.removeChild(overlayCanvas);
                overlayCanvas = null;
                activeTransition = null;
                resolve();
                return;
            }
            try{
                // copy rendered overlay contents into noiseCanvas bitmap
                ctxNoise.clearRect(0,0,w,h);
                ctxNoise.drawImage(overlayCanvas, 0, 0, w, h);
            }catch(e){
                // ignore errors
            }
            // remove overlay
            if(overlayCanvas && overlayCanvas.parentElement) overlayCanvas.parentElement.removeChild(overlayCanvas);
            overlayCanvas = null;
            activeTransition = null;
            resolve();
        }, 110); // slightly more than 100ms to be safe
    });
}

// wheel handler to change blend mode index
function wheelCycleBlendMode(ev){
    if(!originalImageData) return;
    // keep default scrolling for page? Prevent to avoid accidental scrolling while hovering area
    ev.preventDefault();

    const delta = ev.deltaY || ev.wheelDelta || 0;
    if(delta === 0) return;

    // determine direction
    const dir = delta > 0 ? 1 : -1;
    currentBlendIndex = (currentBlendIndex + dir + blendModes.length) % blendModes.length;

    const mode = blendModes[currentBlendIndex];
    // reflect in UI select *but do not call its change handler* automatically (we'll update the UI value and render)
    blendModeSelect.value = mode;

    // entering scroll-preview mode
    scrollModeActive = true;
    // ensure original hidden so edited is visible
    originalCanvas.style.opacity = '0';

    // crossfade to the newly rendered blend result
    crossfadeToBlend(mode);

    // reset inactivity revert timer
    scheduleRevertToOriginal();
}

// pointer state tracking
let isPointerOverPreview = false;
previewContainer.addEventListener('mouseenter', (e)=> {
    isPointerOverPreview = true;
    // If we haven't entered scroll-preview mode recently, show original (old behavior)
    if(!scrollModeActive){
        originalCanvas.style.opacity = '1';
    } else {
        // if in scroll preview mode, keep original hidden (we're previewing blends)
        originalCanvas.style.opacity = '0';
    }
});
previewContainer.addEventListener('mouseleave', (e)=> {
    isPointerOverPreview = false;
    // leaving preview: always show edited (noise) canvas and cancel revert timers
    clearScrollInactivityTimer();
    scrollModeActive = false;
    originalCanvas.style.opacity = '0';
    // remove any overlay (but keep the current composite on noiseCanvas)
    removeOverlayCanvasImmediate();
});

// add wheel listener for scrolling through blends
// use passive: false so we can preventDefault to avoid page scroll
previewContainer.addEventListener('wheel', wheelCycleBlendMode, { passive: false });

/* -------------------------
   Download
   ------------------------- */
downloadBtn.addEventListener('click', ()=> {
    const a = document.createElement('a');
    a.download = 'noisy_image.png';
    a.href = noiseCanvas.toDataURL('image/png');
    a.click();
});

/* -------------------------
   Modal manual
   ------------------------- */
helpBtn.addEventListener('click', ()=> {
    manualModal.classList.add('show');
    manualModal.setAttribute('aria-hidden','false');
});
closeManual.addEventListener('click', ()=> {
    manualModal.classList.remove('show');
    manualModal.setAttribute('aria-hidden','true');
});
manualModal.addEventListener('click', (e)=> { if(e.target === manualModal) { manualModal.classList.remove('show'); manualModal.setAttribute('aria-hidden','true'); }});

/* -------------------------
   Resize handling
   ------------------------- */
window.addEventListener('resize', ()=> {
    if(window._fitTimeout) clearTimeout(window._fitTimeout);
    window._fitTimeout = setTimeout(()=> {
        fitCanvasesToPreview();
    }, 80);
});

/* -------------------------
   Initialize default values & sync map
   ------------------------- */
(function init(){
    strengthNumber.value = parseFloat(strengthRange.value).toFixed(2);

    noiseSizeRange.value = sliderFromNoiseSize(parseFloat(noiseSizeNumber.value || 4)).toFixed(2);
    syncNoiseSizeFromSlider();

    blurrinessRange.value = sliderFromBlur(parseFloat(blurrinessNumber.value || 2)).toFixed(2);
    syncBlurFromSlider();

    opacityNumber.value = parseFloat(opacityRange.value).toFixed(2);
})();
</script>
</body>
</html>
