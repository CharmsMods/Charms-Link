<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Noise Generator</title>
    <style>
        /*
        * 1. THEME & STRUCTURE
        * Uses only #000000 (black) and #ffffff (white).
        */
        body {
            background-color: #000000;
            color: #ffffff;
            font-family: monospace;
            display: flex;
            /* ALIGN CONTENT TO LEFT */
            justify-content: flex-start;
            align-items: flex-start;
            padding: 20px; /* This gives the 'slight gap' on the left */
            margin: 0;
            min-height: 100vh;
            text-align: left; /* Aligns text in the controls panel */
        }

        .container {
            display: flex;
            gap: 20px;
            width: 100%;
            padding: 0;
        }

        .controls-panel {
            flex: 1;
            padding: 10px;
            min-width: 300px;
            max-width: 400px;
        }
        
        .preview-panel {
            flex: 2;
            padding: 10px;
            max-width: calc(100vw - 350px); 
        }

        /*
        * 2. UI ELEMENTS STYLING
        */
        h1, h3 {
            color: #ffffff;
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center; 
        }

        .input-group {
            margin-bottom: 15px;
            text-align: left;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px 0;
        }

        .control-row label {
            flex-grow: 1;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .control-value {
            width: 30px;
            text-align: right;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #ffffff;
            border: 1px solid #000000;
            cursor: pointer;
        }

        /* Styling for Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #000000; 
            border: 1px solid #ffffff;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 3px;
            background-color: white; 
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #ffffff;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(16px);
            -ms-transform: translateX(16px);
            transform: translateX(16px);
            background-color: #000000;
        }
        
        /* Button and File Input Styling */
        input[type="file"] {
            background-color: #000000;
            color: #ffffff;
            border: 1px solid #ffffff;
            padding: 8px 15px;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
            font-family: monospace;
            margin-bottom: 10px;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            background-color: #000000;
            color: #ffffff;
            border: 1px solid #ffffff;
            padding: 8px 15px;
            cursor: pointer;
            box-sizing: border-box;
            font-family: monospace;
            width: 100%;
        }

        button:hover:not(:disabled) {
            background-color: #333333;
        }

        /* Class to hide the manual button by default */
        .hidden {
            display: none !important;
        }

        /*
        * 3. PREVIEW STYLING
        */
        .preview-container {
            position: relative; 
            display: inline-block;
            border: 1px solid #ffffff;
            padding: 0; 
            margin-bottom: 20px;
            max-width: 100%; 
            height: auto;
        }

        #noiseCanvas {
            max-width: 100%;
            height: auto;
            display: block;
        }
        
        #originalCanvas {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; 
            transition: opacity 100ms ease-in-out; 
            max-width: 100%;
            height: auto;
        }

        .preview-container:hover #originalCanvas {
            opacity: 1; 
        }

        .hidden-canvas {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls-panel">
            <h1 style="text-align: center;">Digital Grain Studio</h1>
            <p style="text-align: center;">Load an image and tune the noise effect.</p>

            <div class="input-group">
                <label for="imageUpload">Image Upload:</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>

            <div class="input-group">
                <div class="control-row">
                    <label for="strength">Noise Strength (Standard Deviation):</label>
                    <input type="range" id="strength" min="0" max="150" step="0.1" value="50">
                    <span class="control-value" id="strengthValue">50.0</span>
                </div>
            </div>

            <div class="input-group">
                <div class="control-row">
                    <label for="blurriness">Noise Blurriness (Radius):</label>
                    <input type="range" id="blurriness" min="0" max="1000" step="1" value="160">
                    <span class="control-value" id="blurrinessValue">2.0</span>
                </div>
            </div>
            
            <div class="input-group">
                <div class="control-row">
                    <label for="colorNoiseToggle">B&W Noise / Color Noise</label>
                    <label class="switch">
                        <input type="checkbox" id="colorNoiseToggle"> 
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div class="button-container">
                <button id="manualRenderButton" class="hidden">Manual Render Preview</button>
                <button id="downloadImage" disabled>Download Noisy Image</button>
            </div>
        </div>

        <div class="preview-panel">
            <h3 style="text-align: center;">Image Preview (Hover to see Original)</h3>
            <div class="preview-container">
                <canvas id="noiseCanvas" class="hidden-canvas"></canvas>
                <canvas id="originalCanvas" class="hidden-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Get elements
        const fileInput = document.getElementById('imageUpload');
        const originalCanvas = document.getElementById('originalCanvas');
        const noiseCanvas = document.getElementById('noiseCanvas');
        const previewContainer = document.querySelector('.preview-container');
        const ctxOriginal = originalCanvas.getContext('2d');
        const ctxNoise = noiseCanvas.getContext('2d');
        const strengthInput = document.getElementById('strength');
        const blurrinessInput = document.getElementById('blurriness');
        const strengthValueSpan = document.getElementById('strengthValue');
        const blurrinessValueSpan = document.getElementById('blurrinessValue');
        const colorNoiseToggle = document.getElementById('colorNoiseToggle');
        const downloadButton = document.getElementById('downloadImage');
        // Manual button element
        const manualRenderButton = document.getElementById('manualRenderButton');

        let originalPixelData = null; // Stored raw pixel data of the original image
        
        // State variables for smart feature
        let isRealTimeControl = true; 
        const PERFORMANCE_THRESHOLD_MS = 600;

        // *** LOGARITHMIC MAPPING FUNCTION ***
        function getLogarithmicBlurRadius(sliderValue) {
            const MAX_SLIDER_VALUE = 1000;
            const MAX_BLUR_RADIUS = 5.0;
            
            // Use a Square Root curve (exponent 0.5) to give more detail at the low end (0.0 to 1.0)
            const normalizedValue = sliderValue / MAX_SLIDER_VALUE;
            // The formula is: y = R_max * (x/X_max)^(0.5)
            const blurRadius = MAX_BLUR_RADIUS * Math.pow(normalizedValue, 0.5);
            
            // Return with high precision (4 decimal places)
            return parseFloat(blurRadius.toFixed(4));
        }

        // *** GAUSSIAN RANDOM NUMBER GENERATOR (Box-Muller Transform) ***
        function gaussianRandom(mean = 0, stdDev = 1) {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return num * stdDev + mean;
        }

        // *** EVENT MANAGEMENT FUNCTIONS ***
        function bindRealTimeNoiseListeners() {
            strengthInput.addEventListener('input', applyGaussianNoise);
            // Blur is still bound to the real-time noise function
            blurrinessInput.addEventListener('input', applyGaussianNoise);
            colorNoiseToggle.addEventListener('change', applyGaussianNoise);
        }

        function unbindRealTimeNoiseListeners() {
            strengthInput.removeEventListener('input', applyGaussianNoise);
            blurrinessInput.removeEventListener('input', applyGaussianNoise);
            colorNoiseToggle.removeEventListener('change', applyGaussianNoise);
        }

        function updateValueDisplays() {
            strengthValueSpan.textContent = parseFloat(strengthInput.value).toFixed(1); 
            
            // ðŸ’¡ JS CHANGE: Display the calculated, real blur radius, not the abstract slider value
            const realBlurRadius = getLogarithmicBlurRadius(parseFloat(blurrinessInput.value));
            blurrinessValueSpan.textContent = realBlurRadius.toFixed(1);
        }

        // *** NOISE APPLICATION FUNCTION (NOW TIMED) ***
        function applyGaussianNoise() {
            if (!originalPixelData) {
                return;
            }

            // Start Timer
            const startTime = performance.now();

            const stdDev = parseFloat(strengthInput.value);
            // ðŸ’¡ JS CHANGE: Get the calculated logarithmic value for the blur radius
            const blurRadius = getLogarithmicBlurRadius(parseFloat(blurrinessInput.value));
            const isColorNoise = colorNoiseToggle.checked;

            // Clone the original data array for the noisy version
            const noisyImageData = new ImageData(
                new Uint8ClampedArray(originalPixelData.data),
                originalCanvas.width,
                originalCanvas.height
            );
            const data = noisyImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (isColorNoise) {
                    // Color Noise: Apply unique noise to R, G, B
                    for (let j = 0; j < 3; j++) {
                        const index = i + j;
                        const noise = gaussianRandom(0, stdDev);
                        let value = data[index] + noise;
                        data[index] = Math.max(0, Math.min(255, value));
                    }
                } else {
                    // B&W Noise: Apply one noise value equally to R, G, B
                    const noise = gaussianRandom(0, stdDev);
                    for (let j = 0; j < 3; j++) {
                        const index = i + j;
                        let value = data[index] + noise;
                        data[index] = Math.max(0, Math.min(255, value));
                    }
                }
            }

            // Draw the noisy image
            ctxNoise.putImageData(noisyImageData, 0, 0);

            // Apply Blurriness
            if (blurRadius > 0) {
                ctxNoise.filter = `blur(${blurRadius}px)`;
                ctxNoise.drawImage(noiseCanvas, 0, 0);
                ctxNoise.filter = 'none';
            }

            downloadButton.disabled = false;
            
            // End Timer and Check Performance
            const endTime = performance.now();
            const processingTime = endTime - startTime;

            if (processingTime > PERFORMANCE_THRESHOLD_MS && isRealTimeControl) {
                // Switch to manual mode
                isRealTimeControl = false;
                unbindRealTimeNoiseListeners();
                manualRenderButton.classList.remove('hidden');
                
                alert(`âš ï¸ Performance Alert!\nImage processing took ${processingTime.toFixed(0)}ms. Real-time preview has been disabled to prevent lag. Please use the 'Manual Render Preview' button.`);
            }
        }

        // *** EVENT HANDLERS ***

        // 1. Image Loading
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const width = img.width;
                        const height = img.height;

                        originalCanvas.width = noiseCanvas.width = width;
                        originalCanvas.height = noiseCanvas.height = height;
                        
                        ctxOriginal.drawImage(img, 0, 0);
                        originalPixelData = ctxOriginal.getImageData(0, 0, width, height);

                        noiseCanvas.classList.remove('hidden-canvas');
                        originalCanvas.classList.remove('hidden-canvas');

                        // Reset to real-time mode for a new image
                        isRealTimeControl = true;
                        manualRenderButton.classList.add('hidden');
                        bindRealTimeNoiseListeners(); // Re-bind on new image load

                        // Apply noise immediately (uses default blur of 2.0)
                        applyGaussianNoise();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // 2. Control Updates (ALWAYS update value displays)
        strengthInput.addEventListener('input', updateValueDisplays);
        blurrinessInput.addEventListener('input', updateValueDisplays);

        // 3. Initial binding for real-time noise
        bindRealTimeNoiseListeners(); 

        // 4. Manual Render Button Handler
        manualRenderButton.addEventListener('click', applyGaussianNoise);

        // 5. Download Button
        downloadButton.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'noisy_image.png';
            link.href = noiseCanvas.toDataURL('image/png');
            link.click();
        });
    </script>
</body>
</html>