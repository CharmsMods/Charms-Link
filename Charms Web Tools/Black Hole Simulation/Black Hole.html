<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RK4 Black Hole Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
        #hud { 
            position: absolute; bottom: 30px; left: 30px; color: #0f0; 
            background: rgba(0,20,0,0.8); padding: 15px; border: 1px solid #0f0;
            pointer-events: none; font-size: 11px; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0,255,0,0.2);
        }
    </style>
</head>
<body>

    <div id="hud">
        <b>[ SYSTEM STATUS: ACTIVE ]</b><br>
        Metric: Schwarzschild (RK4)<br>
        Lensing: Einstein Ring Active<br>
        Controls: Move Mouse to Orbit
    </div>

    <canvas id="canvas"></canvas>

<script type="x-shader/x-vertex" id="vs">#version 300 es
    in vec4 position;
    void main() { gl_Position = position; }
</script>

<script type="x-shader/x-fragment" id="fs">#version 300 es
    precision highp float;
    uniform vec2 u_res;
    uniform vec2 u_mouse;
    uniform float u_time;
    uniform float u_camDist;
    uniform float u_fov;
    uniform float u_spin;
    out vec4 fragColor;

    const float RS = 1.0;
    const float R_PHOTON = 1.5 * RS;
    const float R_DISK_IN = 3.0 * RS;
    const float R_DISK_OUT = 18.0 * RS;
    const float FAR_RADIUS = 60.0;
    const int MAX_STEPS = 200;

    float hash(vec3 p) {
        p = fract(p * 0.3183099 + .1);
        p *= 17.0;
        return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
    }

    float noise2D(vec2 uv) {
        return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453123);
    }

    float noiseSmooth(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = noise2D(i);
        float b = noise2D(i + vec2(1.0, 0.0));
        float c = noise2D(i + vec2(0.0, 1.0));
        float d = noise2D(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }

    float fbm(vec2 p) {
        float v = 0.0;
        float a = 0.5;
        mat2 m = mat2(1.6, -1.2, 1.2, 1.6);
        for (int i = 0; i < 5; i++) {
            v += a * noiseSmooth(p);
            p = m * p;
            a *= 0.5;
        }
        return v;
    }

    vec3 sample_sky(vec3 dir) {
        dir = normalize(dir);
        float u = atan(dir.z, dir.x) / (6.2831853) + 0.5;
        float v = asin(clamp(dir.y, -1.0, 1.0)) / 3.14159265 + 0.5;
        vec2 uv = vec2(u, v);

        float neb = fbm(uv * 4.0 + vec2(0.0, u_time * 0.01));
        vec3 nebCol = mix(vec3(0.02, 0.04, 0.08), vec3(0.18, 0.08, 0.22), smoothstep(0.35, 0.9, neb));
        nebCol *= 0.35 + 0.65 * smoothstep(0.25, 0.95, fbm(uv * 1.7 - 12.0));

        float n1 = noise2D(uv * 1400.0);
        float n2 = noise2D(uv * 3400.0 + 1.7);
        float star = pow(max(n1, n2), 38.0);
        float star2 = pow(noise2D(uv * 9000.0 + 0.2), 180.0);
        float tw = 0.75 + 0.25 * sin(u_time * 3.0 + 6.2831 * noise2D(uv * 200.0));
        vec3 starCol = mix(vec3(0.8, 0.9, 1.0), vec3(1.0, 0.85, 0.7), noise2D(uv * 80.0 + 2.0));
        starCol *= (star * tw * 2.2 + star2 * 5.0);

        vec3 sky = nebCol + starCol;
        return sky;
    }

    float du_dphi_sq(float u, float invb2) {
        return invb2 - (u * u) + (RS * u * u * u);
    }

    void rk4_u_step(inout float u, inout float w, float dphi, float invb2) {
        float k1_u = w;
        float k1_w = u - 1.5 * RS * u * u;

        float u2 = u + 0.5 * dphi * k1_u;
        float w2 = w + 0.5 * dphi * k1_w;
        float k2_u = w2;
        float k2_w = u2 - 1.5 * RS * u2 * u2;

        float u3 = u + 0.5 * dphi * k2_u;
        float w3 = w + 0.5 * dphi * k2_w;
        float k3_u = w3;
        float k3_w = u3 - 1.5 * RS * u3 * u3;

        float u4 = u + dphi * k3_u;
        float w4 = w + dphi * k3_w;
        float k4_u = w4;
        float k4_w = u4 - 1.5 * RS * u4 * u4;

        u += (dphi / 6.0) * (k1_u + 2.0 * k2_u + 2.0 * k3_u + k4_u);
        w += (dphi / 6.0) * (k1_w + 2.0 * k2_w + 2.0 * k3_w + k4_w);

        float wAbs = sqrt(max(du_dphi_sq(u, invb2), 0.0));
        w = sign(w) * min(abs(w), wAbs + 1e-4);
    }

    vec3 ray_dir_from_u(float u, float w, float phi, vec3 e1, vec3 e2) {
        float r = 1.0 / max(u, 1e-4);
        vec3 e_r = cos(phi) * e1 + sin(phi) * e2;
        vec3 e_phi = -sin(phi) * e1 + cos(phi) * e2;
        float dr_dphi = -w / max(u * u, 1e-6);
        vec3 t = dr_dphi * e_r + r * e_phi;
        return normalize(t);
    }

    vec3 pos_from_u(float u, float phi, vec3 e1, vec3 e2) {
        float r = 1.0 / max(u, 1e-4);
        return r * (cos(phi) * e1 + sin(phi) * e2);
    }

    vec3 disk_emission(vec3 hit, vec3 rayDir, vec3 diskNormal) {
        float r = length(hit);

        float t = clamp((r - R_DISK_IN) / (R_DISK_OUT - R_DISK_IN), 0.0, 1.0);
        vec3 hot = vec3(1.25, 0.75, 0.25);
        vec3 cool = vec3(0.35, 0.55, 1.15);
        vec3 base = mix(hot, cool, pow(t, 0.6));

        float phi = atan(hit.z, hit.x);
        float swirl = fbm(vec2(r * 0.9, phi * 3.0 + u_time * (2.0 / max(r, 1.5))) + 2.0);
        float filaments = smoothstep(0.35, 0.92, swirl);

        vec3 tangent = normalize(cross(diskNormal, normalize(vec3(hit.x, 0.0, hit.z))));
        float beta = clamp(sqrt(RS / max(2.0 * r, 1e-3)), 0.0, 0.65);
        float gamma = inversesqrt(max(1.0 - beta * beta, 1e-3));
        float cosTheta = dot(normalize(rayDir), tangent);
        float D = 1.0 / (gamma * (1.0 - beta * cosTheta));
        float beaming = pow(D, 3.0);

        float g = sqrt(max(1.0 - RS / max(r, RS * 1.001), 0.0));

        float approach = smoothstep(-0.15, 0.5, cosTheta);
        vec3 shift = mix(vec3(1.15, 0.95, 0.85), vec3(0.75, 0.85, 1.15), approach);

        float normalTerm = 0.35 + 0.65 * max(0.0, dot(-rayDir, diskNormal));
        float density = filaments * normalTerm * (1.25 / (0.25 + r));
        vec3 emission = base * shift * density * beaming * g;
        return emission;
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;

        float angX = u_mouse.x + u_time * 0.05;
        float angY = (u_mouse.y - 0.5) * 2.0;
        mat3 rotX = mat3(cos(angX), 0, sin(angX), 0, 1, 0, -sin(angX), 0, cos(angX));
        mat3 rotY = mat3(1, 0, 0, 0, cos(angY), -sin(angY), 0, sin(angY), cos(angY));
        mat3 camRot = rotX * rotY;

        float camDist = max(u_camDist, 2.1 * RS);
        vec3 camPos = camRot * vec3(0.0, 0.0, -camDist);
        vec3 target = vec3(0.0);
        vec3 fwd = normalize(target - camPos);
        vec3 worldUp = vec3(0.0, 1.0, 0.0);
        vec3 right = normalize(cross(fwd, worldUp));
        vec3 up = normalize(cross(right, fwd));

        float fov = clamp(u_fov, 0.55, 1.65);
        vec3 rayDir0 = normalize(fwd + uv.x * fov * right + uv.y * fov * up);

        vec3 col = vec3(0.0);
        float glow = 0.0;
        int captureCount = 0;

        vec3 diskNormal = normalize(vec3(0.0, 1.0, 0.08));

        vec3 rhat_out = normalize(camPos);
        vec3 rhat_in = -rhat_out;
        float cosA = clamp(dot(rayDir0, rhat_in), -1.0, 1.0);
        float sinA = sqrt(max(1.0 - cosA * cosA, 0.0));

        float rCam = length(camPos);
        float fStatic = sqrt(max(1.0 - RS / rCam, 1e-4));
        float b = (rCam * sinA) / fStatic;
        float invb2 = 1.0 / max(b * b, 1e-6);

        vec3 e1 = rhat_out;
        vec3 e2 = normalize(rayDir0 - dot(rayDir0, e1) * e1);
        if (length(e2) < 1e-5) {
            e2 = normalize(cross(vec3(0.0, 1.0, 0.0), e1));
        }

        float u = 1.0 / rCam;
        float wAbs0 = sqrt(max(du_dphi_sq(u, invb2), 0.0));
        float inward = step(0.0, cosA);
        float w = mix(-wAbs0, wAbs0, inward);
        float phi = 0.0;

        vec3 p = pos_from_u(u, phi, e1, e2);
        vec3 v = ray_dir_from_u(u, w, phi, e1, e2);

        for(int i = 0; i < MAX_STEPS; i++) {
            vec3 p_old = p;
            float r0 = 1.0 / max(u, 1e-4);

            float dphi = 0.022 + 0.065 * clamp(r0 / 28.0, 0.0, 1.0);
            dphi *= mix(0.35, 1.0, smoothstep(1.2 * RS, 6.0 * RS, r0));
            dphi = clamp(dphi, 0.012, 0.10);

            float drag = u_spin * (RS * RS) / max(r0 * r0 * r0, 1e-4);
            phi += dphi * (1.0 + drag);

            rk4_u_step(u, w, dphi, invb2);
            p = pos_from_u(u, phi, e1, e2);
            v = ray_dir_from_u(u, w, phi, e1, e2);

            float r = length(p);

            if (r < RS * 1.001) {
                col *= 0.0;
                break;
            }

            if (r < R_PHOTON) {
                float inwardNow = step(0.0, -dot(normalize(p), v));
                captureCount += int(inwardNow);
                if (captureCount > 10) {
                    col *= 0.0;
                    break;
                }
            }

            if(r > FAR_RADIUS) {
                col += sample_sky(v);
                break;
            }

            float d0 = dot(p_old, diskNormal);
            float d1 = dot(p, diskNormal);
            if (d0 * d1 < 0.0) {
                float tHit = d0 / (d0 - d1);
                vec3 hit = mix(p_old, p, clamp(tHit, 0.0, 1.0));
                float hr = length(hit);
                if (hr > R_DISK_IN && hr < R_DISK_OUT) {
                    vec3 e = disk_emission(hit, v, diskNormal);
                    col += e;
                    glow += dot(e, vec3(0.333));
                    if (dot(col, vec3(0.333)) > 2.2) break;
                }
            }
        }

        col += vec3(1.0, 0.55, 0.25) * glow * 0.10;
        col = col / (col + vec3(1.0));
        fragColor = vec4(pow(max(col, 0.0), vec3(0.4545)), 1.0);
    }
</script>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
        alert("WebGL 2 not supported by your browser.");
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source.trim()); 
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vsSource = document.getElementById('vs').textContent;
    const fsSource = document.getElementById('fs').textContent;

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
    
    const posLoc = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const resLoc = gl.getUniformLocation(program, "u_res");
    const timeLoc = gl.getUniformLocation(program, "u_time");
    const mouseLoc = gl.getUniformLocation(program, "u_mouse");
    const camDistLoc = gl.getUniformLocation(program, "u_camDist");
    const fovLoc = gl.getUniformLocation(program, "u_fov");
    const spinLoc = gl.getUniformLocation(program, "u_spin");

    let mx = 0, my = 0.5;
    let camDist = 12.0;
    let fov = 1.15;
    let spin = 0.0;
    window.addEventListener('mousemove', (e) => {
        mx = (e.clientX / window.innerWidth) * 6.28;
        my = (e.clientY / window.innerHeight);
    });

    window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        camDist = Math.min(55, Math.max(4.0, camDist + delta * 0.8));
        fov = Math.min(1.55, Math.max(0.70, fov + delta * 0.03));
    }, { passive: false });

    window.addEventListener('keydown', (e) => {
        if (e.key === 'k' || e.key === 'K') {
            spin = (spin > 0.0) ? 0.0 : 1.0;
        }
    });

    function render(time) {
        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        gl.uniform2f(resLoc, canvas.width, canvas.height);
        gl.uniform2f(mouseLoc, mx, my);
        gl.uniform1f(timeLoc, time * 0.001);
        gl.uniform1f(camDistLoc, camDist);
        gl.uniform1f(fovLoc, fov);
        gl.uniform1f(spinLoc, spin);
        
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>